
zephyr.elf:     file format elf32-i386


Disassembly of section .init:

00003178 <_init>:
    3178:	53                   	push   %ebx
    3179:	83 ec 08             	sub    $0x8,%esp
    317c:	e8 9f 02 00 00       	call   3420 <__x86.get_pc_thunk.bx>
    3181:	81 c3 c7 8d 00 00    	add    $0x8dc7,%ebx
    3187:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    318d:	85 c0                	test   %eax,%eax
    318f:	74 05                	je     3196 <_init+0x1e>
    3191:	e8 82 02 00 00       	call   3418 <__gmon_start__@plt>
    3196:	83 c4 08             	add    $0x8,%esp
    3199:	5b                   	pop    %ebx
    319a:	c3                   	ret    

Disassembly of section .plt:

000031a0 <.plt>:
    31a0:	ff b3 04 00 00 00    	pushl  0x4(%ebx)
    31a6:	ff a3 08 00 00 00    	jmp    *0x8(%ebx)
    31ac:	00 00                	add    %al,(%eax)
	...

000031b0 <pthread_mutex_unlock@plt>:
    31b0:	ff a3 0c 00 00 00    	jmp    *0xc(%ebx)
    31b6:	68 00 00 00 00       	push   $0x0
    31bb:	e9 e0 ff ff ff       	jmp    31a0 <.plt>

000031c0 <__snprintf_chk@plt>:
    31c0:	ff a3 10 00 00 00    	jmp    *0x10(%ebx)
    31c6:	68 08 00 00 00       	push   $0x8
    31cb:	e9 d0 ff ff ff       	jmp    31a0 <.plt>

000031d0 <strcmp@plt>:
    31d0:	ff a3 14 00 00 00    	jmp    *0x14(%ebx)
    31d6:	68 10 00 00 00       	push   $0x10
    31db:	e9 c0 ff ff ff       	jmp    31a0 <.plt>

000031e0 <__vfprintf_chk@plt>:
    31e0:	ff a3 18 00 00 00    	jmp    *0x18(%ebx)
    31e6:	68 18 00 00 00       	push   $0x18
    31eb:	e9 b0 ff ff ff       	jmp    31a0 <.plt>

000031f0 <pthread_cond_broadcast@plt>:
    31f0:	ff a3 1c 00 00 00    	jmp    *0x1c(%ebx)
    31f6:	68 20 00 00 00       	push   $0x20
    31fb:	e9 a0 ff ff ff       	jmp    31a0 <.plt>

00003200 <free@plt>:
    3200:	ff a3 20 00 00 00    	jmp    *0x20(%ebx)
    3206:	68 28 00 00 00       	push   $0x28
    320b:	e9 90 ff ff ff       	jmp    31a0 <.plt>

00003210 <__pthread_register_cancel@plt>:
    3210:	ff a3 24 00 00 00    	jmp    *0x24(%ebx)
    3216:	68 30 00 00 00       	push   $0x30
    321b:	e9 80 ff ff ff       	jmp    31a0 <.plt>

00003220 <clock_gettime@plt>:
    3220:	ff a3 28 00 00 00    	jmp    *0x28(%ebx)
    3226:	68 38 00 00 00       	push   $0x38
    322b:	e9 70 ff ff ff       	jmp    31a0 <.plt>

00003230 <pthread_self@plt>:
    3230:	ff a3 2c 00 00 00    	jmp    *0x2c(%ebx)
    3236:	68 40 00 00 00       	push   $0x40
    323b:	e9 60 ff ff ff       	jmp    31a0 <.plt>

00003240 <pthread_cond_wait@plt>:
    3240:	ff a3 30 00 00 00    	jmp    *0x30(%ebx)
    3246:	68 48 00 00 00       	push   $0x48
    324b:	e9 50 ff ff ff       	jmp    31a0 <.plt>

00003250 <sleep@plt>:
    3250:	ff a3 34 00 00 00    	jmp    *0x34(%ebx)
    3256:	68 50 00 00 00       	push   $0x50
    325b:	e9 40 ff ff ff       	jmp    31a0 <.plt>

00003260 <__stack_chk_fail@plt>:
    3260:	ff a3 38 00 00 00    	jmp    *0x38(%ebx)
    3266:	68 58 00 00 00       	push   $0x58
    326b:	e9 30 ff ff ff       	jmp    31a0 <.plt>

00003270 <pthread_mutex_lock@plt>:
    3270:	ff a3 3c 00 00 00    	jmp    *0x3c(%ebx)
    3276:	68 60 00 00 00       	push   $0x60
    327b:	e9 20 ff ff ff       	jmp    31a0 <.plt>

00003280 <strtoll@plt>:
    3280:	ff a3 40 00 00 00    	jmp    *0x40(%ebx)
    3286:	68 68 00 00 00       	push   $0x68
    328b:	e9 10 ff ff ff       	jmp    31a0 <.plt>

00003290 <realloc@plt>:
    3290:	ff a3 44 00 00 00    	jmp    *0x44(%ebx)
    3296:	68 70 00 00 00       	push   $0x70
    329b:	e9 00 ff ff ff       	jmp    31a0 <.plt>

000032a0 <exit@plt>:
    32a0:	ff a3 48 00 00 00    	jmp    *0x48(%ebx)
    32a6:	68 78 00 00 00       	push   $0x78
    32ab:	e9 f0 fe ff ff       	jmp    31a0 <.plt>

000032b0 <strtoul@plt>:
    32b0:	ff a3 4c 00 00 00    	jmp    *0x4c(%ebx)
    32b6:	68 80 00 00 00       	push   $0x80
    32bb:	e9 e0 fe ff ff       	jmp    31a0 <.plt>

000032c0 <__libc_start_main@plt>:
    32c0:	ff a3 50 00 00 00    	jmp    *0x50(%ebx)
    32c6:	68 88 00 00 00       	push   $0x88
    32cb:	e9 d0 fe ff ff       	jmp    31a0 <.plt>

000032d0 <strcasecmp@plt>:
    32d0:	ff a3 54 00 00 00    	jmp    *0x54(%ebx)
    32d6:	68 90 00 00 00       	push   $0x90
    32db:	e9 c0 fe ff ff       	jmp    31a0 <.plt>

000032e0 <setvbuf@plt>:
    32e0:	ff a3 58 00 00 00    	jmp    *0x58(%ebx)
    32e6:	68 98 00 00 00       	push   $0x98
    32eb:	e9 b0 fe ff ff       	jmp    31a0 <.plt>

000032f0 <snprintf@plt>:
    32f0:	ff a3 5c 00 00 00    	jmp    *0x5c(%ebx)
    32f6:	68 a0 00 00 00       	push   $0xa0
    32fb:	e9 a0 fe ff ff       	jmp    31a0 <.plt>

00003300 <putchar@plt>:
    3300:	ff a3 60 00 00 00    	jmp    *0x60(%ebx)
    3306:	68 a8 00 00 00       	push   $0xa8
    330b:	e9 90 fe ff ff       	jmp    31a0 <.plt>

00003310 <pthread_cancel@plt>:
    3310:	ff a3 64 00 00 00    	jmp    *0x64(%ebx)
    3316:	68 b0 00 00 00       	push   $0xb0
    331b:	e9 80 fe ff ff       	jmp    31a0 <.plt>

00003320 <strncpy@plt>:
    3320:	ff a3 68 00 00 00    	jmp    *0x68(%ebx)
    3326:	68 b8 00 00 00       	push   $0xb8
    332b:	e9 70 fe ff ff       	jmp    31a0 <.plt>

00003330 <strtoull@plt>:
    3330:	ff a3 6c 00 00 00    	jmp    *0x6c(%ebx)
    3336:	68 c0 00 00 00       	push   $0xc0
    333b:	e9 60 fe ff ff       	jmp    31a0 <.plt>

00003340 <strtod@plt>:
    3340:	ff a3 70 00 00 00    	jmp    *0x70(%ebx)
    3346:	68 c8 00 00 00       	push   $0xc8
    334b:	e9 50 fe ff ff       	jmp    31a0 <.plt>

00003350 <pthread_exit@plt>:
    3350:	ff a3 74 00 00 00    	jmp    *0x74(%ebx)
    3356:	68 d0 00 00 00       	push   $0xd0
    335b:	e9 40 fe ff ff       	jmp    31a0 <.plt>

00003360 <__sigsetjmp@plt>:
    3360:	ff a3 78 00 00 00    	jmp    *0x78(%ebx)
    3366:	68 d8 00 00 00       	push   $0xd8
    336b:	e9 30 fe ff ff       	jmp    31a0 <.plt>

00003370 <sigemptyset@plt>:
    3370:	ff a3 7c 00 00 00    	jmp    *0x7c(%ebx)
    3376:	68 e0 00 00 00       	push   $0xe0
    337b:	e9 20 fe ff ff       	jmp    31a0 <.plt>

00003380 <__pthread_unwind_next@plt>:
    3380:	ff a3 80 00 00 00    	jmp    *0x80(%ebx)
    3386:	68 e8 00 00 00       	push   $0xe8
    338b:	e9 10 fe ff ff       	jmp    31a0 <.plt>

00003390 <nanosleep@plt>:
    3390:	ff a3 84 00 00 00    	jmp    *0x84(%ebx)
    3396:	68 f0 00 00 00       	push   $0xf0
    339b:	e9 00 fe ff ff       	jmp    31a0 <.plt>

000033a0 <__fprintf_chk@plt>:
    33a0:	ff a3 88 00 00 00    	jmp    *0x88(%ebx)
    33a6:	68 f8 00 00 00       	push   $0xf8
    33ab:	e9 f0 fd ff ff       	jmp    31a0 <.plt>

000033b0 <pthread_create@plt>:
    33b0:	ff a3 8c 00 00 00    	jmp    *0x8c(%ebx)
    33b6:	68 00 01 00 00       	push   $0x100
    33bb:	e9 e0 fd ff ff       	jmp    31a0 <.plt>

000033c0 <sigaction@plt>:
    33c0:	ff a3 90 00 00 00    	jmp    *0x90(%ebx)
    33c6:	68 08 01 00 00       	push   $0x108
    33cb:	e9 d0 fd ff ff       	jmp    31a0 <.plt>

000033d0 <pthread_detach@plt>:
    33d0:	ff a3 94 00 00 00    	jmp    *0x94(%ebx)
    33d6:	68 10 01 00 00       	push   $0x110
    33db:	e9 c0 fd ff ff       	jmp    31a0 <.plt>

000033e0 <isatty@plt>:
    33e0:	ff a3 98 00 00 00    	jmp    *0x98(%ebx)
    33e6:	68 18 01 00 00       	push   $0x118
    33eb:	e9 b0 fd ff ff       	jmp    31a0 <.plt>

000033f0 <strtol@plt>:
    33f0:	ff a3 9c 00 00 00    	jmp    *0x9c(%ebx)
    33f6:	68 20 01 00 00       	push   $0x120
    33fb:	e9 a0 fd ff ff       	jmp    31a0 <.plt>

00003400 <calloc@plt>:
    3400:	ff a3 a0 00 00 00    	jmp    *0xa0(%ebx)
    3406:	68 28 01 00 00       	push   $0x128
    340b:	e9 90 fd ff ff       	jmp    31a0 <.plt>

Disassembly of section .plt.got:

00003410 <__cxa_finalize@plt>:
    3410:	ff a3 a8 00 00 00    	jmp    *0xa8(%ebx)
    3416:	66 90                	xchg   %ax,%ax

00003418 <__gmon_start__@plt>:
    3418:	ff a3 ac 00 00 00    	jmp    *0xac(%ebx)
    341e:	66 90                	xchg   %ax,%ax

Disassembly of section .text:

00003420 <__x86.get_pc_thunk.bx>:
    3420:	8b 1c 24             	mov    (%esp),%ebx
    3423:	c3                   	ret    
    3424:	66 90                	xchg   %ax,%ax
    3426:	66 90                	xchg   %ax,%ax
    3428:	66 90                	xchg   %ax,%ax
    342a:	66 90                	xchg   %ax,%ax
    342c:	66 90                	xchg   %ax,%ax
    342e:	66 90                	xchg   %ax,%ax

00003430 <deregister_tm_clones>:
    3430:	e8 a3 02 00 00       	call   36d8 <__x86.get_pc_thunk.dx>
    3435:	81 c2 13 8b 00 00    	add    $0x8b13,%edx
    343b:	8d 8a d4 02 00 00    	lea    0x2d4(%edx),%ecx
    3441:	8d 82 d4 02 00 00    	lea    0x2d4(%edx),%eax
    3447:	39 c8                	cmp    %ecx,%eax
    3449:	74 1d                	je     3468 <deregister_tm_clones+0x38>
    344b:	8b 82 a4 00 00 00    	mov    0xa4(%edx),%eax
    3451:	85 c0                	test   %eax,%eax
    3453:	74 13                	je     3468 <deregister_tm_clones+0x38>
    3455:	55                   	push   %ebp
    3456:	89 e5                	mov    %esp,%ebp
    3458:	83 ec 14             	sub    $0x14,%esp
    345b:	51                   	push   %ecx
    345c:	ff d0                	call   *%eax
    345e:	83 c4 10             	add    $0x10,%esp
    3461:	c9                   	leave  
    3462:	c3                   	ret    
    3463:	90                   	nop
    3464:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    3468:	f3 c3                	repz ret 
    346a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00003470 <register_tm_clones>:
    3470:	e8 63 02 00 00       	call   36d8 <__x86.get_pc_thunk.dx>
    3475:	81 c2 d3 8a 00 00    	add    $0x8ad3,%edx
    347b:	55                   	push   %ebp
    347c:	8d 8a d4 02 00 00    	lea    0x2d4(%edx),%ecx
    3482:	8d 82 d4 02 00 00    	lea    0x2d4(%edx),%eax
    3488:	29 c8                	sub    %ecx,%eax
    348a:	89 e5                	mov    %esp,%ebp
    348c:	53                   	push   %ebx
    348d:	c1 f8 02             	sar    $0x2,%eax
    3490:	89 c3                	mov    %eax,%ebx
    3492:	83 ec 04             	sub    $0x4,%esp
    3495:	c1 eb 1f             	shr    $0x1f,%ebx
    3498:	01 d8                	add    %ebx,%eax
    349a:	d1 f8                	sar    %eax
    349c:	74 14                	je     34b2 <register_tm_clones+0x42>
    349e:	8b 92 b4 00 00 00    	mov    0xb4(%edx),%edx
    34a4:	85 d2                	test   %edx,%edx
    34a6:	74 0a                	je     34b2 <register_tm_clones+0x42>
    34a8:	83 ec 08             	sub    $0x8,%esp
    34ab:	50                   	push   %eax
    34ac:	51                   	push   %ecx
    34ad:	ff d2                	call   *%edx
    34af:	83 c4 10             	add    $0x10,%esp
    34b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    34b5:	c9                   	leave  
    34b6:	c3                   	ret    
    34b7:	89 f6                	mov    %esi,%esi
    34b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000034c0 <__do_global_dtors_aux>:
    34c0:	55                   	push   %ebp
    34c1:	89 e5                	mov    %esp,%ebp
    34c3:	53                   	push   %ebx
    34c4:	e8 57 ff ff ff       	call   3420 <__x86.get_pc_thunk.bx>
    34c9:	81 c3 7f 8a 00 00    	add    $0x8a7f,%ebx
    34cf:	83 ec 04             	sub    $0x4,%esp
    34d2:	80 bb 54 1b 00 00 00 	cmpb   $0x0,0x1b54(%ebx)
    34d9:	75 27                	jne    3502 <__do_global_dtors_aux+0x42>
    34db:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    34e1:	85 c0                	test   %eax,%eax
    34e3:	74 11                	je     34f6 <__do_global_dtors_aux+0x36>
    34e5:	83 ec 0c             	sub    $0xc,%esp
    34e8:	ff b3 a8 02 00 00    	pushl  0x2a8(%ebx)
    34ee:	e8 1d ff ff ff       	call   3410 <__cxa_finalize@plt>
    34f3:	83 c4 10             	add    $0x10,%esp
    34f6:	e8 35 ff ff ff       	call   3430 <deregister_tm_clones>
    34fb:	c6 83 54 1b 00 00 01 	movb   $0x1,0x1b54(%ebx)
    3502:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3505:	c9                   	leave  
    3506:	c3                   	ret    
    3507:	89 f6                	mov    %esi,%esi
    3509:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003510 <frame_dummy>:
    3510:	55                   	push   %ebp
    3511:	89 e5                	mov    %esp,%ebp
    3513:	5d                   	pop    %ebp
    3514:	e9 57 ff ff ff       	jmp    3470 <register_tm_clones>
    3519:	66 90                	xchg   %ax,%ax
    351b:	66 90                	xchg   %ax,%ax
    351d:	66 90                	xchg   %ax,%ax
    351f:	90                   	nop

00003520 <__udivdi3>:
    3520:	55                   	push   %ebp
    3521:	57                   	push   %edi
    3522:	56                   	push   %esi
    3523:	53                   	push   %ebx
    3524:	83 ec 1c             	sub    $0x1c,%esp
    3527:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    352b:	8b 6c 24 30          	mov    0x30(%esp),%ebp
    352f:	8b 74 24 34          	mov    0x34(%esp),%esi
    3533:	8b 5c 24 38          	mov    0x38(%esp),%ebx
    3537:	85 d2                	test   %edx,%edx
    3539:	75 35                	jne    3570 <__udivdi3+0x50>
    353b:	39 f3                	cmp    %esi,%ebx
    353d:	0f 87 bd 00 00 00    	ja     3600 <__udivdi3+0xe0>
    3543:	85 db                	test   %ebx,%ebx
    3545:	89 d9                	mov    %ebx,%ecx
    3547:	75 0b                	jne    3554 <__udivdi3+0x34>
    3549:	b8 01 00 00 00       	mov    $0x1,%eax
    354e:	31 d2                	xor    %edx,%edx
    3550:	f7 f3                	div    %ebx
    3552:	89 c1                	mov    %eax,%ecx
    3554:	31 d2                	xor    %edx,%edx
    3556:	89 f0                	mov    %esi,%eax
    3558:	f7 f1                	div    %ecx
    355a:	89 c6                	mov    %eax,%esi
    355c:	89 e8                	mov    %ebp,%eax
    355e:	89 f7                	mov    %esi,%edi
    3560:	f7 f1                	div    %ecx
    3562:	89 fa                	mov    %edi,%edx
    3564:	83 c4 1c             	add    $0x1c,%esp
    3567:	5b                   	pop    %ebx
    3568:	5e                   	pop    %esi
    3569:	5f                   	pop    %edi
    356a:	5d                   	pop    %ebp
    356b:	c3                   	ret    
    356c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    3570:	39 f2                	cmp    %esi,%edx
    3572:	77 7c                	ja     35f0 <__udivdi3+0xd0>
    3574:	0f bd fa             	bsr    %edx,%edi
    3577:	83 f7 1f             	xor    $0x1f,%edi
    357a:	0f 84 98 00 00 00    	je     3618 <__udivdi3+0xf8>
    3580:	89 f9                	mov    %edi,%ecx
    3582:	b8 20 00 00 00       	mov    $0x20,%eax
    3587:	29 f8                	sub    %edi,%eax
    3589:	d3 e2                	shl    %cl,%edx
    358b:	89 54 24 08          	mov    %edx,0x8(%esp)
    358f:	89 c1                	mov    %eax,%ecx
    3591:	89 da                	mov    %ebx,%edx
    3593:	d3 ea                	shr    %cl,%edx
    3595:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    3599:	09 d1                	or     %edx,%ecx
    359b:	89 f2                	mov    %esi,%edx
    359d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    35a1:	89 f9                	mov    %edi,%ecx
    35a3:	d3 e3                	shl    %cl,%ebx
    35a5:	89 c1                	mov    %eax,%ecx
    35a7:	d3 ea                	shr    %cl,%edx
    35a9:	89 f9                	mov    %edi,%ecx
    35ab:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
    35af:	d3 e6                	shl    %cl,%esi
    35b1:	89 eb                	mov    %ebp,%ebx
    35b3:	89 c1                	mov    %eax,%ecx
    35b5:	d3 eb                	shr    %cl,%ebx
    35b7:	09 de                	or     %ebx,%esi
    35b9:	89 f0                	mov    %esi,%eax
    35bb:	f7 74 24 08          	divl   0x8(%esp)
    35bf:	89 d6                	mov    %edx,%esi
    35c1:	89 c3                	mov    %eax,%ebx
    35c3:	f7 64 24 0c          	mull   0xc(%esp)
    35c7:	39 d6                	cmp    %edx,%esi
    35c9:	72 0c                	jb     35d7 <__udivdi3+0xb7>
    35cb:	89 f9                	mov    %edi,%ecx
    35cd:	d3 e5                	shl    %cl,%ebp
    35cf:	39 c5                	cmp    %eax,%ebp
    35d1:	73 5d                	jae    3630 <__udivdi3+0x110>
    35d3:	39 d6                	cmp    %edx,%esi
    35d5:	75 59                	jne    3630 <__udivdi3+0x110>
    35d7:	8d 43 ff             	lea    -0x1(%ebx),%eax
    35da:	31 ff                	xor    %edi,%edi
    35dc:	89 fa                	mov    %edi,%edx
    35de:	83 c4 1c             	add    $0x1c,%esp
    35e1:	5b                   	pop    %ebx
    35e2:	5e                   	pop    %esi
    35e3:	5f                   	pop    %edi
    35e4:	5d                   	pop    %ebp
    35e5:	c3                   	ret    
    35e6:	8d 76 00             	lea    0x0(%esi),%esi
    35e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
    35f0:	31 ff                	xor    %edi,%edi
    35f2:	31 c0                	xor    %eax,%eax
    35f4:	89 fa                	mov    %edi,%edx
    35f6:	83 c4 1c             	add    $0x1c,%esp
    35f9:	5b                   	pop    %ebx
    35fa:	5e                   	pop    %esi
    35fb:	5f                   	pop    %edi
    35fc:	5d                   	pop    %ebp
    35fd:	c3                   	ret    
    35fe:	66 90                	xchg   %ax,%ax
    3600:	31 ff                	xor    %edi,%edi
    3602:	89 e8                	mov    %ebp,%eax
    3604:	89 f2                	mov    %esi,%edx
    3606:	f7 f3                	div    %ebx
    3608:	89 fa                	mov    %edi,%edx
    360a:	83 c4 1c             	add    $0x1c,%esp
    360d:	5b                   	pop    %ebx
    360e:	5e                   	pop    %esi
    360f:	5f                   	pop    %edi
    3610:	5d                   	pop    %ebp
    3611:	c3                   	ret    
    3612:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    3618:	39 f2                	cmp    %esi,%edx
    361a:	72 06                	jb     3622 <__udivdi3+0x102>
    361c:	31 c0                	xor    %eax,%eax
    361e:	39 eb                	cmp    %ebp,%ebx
    3620:	77 d2                	ja     35f4 <__udivdi3+0xd4>
    3622:	b8 01 00 00 00       	mov    $0x1,%eax
    3627:	eb cb                	jmp    35f4 <__udivdi3+0xd4>
    3629:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    3630:	89 d8                	mov    %ebx,%eax
    3632:	31 ff                	xor    %edi,%edi
    3634:	eb be                	jmp    35f4 <__udivdi3+0xd4>
    3636:	66 90                	xchg   %ax,%ax
    3638:	66 90                	xchg   %ax,%ax
    363a:	66 90                	xchg   %ax,%ax
    363c:	66 90                	xchg   %ax,%ax
    363e:	66 90                	xchg   %ax,%ax

00003640 <__libc_csu_init>:
    3640:	55                   	push   %ebp
    3641:	57                   	push   %edi
    3642:	56                   	push   %esi
    3643:	53                   	push   %ebx
    3644:	e8 d7 fd ff ff       	call   3420 <__x86.get_pc_thunk.bx>
    3649:	81 c3 ff 88 00 00    	add    $0x88ff,%ebx
    364f:	83 ec 0c             	sub    $0xc,%esp
    3652:	8b 6c 24 28          	mov    0x28(%esp),%ebp
    3656:	8d b3 ec fe ff ff    	lea    -0x114(%ebx),%esi
    365c:	e8 17 fb ff ff       	call   3178 <_init>
    3661:	8d 83 e8 fe ff ff    	lea    -0x118(%ebx),%eax
    3667:	29 c6                	sub    %eax,%esi
    3669:	c1 fe 02             	sar    $0x2,%esi
    366c:	85 f6                	test   %esi,%esi
    366e:	74 25                	je     3695 <__libc_csu_init+0x55>
    3670:	31 ff                	xor    %edi,%edi
    3672:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    3678:	83 ec 04             	sub    $0x4,%esp
    367b:	55                   	push   %ebp
    367c:	ff 74 24 2c          	pushl  0x2c(%esp)
    3680:	ff 74 24 2c          	pushl  0x2c(%esp)
    3684:	ff 94 bb e8 fe ff ff 	call   *-0x118(%ebx,%edi,4)
    368b:	83 c7 01             	add    $0x1,%edi
    368e:	83 c4 10             	add    $0x10,%esp
    3691:	39 fe                	cmp    %edi,%esi
    3693:	75 e3                	jne    3678 <__libc_csu_init+0x38>
    3695:	83 c4 0c             	add    $0xc,%esp
    3698:	5b                   	pop    %ebx
    3699:	5e                   	pop    %esi
    369a:	5f                   	pop    %edi
    369b:	5d                   	pop    %ebp
    369c:	c3                   	ret    
    369d:	8d 76 00             	lea    0x0(%esi),%esi

000036a0 <__libc_csu_fini>:
    36a0:	f3 c3                	repz ret 

000036a2 <_start>:
    36a2:	31 ed                	xor    %ebp,%ebp
    36a4:	5e                   	pop    %esi
    36a5:	89 e1                	mov    %esp,%ecx
    36a7:	83 e4 f0             	and    $0xfffffff0,%esp
    36aa:	50                   	push   %eax
    36ab:	54                   	push   %esp
    36ac:	52                   	push   %edx
    36ad:	e8 22 00 00 00       	call   36d4 <_start+0x32>
    36b2:	81 c3 96 88 00 00    	add    $0x8896,%ebx
    36b8:	8d 83 58 77 ff ff    	lea    -0x88a8(%ebx),%eax
    36be:	50                   	push   %eax
    36bf:	8d 83 f8 76 ff ff    	lea    -0x8908(%ebx),%eax
    36c5:	50                   	push   %eax
    36c6:	51                   	push   %ecx
    36c7:	56                   	push   %esi
    36c8:	ff b3 b0 00 00 00    	pushl  0xb0(%ebx)
    36ce:	e8 ed fb ff ff       	call   32c0 <__libc_start_main@plt>
    36d3:	f4                   	hlt    
    36d4:	8b 1c 24             	mov    (%esp),%ebx
    36d7:	c3                   	ret    

000036d8 <__x86.get_pc_thunk.dx>:
    36d8:	8b 14 24             	mov    (%esp),%edx
    36db:	c3                   	ret    

000036dc <unit_test_noop>:
 * Unit test / setup function / teardown function that does
 * nothing, successfully. Can be used as a parameter to
 * ztest_unit_test_setup_teardown().
 */
static inline void unit_test_noop(void)
{
    36dc:	55                   	push   %ebp
    36dd:	89 e5                	mov    %esp,%ebp
}
    36df:	5d                   	pop    %ebp
    36e0:	c3                   	ret    

000036e1 <test_main>:

extern void test_suit_placeholder(void);

/* test case main entry */
void test_main(void)
{
    36e1:	55                   	push   %ebp
    36e2:	89 e5                	mov    %esp,%ebp
    36e4:	83 ec 10             	sub    $0x10,%esp
    ztest_test_suite(suit_tests,
        ztest_unit_test(test_suit_placeholder));
    ztest_run_test_suite(suit_tests);
    36e7:	68 00 c0 00 00       	push   $0xc000
    36ec:	68 44 8b 00 00       	push   $0x8b44
    36f1:	e8 4a 2b 00 00       	call   6240 <z_ztest_run_test_suite>
    36f6:	83 c4 10             	add    $0x10,%esp
}
    36f9:	c9                   	leave  
    36fa:	c3                   	ret    

000036fb <test_suit_placeholder>:
#include <ztest.h>
#include <zoot/suit.h>
#include "vectors.h"

void test_suit_placeholder(void) {
    36fb:	55                   	push   %ebp
    36fc:	89 e5                	mov    %esp,%ebp
    36fe:	83 ec 14             	sub    $0x14,%esp
    printk("WARNING - This test has not been implemented.\n");
    3701:	68 65 8b 00 00       	push   $0x8b65
    3706:	e8 84 08 00 00       	call   3f8f <printk>
    370b:	83 c4 10             	add    $0x10,%esp
    zassert_false(0, ""); 
}
    370e:	c9                   	leave  
    370f:	c3                   	ret    

00003710 <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
    3710:	55                   	push   %ebp
    3711:	89 e5                	mov    %esp,%ebp
    3713:	56                   	push   %esi
    3714:	53                   	push   %ebx
    3715:	6b da 0c             	imul   $0xc,%edx,%ebx
    3718:	03 58 0c             	add    0xc(%eax),%ebx
	u32_t *bitarray = level <= p->max_inline_level ?
    371b:	0f be 40 0b          	movsbl 0xb(%eax),%eax
		p->levels[level].bits : p->levels[level].bits_p;
    371f:	39 d0                	cmp    %edx,%eax
    3721:	7d 02                	jge    3725 <get_bit_ptr+0x15>
    3723:	8b 1b                	mov    (%ebx),%ebx

	*word = &bitarray[bn / 32];
    3725:	89 c8                	mov    %ecx,%eax
    3727:	be 20 00 00 00       	mov    $0x20,%esi
    372c:	99                   	cltd   
    372d:	f7 fe                	idiv   %esi
    372f:	8d 14 83             	lea    (%ebx,%eax,4),%edx
    3732:	8b 45 08             	mov    0x8(%ebp),%eax
    3735:	89 10                	mov    %edx,(%eax)

	return bn & 0x1f;
    3737:	89 c8                	mov    %ecx,%eax
}
    3739:	5b                   	pop    %ebx
	return bn & 0x1f;
    373a:	83 e0 1f             	and    $0x1f,%eax
}
    373d:	5e                   	pop    %esi
    373e:	5d                   	pop    %ebp
    373f:	c3                   	ret    

00003740 <z_sys_mem_pool_base_init>:

	return (*word >> (4*(bit / 4))) & 0xf;
}

void z_sys_mem_pool_base_init(struct sys_mem_pool_base *p)
{
    3740:	55                   	push   %ebp
    3741:	89 e5                	mov    %esp,%ebp
    3743:	57                   	push   %edi
    3744:	56                   	push   %esi
    3745:	53                   	push   %ebx
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);

	p->max_inline_level = -1;

	for (i = 0; i < p->n_levels; i++) {
    3746:	31 db                	xor    %ebx,%ebx
{
    3748:	83 ec 14             	sub    $0x14,%esp
    374b:	8b 4d 08             	mov    0x8(%ebp),%ecx
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    374e:	8b 41 08             	mov    0x8(%ecx),%eax
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    3751:	8b 31                	mov    (%ecx),%esi
	p->max_inline_level = -1;
    3753:	c6 41 0b ff          	movb   $0xff,0xb(%ecx)
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    3757:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
    375b:	8b 41 04             	mov    0x4(%ecx),%eax
    375e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3761:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    3765:	0f af 45 f0          	imul   -0x10(%ebp),%eax
    3769:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
    376c:	01 c6                	add    %eax,%esi
	for (i = 0; i < p->n_levels; i++) {
    376e:	0f b6 41 0a          	movzbl 0xa(%ecx),%eax
    3772:	89 45 e0             	mov    %eax,-0x20(%ebp)
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
    3775:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3778:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (i = 0; i < p->n_levels; i++) {
    377b:	39 5d e0             	cmp    %ebx,-0x20(%ebp)
    377e:	7e 40                	jle    37c0 <z_sys_mem_pool_base_init+0x80>
		int nblocks = buflen / sz;
    3780:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3783:	31 d2                	xor    %edx,%edx
    3785:	f7 75 ec             	divl   -0x14(%ebp)

		sys_dlist_init(&p->levels[i].free_list);
    3788:	6b d3 0c             	imul   $0xc,%ebx,%edx
    378b:	03 51 0c             	add    0xc(%ecx),%edx

		if (nblocks <= sizeof(p->levels[i].bits)*8) {
    378e:	83 f8 20             	cmp    $0x20,%eax
		sys_dlist_init(&p->levels[i].free_list);
    3791:	8d 7a 04             	lea    0x4(%edx),%edi
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    3794:	89 7a 04             	mov    %edi,0x4(%edx)
	list->tail = (sys_dnode_t *)list;
    3797:	89 7a 08             	mov    %edi,0x8(%edx)
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
    379a:	77 05                	ja     37a1 <z_sys_mem_pool_base_init+0x61>
			p->max_inline_level = i;
    379c:	88 59 0b             	mov    %bl,0xb(%ecx)
    379f:	eb 10                	jmp    37b1 <z_sys_mem_pool_base_init+0x71>
		} else {
			p->levels[i].bits_p = bits;
			bits += (nblocks + 31)/32;
    37a1:	83 c0 1f             	add    $0x1f,%eax
			p->levels[i].bits_p = bits;
    37a4:	89 32                	mov    %esi,(%edx)
			bits += (nblocks + 31)/32;
    37a6:	bf 20 00 00 00       	mov    $0x20,%edi
    37ab:	99                   	cltd   
    37ac:	f7 ff                	idiv   %edi
    37ae:	8d 34 86             	lea    (%esi,%eax,4),%esi
		}

		sz = WB_DN(sz / 4);
    37b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
	for (i = 0; i < p->n_levels; i++) {
    37b4:	43                   	inc    %ebx
		sz = WB_DN(sz / 4);
    37b5:	c1 e8 02             	shr    $0x2,%eax
    37b8:	83 e0 fc             	and    $0xfffffffc,%eax
    37bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    37be:	eb bb                	jmp    377b <z_sys_mem_pool_base_init+0x3b>
	}

	for (i = 0; i < p->n_max; i++) {
    37c0:	0f b7 75 ea          	movzwl -0x16(%ebp),%esi
    37c4:	31 c0                	xor    %eax,%eax
    37c6:	31 db                	xor    %ebx,%ebx
    37c8:	89 75 ec             	mov    %esi,-0x14(%ebp)
    37cb:	8b 75 f0             	mov    -0x10(%ebp),%esi
    37ce:	01 c6                	add    %eax,%esi
    37d0:	39 5d ec             	cmp    %ebx,-0x14(%ebp)
    37d3:	7e 1d                	jle    37f2 <z_sys_mem_pool_base_init+0xb2>
		void *block = block_ptr(p, p->max_sz, i);

		sys_dlist_append(&p->levels[0].free_list, block);
    37d5:	8b 51 0c             	mov    0xc(%ecx),%edx
	return (u8_t *)p->buf + lsz * block;
    37d8:	03 01                	add    (%ecx),%eax
	for (i = 0; i < p->n_max; i++) {
    37da:	43                   	inc    %ebx
		sys_dlist_append(&p->levels[0].free_list, block);
    37db:	8d 7a 04             	lea    0x4(%edx),%edi
    37de:	89 38                	mov    %edi,(%eax)
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
	node->prev = list->tail;
    37e0:	8b 7a 08             	mov    0x8(%edx),%edi
    37e3:	89 78 04             	mov    %edi,0x4(%eax)

	list->tail->next = node;
    37e6:	8b 7a 08             	mov    0x8(%edx),%edi
    37e9:	89 07                	mov    %eax,(%edi)
	list->tail = node;
    37eb:	89 42 08             	mov    %eax,0x8(%edx)
	for (i = 0; i < p->n_max; i++) {
    37ee:	89 f0                	mov    %esi,%eax
    37f0:	eb d9                	jmp    37cb <z_sys_mem_pool_base_init+0x8b>
	}
}
    37f2:	83 c4 14             	add    $0x14,%esp
    37f5:	5b                   	pop    %ebx
    37f6:	5e                   	pop    %esi
    37f7:	5f                   	pop    %edi
    37f8:	5d                   	pop    %ebp
    37f9:	c3                   	ret    

000037fa <z_sys_mem_pool_block_free>:
	return 0;
}

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
    37fa:	55                   	push   %ebp
    37fb:	89 e5                	mov    %esp,%ebp
    37fd:	57                   	push   %edi
    37fe:	56                   	push   %esi
    37ff:	53                   	push   %ebx
    3800:	83 ec 3c             	sub    $0x3c,%esp
    3803:	8b 5d 08             	mov    0x8(%ebp),%ebx
    3806:	8b 7d 0c             	mov    0xc(%ebp),%edi
    3809:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    380f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    3812:	31 c0                	xor    %eax,%eax
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    3814:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
    3818:	8b 53 04             	mov    0x4(%ebx),%edx
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    381b:	8d 04 85 12 00 00 00 	lea    0x12(,%eax,4),%eax
    3822:	25 f0 07 00 00       	and    $0x7f0,%eax
    3827:	29 c4                	sub    %eax,%esp
    3829:	8d 44 24 03          	lea    0x3(%esp),%eax
    382d:	c1 e8 02             	shr    $0x2,%eax
    3830:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
	lsizes[0] = p->max_sz;
    3837:	89 14 85 00 00 00 00 	mov    %edx,0x0(,%eax,4)
	for (i = 1; i <= level; i++) {
    383e:	b8 01 00 00 00       	mov    $0x1,%eax
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
    3843:	89 4d cc             	mov    %ecx,-0x34(%ebp)
	for (i = 1; i <= level; i++) {
    3846:	39 c7                	cmp    %eax,%edi
    3848:	72 1b                	jb     3865 <z_sys_mem_pool_block_free+0x6b>
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
    384a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    384d:	8b 75 cc             	mov    -0x34(%ebp),%esi
    3850:	8b 4c 81 fc          	mov    -0x4(%ecx,%eax,4),%ecx
    3854:	89 ca                	mov    %ecx,%edx
    3856:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    3859:	c1 ea 02             	shr    $0x2,%edx
    385c:	83 e2 fc             	and    $0xfffffffc,%edx
    385f:	89 14 86             	mov    %edx,(%esi,%eax,4)
	for (i = 1; i <= level; i++) {
    3862:	40                   	inc    %eax
    3863:	eb e1                	jmp    3846 <z_sys_mem_pool_block_free+0x4c>
	}

	block_free(p, level, lsizes, block);
    3865:	8b 45 10             	mov    0x10(%ebp),%eax
    3868:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return 0;
    386b:	31 c0                	xor    %eax,%eax
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    386d:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
    3871:	74 05                	je     3878 <z_sys_mem_pool_block_free+0x7e>
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
    3873:	e8 f2 1b 00 00       	call   546a <posix_irq_lock>
	unsigned int key = pool_irq_lock(p);
    3878:	89 45 d0             	mov    %eax,-0x30(%ebp)
	while (level >= 0) {
    387b:	85 ff                	test   %edi,%edi
    387d:	0f 88 4d 01 00 00    	js     39d0 <z_sys_mem_pool_block_free+0x1d6>
		int i, lsz = lsizes[level];
    3883:	8b 45 cc             	mov    -0x34(%ebp),%eax
	return (u8_t *)p->buf + lsz * block;
    3886:	8b 75 d4             	mov    -0x2c(%ebp),%esi
	int bit = get_bit_ptr(p, level, bn, &word);
    3889:	83 ec 0c             	sub    $0xc,%esp
    388c:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    388f:	89 fa                	mov    %edi,%edx
		int i, lsz = lsizes[level];
    3891:	8b 04 b8             	mov    (%eax,%edi,4),%eax
	return (u8_t *)p->buf + lsz * block;
    3894:	0f af f0             	imul   %eax,%esi
		int i, lsz = lsizes[level];
    3897:	89 45 c8             	mov    %eax,-0x38(%ebp)
	int bit = get_bit_ptr(p, level, bn, &word);
    389a:	8d 45 e0             	lea    -0x20(%ebp),%eax
	return (u8_t *)p->buf + lsz * block;
    389d:	03 33                	add    (%ebx),%esi
	int bit = get_bit_ptr(p, level, bn, &word);
    389f:	50                   	push   %eax
    38a0:	89 d8                	mov    %ebx,%eax
    38a2:	e8 69 fe ff ff       	call   3710 <get_bit_ptr>
	return (*word >> bit) & 1;
    38a7:	8b 55 e0             	mov    -0x20(%ebp),%edx
	int bit = get_bit_ptr(p, level, bn, &word);
    38aa:	83 c4 10             	add    $0x10,%esp
	return (*word >> bit) & 1;
    38ad:	8b 12                	mov    (%edx),%edx
		__ASSERT(alloc_bit_is_set(p, level, bn),
    38af:	0f a3 c2             	bt     %eax,%edx
    38b2:	72 3a                	jb     38ee <z_sys_mem_pool_block_free+0xf4>
    38b4:	68 a3 00 00 00       	push   $0xa3
    38b9:	68 94 8b 00 00       	push   $0x8b94
    38be:	68 c7 8b 00 00       	push   $0x8bc7
    38c3:	68 e6 8b 00 00       	push   $0x8be6
    38c8:	e8 c2 06 00 00       	call   3f8f <printk>
    38cd:	59                   	pop    %ecx
    38ce:	58                   	pop    %eax
    38cf:	56                   	push   %esi
    38d0:	68 03 8c 00 00       	push   $0x8c03
    38d5:	e8 b5 06 00 00       	call   3f8f <printk>
    38da:	58                   	pop    %eax
    38db:	5a                   	pop    %edx
    38dc:	68 a3 00 00 00       	push   $0xa3
    38e1:	68 94 8b 00 00       	push   $0x8b94
    38e6:	e8 38 07 00 00       	call   4023 <assert_post_action>
    38eb:	83 c4 10             	add    $0x10,%esp
	int bit = get_bit_ptr(p, level, bn, &word);
    38ee:	8d 45 e0             	lea    -0x20(%ebp),%eax
    38f1:	83 ec 0c             	sub    $0xc,%esp
    38f4:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    38f7:	89 fa                	mov    %edi,%edx
    38f9:	50                   	push   %eax
    38fa:	89 d8                	mov    %ebx,%eax
    38fc:	e8 0f fe ff ff       	call   3710 <get_bit_ptr>
    3901:	89 c1                	mov    %eax,%ecx
	*word &= ~(1<<bit);
    3903:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3906:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
    390b:	d3 c2                	rol    %cl,%edx
	int bit = get_bit_ptr(p, level, bn, &word);
    390d:	83 c4 10             	add    $0x10,%esp
	*word &= ~(1<<bit);
    3910:	21 10                	and    %edx,(%eax)
		sys_dlist_append(&p->levels[level].free_list, block);
    3912:	6b c7 0c             	imul   $0xc,%edi,%eax
    3915:	03 43 0c             	add    0xc(%ebx),%eax
    3918:	8d 50 04             	lea    0x4(%eax),%edx
    391b:	89 16                	mov    %edx,(%esi)
	node->prev = list->tail;
    391d:	8b 50 08             	mov    0x8(%eax),%edx
    3920:	89 56 04             	mov    %edx,0x4(%esi)
	list->tail->next = node;
    3923:	8b 50 08             	mov    0x8(%eax),%edx
    3926:	89 32                	mov    %esi,(%edx)
	list->tail = node;
    3928:	89 70 08             	mov    %esi,0x8(%eax)
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    392b:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
    392f:	74 0e                	je     393f <z_sys_mem_pool_block_free+0x145>
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
    3931:	83 ec 0c             	sub    $0xc,%esp
    3934:	ff 75 d0             	pushl  -0x30(%ebp)
    3937:	e8 40 1b 00 00       	call   547c <posix_irq_unlock>
    393c:	83 c4 10             	add    $0x10,%esp
		return 0;
    393f:	31 c0                	xor    %eax,%eax
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    3941:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
    3945:	74 05                	je     394c <z_sys_mem_pool_block_free+0x152>
	return posix_irq_lock();
    3947:	e8 1e 1b 00 00       	call   546a <posix_irq_lock>
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
    394c:	85 ff                	test   %edi,%edi
		key = pool_irq_lock(p);
    394e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
    3951:	0f 84 b9 00 00 00    	je     3a10 <z_sys_mem_pool_block_free+0x216>
	int bit = get_bit_ptr(p, level, bn, &word);
    3957:	8d 45 e0             	lea    -0x20(%ebp),%eax
    395a:	83 ec 0c             	sub    $0xc,%esp
    395d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    3960:	89 fa                	mov    %edi,%edx
	return (*word >> (4*(bit / 4))) & 0xf;
    3962:	be 04 00 00 00       	mov    $0x4,%esi
	int bit = get_bit_ptr(p, level, bn, &word);
    3967:	50                   	push   %eax
    3968:	89 d8                	mov    %ebx,%eax
    396a:	e8 a1 fd ff ff       	call   3710 <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
    396f:	99                   	cltd   
	int bit = get_bit_ptr(p, level, bn, &word);
    3970:	83 c4 10             	add    $0x10,%esp
	return (*word >> (4*(bit / 4))) & 0xf;
    3973:	f7 fe                	idiv   %esi
    3975:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    397c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    397f:	8b 00                	mov    (%eax),%eax
    3981:	d3 e8                	shr    %cl,%eax
    3983:	89 c1                	mov    %eax,%ecx
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
    3985:	83 e1 0f             	and    $0xf,%ecx
    3988:	0f 85 82 00 00 00    	jne    3a10 <z_sys_mem_pool_block_free+0x216>
			int b = (bn & ~3) + i;
    398e:	8b 75 d4             	mov    -0x2c(%ebp),%esi
    3991:	83 e6 fc             	and    $0xfffffffc,%esi
    3994:	89 75 c4             	mov    %esi,-0x3c(%ebp)
    3997:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    399a:	01 c8                	add    %ecx,%eax
		for (i = 0; i < 4; i++) {
    399c:	41                   	inc    %ecx
	return (u8_t *)p->buf + lsz * block;
    399d:	0f af 45 c8          	imul   -0x38(%ebp),%eax
    39a1:	03 03                	add    (%ebx),%eax
		for (i = 0; i < 4; i++) {
    39a3:	83 f9 04             	cmp    $0x4,%ecx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    39a6:	8b 30                	mov    (%eax),%esi
    39a8:	8b 50 04             	mov    0x4(%eax),%edx
    39ab:	89 32                	mov    %esi,(%edx)
	node->next->prev = node->prev;
    39ad:	8b 30                	mov    (%eax),%esi
    39af:	89 56 04             	mov    %edx,0x4(%esi)
	node->next = NULL;
    39b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
    39b8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    39bf:	75 d6                	jne    3997 <z_sys_mem_pool_block_free+0x19d>
		bn = bn / 4;
    39c1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
		level = level - 1;
    39c4:	4f                   	dec    %edi
		bn = bn / 4;
    39c5:	99                   	cltd   
    39c6:	f7 f9                	idiv   %ecx
    39c8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    39cb:	e9 ab fe ff ff       	jmp    387b <z_sys_mem_pool_block_free+0x81>
	__ASSERT(0, "out of levels");
    39d0:	68 bc 00 00 00       	push   $0xbc
    39d5:	68 94 8b 00 00       	push   $0x8b94
    39da:	68 94 9e 00 00       	push   $0x9e94
    39df:	68 e6 8b 00 00       	push   $0x8be6
    39e4:	e8 a6 05 00 00       	call   3f8f <printk>
    39e9:	c7 04 24 28 8c 00 00 	movl   $0x8c28,(%esp)
    39f0:	e8 9a 05 00 00       	call   3f8f <printk>
    39f5:	58                   	pop    %eax
    39f6:	5a                   	pop    %edx
    39f7:	68 bc 00 00 00       	push   $0xbc
    39fc:	68 94 8b 00 00       	push   $0x8b94
    3a01:	e8 1d 06 00 00       	call   4023 <assert_post_action>
    3a06:	83 c4 10             	add    $0x10,%esp
	return -1;
    3a09:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
	if (p->flags & SYS_MEM_POOL_KERNEL) {
    3a10:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
    3a14:	74 0e                	je     3a24 <z_sys_mem_pool_block_free+0x22a>
	posix_irq_unlock(key);
    3a16:	83 ec 0c             	sub    $0xc,%esp
    3a19:	ff 75 d0             	pushl  -0x30(%ebp)
    3a1c:	e8 5b 1a 00 00       	call   547c <posix_irq_unlock>
    3a21:	83 c4 10             	add    $0x10,%esp
}
    3a24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3a27:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    3a2e:	74 05                	je     3a35 <z_sys_mem_pool_block_free+0x23b>
    3a30:	e8 fc ff ff ff       	call   3a31 <z_sys_mem_pool_block_free+0x237>
    3a35:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3a38:	5b                   	pop    %ebx
    3a39:	5e                   	pop    %esi
    3a3a:	5f                   	pop    %edi
    3a3b:	5d                   	pop    %ebp
    3a3c:	c3                   	ret    

00003a3d <arch_printk_char_out>:
 *
 * @return 0
 */
/* LCOV_EXCL_START */
__attribute__((weak)) int arch_printk_char_out(int c)
{
    3a3d:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    3a3e:	31 c0                	xor    %eax,%eax
{
    3a40:	89 e5                	mov    %esp,%ebp
}
    3a42:	5d                   	pop    %ebp
    3a43:	c3                   	ret    

00003a44 <print_err>:
	return _char_out;
}
#endif /* CONFIG_PRINTK */

static void print_err(out_func_t out, void *ctx)
{
    3a44:	55                   	push   %ebp
    3a45:	89 e5                	mov    %esp,%ebp
    3a47:	56                   	push   %esi
    3a48:	89 d6                	mov    %edx,%esi
    3a4a:	53                   	push   %ebx
    3a4b:	89 c3                	mov    %eax,%ebx
	out('E', ctx);
    3a4d:	50                   	push   %eax
    3a4e:	50                   	push   %eax
    3a4f:	52                   	push   %edx
    3a50:	6a 45                	push   $0x45
    3a52:	ff d3                	call   *%ebx
    3a54:	5a                   	pop    %edx
    3a55:	59                   	pop    %ecx
	out('R', ctx);
    3a56:	56                   	push   %esi
    3a57:	6a 52                	push   $0x52
    3a59:	ff d3                	call   *%ebx
    3a5b:	58                   	pop    %eax
    3a5c:	5a                   	pop    %edx
	out('R', ctx);
    3a5d:	56                   	push   %esi
    3a5e:	6a 52                	push   $0x52
    3a60:	ff d3                	call   *%ebx
    3a62:	83 c4 10             	add    $0x10,%esp
}
    3a65:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3a68:	5b                   	pop    %ebx
    3a69:	5e                   	pop    %esi
    3a6a:	5d                   	pop    %ebp
    3a6b:	c3                   	ret    

00003a6c <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
    3a6c:	55                   	push   %ebp
    3a6d:	89 e5                	mov    %esp,%ebp
    3a6f:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct out_context *ctx = ctx_p;

	ctx->count++;
    3a72:	ff 00                	incl   (%eax)
	return _char_out(c);
}
    3a74:	5d                   	pop    %ebp
	return _char_out(c);
    3a75:	ff 25 f4 c1 00 00    	jmp    *0xc1f4

00003a7b <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    3a7b:	55                   	push   %ebp
    3a7c:	89 e5                	mov    %esp,%ebp
    3a7e:	57                   	push   %edi
    3a7f:	56                   	push   %esi
    3a80:	53                   	push   %ebx
    3a81:	89 c3                	mov    %eax,%ebx
    3a83:	89 d6                	mov    %edx,%esi
    3a85:	ba 01 00 00 00       	mov    $0x1,%edx
    3a8a:	bf 00 ca 9a 3b       	mov    $0x3b9aca00,%edi
    3a8f:	83 ec 2c             	sub    $0x2c,%esp
    3a92:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a95:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    3a98:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
    3a9f:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
    3aa6:	85 c0                	test   %eax,%eax
    3aa8:	0f 4f d0             	cmovg  %eax,%edx
    3aab:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
    3aaf:	b8 20 00 00 00       	mov    $0x20,%eax
    3ab4:	89 55 d8             	mov    %edx,-0x28(%ebp)
    3ab7:	ba 30 00 00 00       	mov    $0x30,%edx
    3abc:	0f 44 c2             	cmove  %edx,%eax
    3abf:	31 c9                	xor    %ecx,%ecx
    3ac1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
    3ac4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    3ac7:	39 d7                	cmp    %edx,%edi
    3ac9:	76 04                	jbe    3acf <_printk_dec_ulong+0x54>
    3acb:	85 c9                	test   %ecx,%ecx
    3acd:	74 1d                	je     3aec <_printk_dec_ulong+0x71>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
    3acf:	50                   	push   %eax
    3ad0:	50                   	push   %eax
    3ad1:	31 d2                	xor    %edx,%edx
    3ad3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3ad6:	56                   	push   %esi
    3ad7:	f7 f7                	div    %edi
    3ad9:	83 c0 30             	add    $0x30,%eax
    3adc:	50                   	push   %eax
    3add:	ff d3                	call   *%ebx
    3adf:	83 c4 10             	add    $0x10,%esp
			digits++;
    3ae2:	ff 45 e0             	incl   -0x20(%ebp)
			found_largest_digit = 1;
    3ae5:	b9 01 00 00 00       	mov    $0x1,%ecx
    3aea:	eb 1e                	jmp    3b0a <_printk_dec_ulong+0x8f>
		} else if (remaining <= min_width
    3aec:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3aef:	39 4d d8             	cmp    %ecx,-0x28(%ebp)
    3af2:	7c 14                	jl     3b08 <_printk_dec_ulong+0x8d>
    3af4:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
    3af8:	77 0e                	ja     3b08 <_printk_dec_ulong+0x8d>
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    3afa:	51                   	push   %ecx
    3afb:	51                   	push   %ecx
    3afc:	56                   	push   %esi
    3afd:	ff 75 d4             	pushl  -0x2c(%ebp)
    3b00:	ff d3                	call   *%ebx
			digits++;
    3b02:	ff 45 e0             	incl   -0x20(%ebp)
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    3b05:	83 c4 10             	add    $0x10,%esp
    3b08:	31 c9                	xor    %ecx,%ecx
		}
		remaining--;
		remainder %= pos;
    3b0a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3b0d:	31 d2                	xor    %edx,%edx
		remaining--;
    3b0f:	ff 4d dc             	decl   -0x24(%ebp)
		remainder %= pos;
    3b12:	f7 f7                	div    %edi
		pos /= 10;
    3b14:	89 f8                	mov    %edi,%eax
    3b16:	bf 0a 00 00 00       	mov    $0xa,%edi
		remainder %= pos;
    3b1b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		pos /= 10;
    3b1e:	31 d2                	xor    %edx,%edx
    3b20:	f7 f7                	div    %edi
	while (pos >= 10) {
    3b22:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
		pos /= 10;
    3b26:	89 c7                	mov    %eax,%edi
	while (pos >= 10) {
    3b28:	75 9a                	jne    3ac4 <_printk_dec_ulong+0x49>
	}
	out((int)(remainder + 48), ctx);
    3b2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3b2d:	52                   	push   %edx
    3b2e:	52                   	push   %edx
    3b2f:	56                   	push   %esi
    3b30:	83 c0 30             	add    $0x30,%eax
    3b33:	50                   	push   %eax
    3b34:	ff d3                	call   *%ebx
    3b36:	83 c4 10             	add    $0x10,%esp

	if (padding == PAD_SPACE_AFTER) {
    3b39:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
    3b3d:	75 19                	jne    3b58 <_printk_dec_ulong+0xdd>
		remaining = min_width - digits;
    3b3f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3b42:	2b 45 e0             	sub    -0x20(%ebp),%eax
    3b45:	89 c7                	mov    %eax,%edi
		while (remaining-- > 0) {
    3b47:	85 ff                	test   %edi,%edi
    3b49:	7e 0d                	jle    3b58 <_printk_dec_ulong+0xdd>
			out(' ', ctx);
    3b4b:	50                   	push   %eax
    3b4c:	50                   	push   %eax
    3b4d:	4f                   	dec    %edi
    3b4e:	56                   	push   %esi
    3b4f:	6a 20                	push   $0x20
    3b51:	ff d3                	call   *%ebx
    3b53:	83 c4 10             	add    $0x10,%esp
    3b56:	eb ef                	jmp    3b47 <_printk_dec_ulong+0xcc>
		}
	}
}
    3b58:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3b5b:	5b                   	pop    %ebx
    3b5c:	5e                   	pop    %esi
    3b5d:	5f                   	pop    %edi
    3b5e:	5d                   	pop    %ebp
    3b5f:	c3                   	ret    

00003b60 <__printk_hook_install>:
{
    3b60:	55                   	push   %ebp
    3b61:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
    3b63:	8b 45 08             	mov    0x8(%ebp),%eax
}
    3b66:	5d                   	pop    %ebp
	_char_out = fn;
    3b67:	a3 f4 c1 00 00       	mov    %eax,0xc1f4
}
    3b6c:	c3                   	ret    

00003b6d <z_vprintk>:
{
    3b6d:	55                   	push   %ebp
    3b6e:	89 e5                	mov    %esp,%ebp
    3b70:	57                   	push   %edi
    3b71:	56                   	push   %esi
    3b72:	53                   	push   %ebx
	int might_format = 0; /* 1 if encountered a '%' */
    3b73:	31 f6                	xor    %esi,%esi
{
    3b75:	83 ec 3c             	sub    $0x3c,%esp
    3b78:	8b 7d 08             	mov    0x8(%ebp),%edi
    3b7b:	8b 5d 14             	mov    0x14(%ebp),%ebx
	char length_mod = 0;
    3b7e:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
	int min_width = -1;
    3b82:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
	enum pad_type padding = PAD_NONE;
    3b89:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	while (*fmt) {
    3b90:	8b 45 10             	mov    0x10(%ebp),%eax
    3b93:	0f be 00             	movsbl (%eax),%eax
    3b96:	84 c0                	test   %al,%al
    3b98:	0f 84 a7 03 00 00    	je     3f45 <z_vprintk+0x3d8>
		if (!might_format) {
    3b9e:	85 f6                	test   %esi,%esi
    3ba0:	75 18                	jne    3bba <z_vprintk+0x4d>
			if (*fmt != '%') {
    3ba2:	3c 25                	cmp    $0x25,%al
    3ba4:	0f 84 41 03 00 00    	je     3eeb <z_vprintk+0x37e>
				out((int)*fmt, ctx);
    3baa:	52                   	push   %edx
    3bab:	52                   	push   %edx
    3bac:	ff 75 0c             	pushl  0xc(%ebp)
    3baf:	50                   	push   %eax
    3bb0:	ff d7                	call   *%edi
    3bb2:	83 c4 10             	add    $0x10,%esp
    3bb5:	e9 71 03 00 00       	jmp    3f2b <z_vprintk+0x3be>
			switch (*fmt) {
    3bba:	3c 64                	cmp    $0x64,%al
    3bbc:	0f 84 0a 01 00 00    	je     3ccc <z_vprintk+0x15f>
    3bc2:	7f 51                	jg     3c15 <z_vprintk+0xa8>
    3bc4:	3c 39                	cmp    $0x39,%al
    3bc6:	7f 2c                	jg     3bf4 <z_vprintk+0x87>
    3bc8:	3c 31                	cmp    $0x31,%al
    3bca:	0f 8d a8 00 00 00    	jge    3c78 <z_vprintk+0x10b>
    3bd0:	3c 2d                	cmp    $0x2d,%al
    3bd2:	0f 84 2c 03 00 00    	je     3f04 <z_vprintk+0x397>
    3bd8:	3c 30                	cmp    $0x30,%al
    3bda:	0f 84 88 00 00 00    	je     3c68 <z_vprintk+0xfb>
    3be0:	3c 25                	cmp    $0x25,%al
    3be2:	0f 85 e7 02 00 00    	jne    3ecf <z_vprintk+0x362>
				out((int)'%', ctx);
    3be8:	56                   	push   %esi
    3be9:	56                   	push   %esi
    3bea:	ff 75 0c             	pushl  0xc(%ebp)
    3bed:	6a 25                	push   $0x25
    3bef:	e9 f0 02 00 00       	jmp    3ee4 <z_vprintk+0x377>
			switch (*fmt) {
    3bf4:	3c 58                	cmp    $0x58,%al
    3bf6:	0f 84 8a 01 00 00    	je     3d86 <z_vprintk+0x219>
    3bfc:	3c 63                	cmp    $0x63,%al
    3bfe:	0f 85 cb 02 00 00    	jne    3ecf <z_vprintk+0x362>
				int c = va_arg(ap, int);
    3c04:	8d 73 04             	lea    0x4(%ebx),%esi
				out(c, ctx);
    3c07:	50                   	push   %eax
    3c08:	50                   	push   %eax
    3c09:	ff 75 0c             	pushl  0xc(%ebp)
    3c0c:	ff 33                	pushl  (%ebx)
    3c0e:	ff d7                	call   *%edi
    3c10:	e9 b5 02 00 00       	jmp    3eca <z_vprintk+0x35d>
			switch (*fmt) {
    3c15:	3c 70                	cmp    $0x70,%al
    3c17:	0f 84 46 01 00 00    	je     3d63 <z_vprintk+0x1f6>
    3c1d:	7f 1a                	jg     3c39 <z_vprintk+0xcc>
    3c1f:	3c 69                	cmp    $0x69,%al
    3c21:	0f 84 a5 00 00 00    	je     3ccc <z_vprintk+0x15f>
    3c27:	3c 6c                	cmp    $0x6c,%al
    3c29:	0f 84 80 00 00 00    	je     3caf <z_vprintk+0x142>
    3c2f:	3c 68                	cmp    $0x68,%al
    3c31:	0f 85 98 02 00 00    	jne    3ecf <z_vprintk+0x362>
    3c37:	eb 6b                	jmp    3ca4 <z_vprintk+0x137>
    3c39:	3c 75                	cmp    $0x75,%al
    3c3b:	0f 84 da 00 00 00    	je     3d1b <z_vprintk+0x1ae>
    3c41:	7f 14                	jg     3c57 <z_vprintk+0xea>
    3c43:	3c 73                	cmp    $0x73,%al
    3c45:	0f 85 84 02 00 00    	jne    3ecf <z_vprintk+0x362>
				char *s = va_arg(ap, char *);
    3c4b:	8b 13                	mov    (%ebx),%edx
    3c4d:	8d 73 04             	lea    0x4(%ebx),%esi
    3c50:	89 d3                	mov    %edx,%ebx
				while (*s) {
    3c52:	e9 36 02 00 00       	jmp    3e8d <z_vprintk+0x320>
			switch (*fmt) {
    3c57:	3c 78                	cmp    $0x78,%al
    3c59:	0f 84 27 01 00 00    	je     3d86 <z_vprintk+0x219>
    3c5f:	3c 7a                	cmp    $0x7a,%al
    3c61:	74 4c                	je     3caf <z_vprintk+0x142>
    3c63:	e9 67 02 00 00       	jmp    3ecf <z_vprintk+0x362>
				if (min_width < 0 && padding == PAD_NONE) {
    3c68:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    3c6c:	79 0a                	jns    3c78 <z_vprintk+0x10b>
    3c6e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    3c72:	0f 84 95 02 00 00    	je     3f0d <z_vprintk+0x3a0>
				if (min_width < 0) {
    3c78:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    3c7c:	79 05                	jns    3c83 <z_vprintk+0x116>
					min_width = *fmt - '0';
    3c7e:	83 e8 30             	sub    $0x30,%eax
    3c81:	eb 08                	jmp    3c8b <z_vprintk+0x11e>
					min_width = 10 * min_width + *fmt - '0';
    3c83:	6b 55 e0 0a          	imul   $0xa,-0x20(%ebp),%edx
    3c87:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
				if (padding == PAD_NONE) {
    3c8b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
					min_width = 10 * min_width + *fmt - '0';
    3c8f:	89 45 e0             	mov    %eax,-0x20(%ebp)
				if (padding == PAD_NONE) {
    3c92:	0f 85 93 02 00 00    	jne    3f2b <z_vprintk+0x3be>
					padding = PAD_SPACE_BEFORE;
    3c98:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    3c9f:	e9 87 02 00 00       	jmp    3f2b <z_vprintk+0x3be>
				if (*fmt == 'h' && length_mod == 'h') {
    3ca4:	80 7d e7 68          	cmpb   $0x68,-0x19(%ebp)
    3ca8:	75 13                	jne    3cbd <z_vprintk+0x150>
    3caa:	e9 67 02 00 00       	jmp    3f16 <z_vprintk+0x3a9>
				} else if (*fmt == 'l' && length_mod == 'l') {
    3caf:	80 7d e7 6c          	cmpb   $0x6c,-0x19(%ebp)
    3cb3:	75 08                	jne    3cbd <z_vprintk+0x150>
    3cb5:	3c 6c                	cmp    $0x6c,%al
    3cb7:	0f 84 5f 02 00 00    	je     3f1c <z_vprintk+0x3af>
				} else if (length_mod == 0) {
    3cbd:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
    3cc1:	0f 85 08 02 00 00    	jne    3ecf <z_vprintk+0x362>
    3cc7:	e9 56 02 00 00       	jmp    3f22 <z_vprintk+0x3b5>
				if (length_mod == 'z') {
    3ccc:	80 7d e7 7a          	cmpb   $0x7a,-0x19(%ebp)
    3cd0:	74 27                	je     3cf9 <z_vprintk+0x18c>
				} else if (length_mod == 'l') {
    3cd2:	80 7d e7 6c          	cmpb   $0x6c,-0x19(%ebp)
    3cd6:	74 21                	je     3cf9 <z_vprintk+0x18c>
				} else if (length_mod == 'L') {
    3cd8:	80 7d e7 4c          	cmpb   $0x4c,-0x19(%ebp)
    3cdc:	75 1b                	jne    3cf9 <z_vprintk+0x18c>
					long long lld = va_arg(ap, long long);
    3cde:	8b 0b                	mov    (%ebx),%ecx
    3ce0:	8d 73 08             	lea    0x8(%ebx),%esi
    3ce3:	8b 5b 04             	mov    0x4(%ebx),%ebx
					if (lld > __LONG_MAX__ ||
    3ce6:	89 c8                	mov    %ecx,%eax
    3ce8:	89 da                	mov    %ebx,%edx
    3cea:	05 00 00 00 80       	add    $0x80000000,%eax
    3cef:	83 d2 00             	adc    $0x0,%edx
    3cf2:	83 fa 00             	cmp    $0x0,%edx
    3cf5:	76 07                	jbe    3cfe <z_vprintk+0x191>
    3cf7:	eb 3f                	jmp    3d38 <z_vprintk+0x1cb>
					d = va_arg(ap, int);
    3cf9:	8b 0b                	mov    (%ebx),%ecx
    3cfb:	8d 73 04             	lea    0x4(%ebx),%esi
				if (d < 0) {
    3cfe:	85 c9                	test   %ecx,%ecx
    3d00:	79 4a                	jns    3d4c <z_vprintk+0x1df>
    3d02:	89 4d d0             	mov    %ecx,-0x30(%ebp)
					out((int)'-', ctx);
    3d05:	50                   	push   %eax
    3d06:	50                   	push   %eax
    3d07:	ff 75 0c             	pushl  0xc(%ebp)
    3d0a:	6a 2d                	push   $0x2d
    3d0c:	ff d7                	call   *%edi
					d = -d;
    3d0e:	8b 4d d0             	mov    -0x30(%ebp),%ecx
					out((int)'-', ctx);
    3d11:	83 c4 10             	add    $0x10,%esp
					min_width--;
    3d14:	ff 4d e0             	decl   -0x20(%ebp)
					d = -d;
    3d17:	f7 d9                	neg    %ecx
    3d19:	eb 31                	jmp    3d4c <z_vprintk+0x1df>
				if (length_mod == 'z') {
    3d1b:	80 7d e7 7a          	cmpb   $0x7a,-0x19(%ebp)
    3d1f:	74 26                	je     3d47 <z_vprintk+0x1da>
				} else if (length_mod == 'l') {
    3d21:	80 7d e7 6c          	cmpb   $0x6c,-0x19(%ebp)
    3d25:	74 20                	je     3d47 <z_vprintk+0x1da>
				} else if (length_mod == 'L') {
    3d27:	80 7d e7 4c          	cmpb   $0x4c,-0x19(%ebp)
    3d2b:	75 1a                	jne    3d47 <z_vprintk+0x1da>
					if (llu > ~0UL) {
    3d2d:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
					unsigned long long llu =
    3d31:	8d 73 08             	lea    0x8(%ebx),%esi
					u = llu;
    3d34:	8b 0b                	mov    (%ebx),%ecx
					if (llu > ~0UL) {
    3d36:	74 14                	je     3d4c <z_vprintk+0x1df>
						print_err(out, ctx);
    3d38:	8b 55 0c             	mov    0xc(%ebp),%edx
    3d3b:	89 f8                	mov    %edi,%eax
    3d3d:	e8 02 fd ff ff       	call   3a44 <print_err>
    3d42:	e9 e0 01 00 00       	jmp    3f27 <z_vprintk+0x3ba>
					u = va_arg(ap, unsigned int);
    3d47:	8b 0b                	mov    (%ebx),%ecx
    3d49:	8d 73 04             	lea    0x4(%ebx),%esi
				_printk_dec_ulong(out, ctx, u, padding,
    3d4c:	8b 55 0c             	mov    0xc(%ebp),%edx
    3d4f:	53                   	push   %ebx
    3d50:	89 f8                	mov    %edi,%eax
    3d52:	53                   	push   %ebx
    3d53:	ff 75 e0             	pushl  -0x20(%ebp)
    3d56:	ff 75 dc             	pushl  -0x24(%ebp)
    3d59:	e8 1d fd ff ff       	call   3a7b <_printk_dec_ulong>
    3d5e:	e9 67 01 00 00       	jmp    3eca <z_vprintk+0x35d>
				out('0', ctx);
    3d63:	50                   	push   %eax
    3d64:	50                   	push   %eax
    3d65:	ff 75 0c             	pushl  0xc(%ebp)
    3d68:	6a 30                	push   $0x30
    3d6a:	ff d7                	call   *%edi
    3d6c:	5a                   	pop    %edx
    3d6d:	59                   	pop    %ecx
				out('x', ctx);
    3d6e:	ff 75 0c             	pushl  0xc(%ebp)
    3d71:	6a 78                	push   $0x78
    3d73:	ff d7                	call   *%edi
					min_width = 8;
    3d75:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
				padding = PAD_ZERO_BEFORE;
    3d7c:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
				out('x', ctx);
    3d83:	83 c4 10             	add    $0x10,%esp
				if (*fmt == 'p') {
    3d86:	8b 45 10             	mov    0x10(%ebp),%eax
    3d89:	80 38 70             	cmpb   $0x70,(%eax)
					x = (uintptr_t)va_arg(ap, void *);
    3d8c:	8b 03                	mov    (%ebx),%eax
				if (*fmt == 'p') {
    3d8e:	74 1a                	je     3daa <z_vprintk+0x23d>
				} else if (length_mod == 'l') {
    3d90:	80 7d e7 6c          	cmpb   $0x6c,-0x19(%ebp)
    3d94:	74 14                	je     3daa <z_vprintk+0x23d>
				} else if (length_mod == 'L') {
    3d96:	80 7d e7 4c          	cmpb   $0x4c,-0x19(%ebp)
    3d9a:	75 0e                	jne    3daa <z_vprintk+0x23d>
					x = va_arg(ap, unsigned long long);
    3d9c:	8b 53 04             	mov    0x4(%ebx),%edx
    3d9f:	89 45 d0             	mov    %eax,-0x30(%ebp)
    3da2:	83 c3 08             	add    $0x8,%ebx
    3da5:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    3da8:	eb 0b                	jmp    3db5 <z_vprintk+0x248>
					x = va_arg(ap, unsigned int);
    3daa:	31 d2                	xor    %edx,%edx
    3dac:	89 45 d0             	mov    %eax,-0x30(%ebp)
    3daf:	83 c3 04             	add    $0x4,%ebx
    3db2:	89 55 d4             	mov    %edx,-0x2c(%ebp)
	int remaining = 16; /* 16 digits max */
    3db5:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%ebp)
	int digits = 0;
    3dbc:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
	int found_largest_digit = 0;
    3dc3:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	int shift = sizeof(num) * 8;
    3dca:	c7 45 d8 40 00 00 00 	movl   $0x40,-0x28(%ebp)
		shift -= 4;
    3dd1:	83 6d d8 04          	subl   $0x4,-0x28(%ebp)
		nibble = (num >> shift) & 0xf;
    3dd5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3dd8:	8a 4d d8             	mov    -0x28(%ebp),%cl
    3ddb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    3dde:	0f ad d0             	shrd   %cl,%edx,%eax
    3de1:	d3 ea                	shr    %cl,%edx
    3de3:	f6 c1 20             	test   $0x20,%cl
    3de6:	74 02                	je     3dea <z_vprintk+0x27d>
    3de8:	89 d0                	mov    %edx,%eax
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
    3dea:	24 0f                	and    $0xf,%al
    3dec:	75 10                	jne    3dfe <z_vprintk+0x291>
    3dee:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    3df2:	75 0a                	jne    3dfe <z_vprintk+0x291>
    3df4:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
			nibble += nibble > 9 ? 87 : 48;
    3df8:	b2 30                	mov    $0x30,%dl
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
    3dfa:	75 29                	jne    3e25 <z_vprintk+0x2b8>
    3dfc:	eb 09                	jmp    3e07 <z_vprintk+0x29a>
			nibble += nibble > 9 ? 87 : 48;
    3dfe:	3c 09                	cmp    $0x9,%al
    3e00:	b2 57                	mov    $0x57,%dl
    3e02:	b1 30                	mov    $0x30,%cl
    3e04:	0f 4e d1             	cmovle %ecx,%edx
    3e07:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
    3e09:	51                   	push   %ecx
    3e0a:	51                   	push   %ecx
    3e0b:	0f b6 c0             	movzbl %al,%eax
    3e0e:	ff 75 0c             	pushl  0xc(%ebp)
    3e11:	50                   	push   %eax
    3e12:	ff d7                	call   *%edi
    3e14:	83 c4 10             	add    $0x10,%esp
			digits++;
    3e17:	ff 45 c4             	incl   -0x3c(%ebp)
	while (shift >= 4) {
    3e1a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    3e1e:	74 42                	je     3e62 <z_vprintk+0x2f5>
			found_largest_digit = 1;
    3e20:	89 75 c8             	mov    %esi,-0x38(%ebp)
    3e23:	eb ac                	jmp    3dd1 <z_vprintk+0x264>
		if (remaining-- <= min_width) {
    3e25:	8b 45 cc             	mov    -0x34(%ebp),%eax
    3e28:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    3e2b:	48                   	dec    %eax
    3e2c:	39 4d e0             	cmp    %ecx,-0x20(%ebp)
    3e2f:	89 45 c8             	mov    %eax,-0x38(%ebp)
    3e32:	0f 8c fb 00 00 00    	jl     3f33 <z_vprintk+0x3c6>
			if (padding == PAD_ZERO_BEFORE) {
    3e38:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    3e3c:	75 09                	jne    3e47 <z_vprintk+0x2da>
				out('0', ctx);
    3e3e:	50                   	push   %eax
    3e3f:	50                   	push   %eax
    3e40:	ff 75 0c             	pushl  0xc(%ebp)
    3e43:	6a 30                	push   $0x30
    3e45:	eb 11                	jmp    3e58 <z_vprintk+0x2eb>
			} else if (padding == PAD_SPACE_BEFORE) {
    3e47:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    3e4b:	0f 85 e2 00 00 00    	jne    3f33 <z_vprintk+0x3c6>
				out(' ', ctx);
    3e51:	50                   	push   %eax
    3e52:	50                   	push   %eax
    3e53:	ff 75 0c             	pushl  0xc(%ebp)
    3e56:	6a 20                	push   $0x20
    3e58:	ff d7                	call   *%edi
    3e5a:	83 c4 10             	add    $0x10,%esp
    3e5d:	e9 d1 00 00 00       	jmp    3f33 <z_vprintk+0x3c6>
			might_format = 0;
    3e62:	31 f6                	xor    %esi,%esi
	if (padding == PAD_SPACE_AFTER) {
    3e64:	83 7d dc 03          	cmpl   $0x3,-0x24(%ebp)
    3e68:	0f 85 bd 00 00 00    	jne    3f2b <z_vprintk+0x3be>
		remaining = min_width * 2 - digits;
    3e6e:	8b 75 e0             	mov    -0x20(%ebp),%esi
    3e71:	01 f6                	add    %esi,%esi
    3e73:	2b 75 c4             	sub    -0x3c(%ebp),%esi
		while (remaining-- > 0) {
    3e76:	85 f6                	test   %esi,%esi
    3e78:	0f 8e ab 00 00 00    	jle    3f29 <z_vprintk+0x3bc>
			out(' ', ctx);
    3e7e:	51                   	push   %ecx
    3e7f:	51                   	push   %ecx
    3e80:	4e                   	dec    %esi
    3e81:	ff 75 0c             	pushl  0xc(%ebp)
    3e84:	6a 20                	push   $0x20
    3e86:	ff d7                	call   *%edi
    3e88:	83 c4 10             	add    $0x10,%esp
    3e8b:	eb e9                	jmp    3e76 <z_vprintk+0x309>
				while (*s) {
    3e8d:	0f be 03             	movsbl (%ebx),%eax
    3e90:	84 c0                	test   %al,%al
    3e92:	74 14                	je     3ea8 <z_vprintk+0x33b>
    3e94:	89 55 d0             	mov    %edx,-0x30(%ebp)
					out((int)(*s++), ctx);
    3e97:	52                   	push   %edx
    3e98:	43                   	inc    %ebx
    3e99:	52                   	push   %edx
    3e9a:	ff 75 0c             	pushl  0xc(%ebp)
    3e9d:	50                   	push   %eax
    3e9e:	ff d7                	call   *%edi
    3ea0:	83 c4 10             	add    $0x10,%esp
    3ea3:	8b 55 d0             	mov    -0x30(%ebp),%edx
    3ea6:	eb e5                	jmp    3e8d <z_vprintk+0x320>
				if (padding == PAD_SPACE_AFTER) {
    3ea8:	83 7d dc 03          	cmpl   $0x3,-0x24(%ebp)
    3eac:	75 79                	jne    3f27 <z_vprintk+0x3ba>
					int remaining = min_width - (s - start);
    3eae:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3eb1:	29 d3                	sub    %edx,%ebx
    3eb3:	29 d8                	sub    %ebx,%eax
    3eb5:	89 c3                	mov    %eax,%ebx
					while (remaining-- > 0) {
    3eb7:	85 db                	test   %ebx,%ebx
    3eb9:	7e 6c                	jle    3f27 <z_vprintk+0x3ba>
						out(' ', ctx);
    3ebb:	50                   	push   %eax
    3ebc:	50                   	push   %eax
    3ebd:	4b                   	dec    %ebx
    3ebe:	ff 75 0c             	pushl  0xc(%ebp)
    3ec1:	6a 20                	push   $0x20
    3ec3:	ff d7                	call   *%edi
    3ec5:	83 c4 10             	add    $0x10,%esp
    3ec8:	eb ed                	jmp    3eb7 <z_vprintk+0x34a>
				out(c, ctx);
    3eca:	83 c4 10             	add    $0x10,%esp
    3ecd:	eb 58                	jmp    3f27 <z_vprintk+0x3ba>
				out((int)'%', ctx);
    3ecf:	50                   	push   %eax
    3ed0:	50                   	push   %eax
    3ed1:	ff 75 0c             	pushl  0xc(%ebp)
    3ed4:	6a 25                	push   $0x25
    3ed6:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
    3ed8:	8b 45 10             	mov    0x10(%ebp),%eax
				out((int)'%', ctx);
    3edb:	5a                   	pop    %edx
    3edc:	59                   	pop    %ecx
				out((int)*fmt, ctx);
    3edd:	ff 75 0c             	pushl  0xc(%ebp)
    3ee0:	0f be 00             	movsbl (%eax),%eax
    3ee3:	50                   	push   %eax
    3ee4:	ff d7                	call   *%edi
    3ee6:	83 c4 10             	add    $0x10,%esp
    3ee9:	eb 3e                	jmp    3f29 <z_vprintk+0x3bc>
				length_mod = 0;
    3eeb:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
				min_width = -1;
    3eef:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
				might_format = 1;
    3ef6:	be 01 00 00 00       	mov    $0x1,%esi
				padding = PAD_NONE;
    3efb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    3f02:	eb 27                	jmp    3f2b <z_vprintk+0x3be>
				padding = PAD_SPACE_AFTER;
    3f04:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    3f0b:	eb 1e                	jmp    3f2b <z_vprintk+0x3be>
					padding = PAD_ZERO_BEFORE;
    3f0d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
    3f14:	eb 15                	jmp    3f2b <z_vprintk+0x3be>
					length_mod = 'H';
    3f16:	c6 45 e7 48          	movb   $0x48,-0x19(%ebp)
    3f1a:	eb 0f                	jmp    3f2b <z_vprintk+0x3be>
					length_mod = 'L';
    3f1c:	c6 45 e7 4c          	movb   $0x4c,-0x19(%ebp)
    3f20:	eb 09                	jmp    3f2b <z_vprintk+0x3be>
    3f22:	88 45 e7             	mov    %al,-0x19(%ebp)
    3f25:	eb 04                	jmp    3f2b <z_vprintk+0x3be>
				char *s = va_arg(ap, char *);
    3f27:	89 f3                	mov    %esi,%ebx
			might_format = 0;
    3f29:	31 f6                	xor    %esi,%esi
		++fmt;
    3f2b:	ff 45 10             	incl   0x10(%ebp)
    3f2e:	e9 5d fc ff ff       	jmp    3b90 <z_vprintk+0x23>
					x = va_arg(ap, unsigned int);
    3f33:	8b 45 c8             	mov    -0x38(%ebp),%eax
    3f36:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    3f3d:	89 45 cc             	mov    %eax,-0x34(%ebp)
    3f40:	e9 8c fe ff ff       	jmp    3dd1 <z_vprintk+0x264>
}
    3f45:	8d 65 f4             	lea    -0xc(%ebp),%esp
    3f48:	5b                   	pop    %ebx
    3f49:	5e                   	pop    %esi
    3f4a:	5f                   	pop    %edi
    3f4b:	5d                   	pop    %ebp
    3f4c:	c3                   	ret    

00003f4d <vprintk>:
{
    3f4d:	55                   	push   %ebp
    3f4e:	89 e5                	mov    %esp,%ebp
    3f50:	83 ec 18             	sub    $0x18,%esp
    3f53:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    3f59:	89 45 f4             	mov    %eax,-0xc(%ebp)
    3f5c:	31 c0                	xor    %eax,%eax
	z_vprintk(char_out, &ctx, fmt, ap);
    3f5e:	8d 45 f0             	lea    -0x10(%ebp),%eax
    3f61:	ff 75 0c             	pushl  0xc(%ebp)
    3f64:	ff 75 08             	pushl  0x8(%ebp)
	struct out_context ctx = { 0 };
    3f67:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	z_vprintk(char_out, &ctx, fmt, ap);
    3f6e:	50                   	push   %eax
    3f6f:	68 6c 3a 00 00       	push   $0x3a6c
    3f74:	e8 f4 fb ff ff       	call   3b6d <z_vprintk>
    3f79:	83 c4 10             	add    $0x10,%esp
}
    3f7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f7f:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    3f86:	74 05                	je     3f8d <vprintk+0x40>
    3f88:	e8 fc ff ff ff       	call   3f89 <vprintk+0x3c>
    3f8d:	c9                   	leave  
    3f8e:	c3                   	ret    

00003f8f <printk>:
{
    3f8f:	55                   	push   %ebp
    3f90:	89 e5                	mov    %esp,%ebp
    3f92:	83 ec 10             	sub    $0x10,%esp
	va_start(ap, fmt);
    3f95:	8d 45 0c             	lea    0xc(%ebp),%eax
		vprintk(fmt, ap);
    3f98:	50                   	push   %eax
    3f99:	ff 75 08             	pushl  0x8(%ebp)
    3f9c:	e8 ac ff ff ff       	call   3f4d <vprintk>
    3fa1:	83 c4 10             	add    $0x10,%esp
}
    3fa4:	c9                   	leave  
    3fa5:	c3                   	ret    

00003fa6 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    3fa6:	55                   	push   %ebp
    3fa7:	89 e5                	mov    %esp,%ebp
    3fa9:	83 ec 0c             	sub    $0xc,%esp
	entry(p1, p2, p3);
    3fac:	ff 75 14             	pushl  0x14(%ebp)
    3faf:	ff 75 10             	pushl  0x10(%ebp)
    3fb2:	ff 75 0c             	pushl  0xc(%ebp)
    3fb5:	ff 55 08             	call   *0x8(%ebp)
    3fb8:	83 c4 10             	add    $0x10,%esp
	if (z_syscall_trap()) {
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_K_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_current_get();
    3fbb:	e8 30 3d 00 00       	call   7cf0 <z_impl_k_current_get>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
    3fc0:	83 ec 0c             	sub    $0xc,%esp
    3fc3:	50                   	push   %eax
    3fc4:	e8 34 06 00 00       	call   45fd <z_impl_k_thread_abort>
    3fc9:	83 c4 0c             	add    $0xc,%esp
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    3fcc:	6a 26                	push   $0x26
    3fce:	68 38 8c 00 00       	push   $0x8c38
    3fd3:	68 70 8c 00 00       	push   $0x8c70
    3fd8:	e8 08 19 00 00       	call   58e5 <posix_print_error_and_exit>
    3fdd:	83 c4 10             	add    $0x10,%esp

00003fe0 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
    3fe0:	55                   	push   %ebp
    3fe1:	89 e5                	mov    %esp,%ebp
    3fe3:	56                   	push   %esi
    3fe4:	53                   	push   %ebx
	if (z_syscall_trap()) {
		return (void *) arch_syscall_invoke2(*(uintptr_t *)&queue, *(uintptr_t *)&timeout, K_SYSCALL_K_QUEUE_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_queue_get(queue, timeout);
    3fe5:	50                   	push   %eax
    3fe6:	50                   	push   %eax
    3fe7:	6a ff                	push   $0xffffffff
    3fe9:	ff 75 08             	pushl  0x8(%ebp)
    3fec:	e8 38 28 00 00       	call   6829 <z_impl_k_queue_get>
    3ff1:	83 c4 10             	add    $0x10,%esp
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
    3ff4:	85 c0                	test   %eax,%eax
    3ff6:	74 ed                	je     3fe5 <z_work_q_main+0x5>
    3ff8:	89 c2                	mov    %eax,%edx
			continue;
		}

		handler = work->handler;
    3ffa:	8b 48 04             	mov    0x4(%eax),%ecx
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    3ffd:	8b 40 08             	mov    0x8(%eax),%eax
    4000:	89 c6                	mov    %eax,%esi
    4002:	89 c3                	mov    %eax,%ebx
    4004:	83 e6 fe             	and    $0xfffffffe,%esi
    4007:	f0 0f b1 72 08       	lock cmpxchg %esi,0x8(%edx)
    400c:	75 f2                	jne    4000 <z_work_q_main+0x20>

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
    400e:	80 e3 01             	and    $0x1,%bl
    4011:	74 09                	je     401c <z_work_q_main+0x3c>
					      K_WORK_STATE_PENDING)) {
			handler(work);
    4013:	83 ec 0c             	sub    $0xc,%esp
    4016:	52                   	push   %edx
    4017:	ff d1                	call   *%ecx
    4019:	83 c4 10             	add    $0x10,%esp
	z_impl_k_yield();
    401c:	e8 f7 3a 00 00       	call   7b18 <z_impl_k_yield>
    4021:	eb c2                	jmp    3fe5 <z_work_q_main+0x5>

00004023 <assert_post_action>:
#ifdef CONFIG_ASSERT_NO_FILE_INFO
__weak void assert_post_action(void)
#else
__weak void assert_post_action(const char *file, unsigned int line)
#endif
{
    4023:	55                   	push   %ebp
    4024:	89 e5                	mov    %esp,%ebp
    4026:	83 ec 0c             	sub    $0xc,%esp
	if (_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
    4029:	6a 2d                	push   $0x2d
    402b:	68 95 8c 00 00       	push   $0x8c95
    4030:	68 fa 8b 00 00       	push   $0x8bfa
    4035:	e8 55 ff ff ff       	call   3f8f <printk>
    403a:	83 c4 10             	add    $0x10,%esp
    403d:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
    4044:	c7 45 08 04 00 00 00 	movl   $0x4,0x8(%ebp)
}
    404b:	c9                   	leave  
	k_panic();
    404c:	e9 d5 23 00 00       	jmp    6426 <z_fatal_error>

00004051 <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
    4051:	55                   	push   %ebp
    4052:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_KERNEL_BIN_NAME, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    4054:	5d                   	pop    %ebp
    4055:	c3                   	ret    

00004056 <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(struct device *arg)
{
    4056:	55                   	push   %ebp
    4057:	89 e5                	mov    %esp,%ebp
    4059:	83 ec 08             	sub    $0x8,%esp
	setvbuf(stdout, NULL, _IOLBF, 512);
    405c:	68 00 02 00 00       	push   $0x200
    4061:	6a 01                	push   $0x1
    4063:	6a 00                	push   $0x0
    4065:	ff 35 00 00 00 00    	pushl  0x0
    406b:	e8 fc ff ff ff       	call   406c <native_posix_console_init+0x16>
    4070:	83 c4 10             	add    $0x10,%esp
	setvbuf(stderr, NULL, _IOLBF, 512);
    4073:	68 00 02 00 00       	push   $0x200
    4078:	6a 01                	push   $0x1
    407a:	6a 00                	push   $0x0
    407c:	ff 35 00 00 00 00    	pushl  0x0
    4082:	e8 fc ff ff ff       	call   4083 <native_posix_console_init+0x2d>
	__printk_hook_install(putchar);
    4087:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    408e:	e8 cd fa ff ff       	call   3b60 <__printk_hook_install>
    4093:	83 c4 10             	add    $0x10,%esp
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
    4096:	31 c0                	xor    %eax,%eax
    4098:	c9                   	leave  
    4099:	c3                   	ret    

0000409a <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(void *arg)
{
    409a:	55                   	push   %ebp
    409b:	89 e5                	mov    %esp,%ebp
    409d:	57                   	push   %edi
    409e:	56                   	push   %esi
    409f:	83 ec 10             	sub    $0x10,%esp
	ARG_UNUSED(arg);

	u64_t now = hwm_get_time();
    40a2:	e8 35 0c 00 00       	call   4cdc <hwm_get_time>
	s32_t elapsed_ticks = (now - last_tick_time)/tick_period;
    40a7:	8b 35 80 d9 00 00    	mov    0xd980,%esi
    40ad:	8b 3d 84 d9 00 00    	mov    0xd984,%edi
    40b3:	89 75 e8             	mov    %esi,-0x18(%ebp)
    40b6:	2b 45 e8             	sub    -0x18(%ebp),%eax
    40b9:	89 7d ec             	mov    %edi,-0x14(%ebp)
    40bc:	1b 55 ec             	sbb    -0x14(%ebp),%edx
    40bf:	8b 35 88 d9 00 00    	mov    0xd988,%esi
    40c5:	8b 3d 8c d9 00 00    	mov    0xd98c,%edi
    40cb:	57                   	push   %edi
    40cc:	56                   	push   %esi
    40cd:	52                   	push   %edx
    40ce:	50                   	push   %eax
    40cf:	89 75 f0             	mov    %esi,-0x10(%ebp)
    40d2:	89 7d f4             	mov    %edi,-0xc(%ebp)
    40d5:	e8 46 f4 ff ff       	call   3520 <__udivdi3>

	last_tick_time += elapsed_ticks*tick_period;
    40da:	8b 7d f4             	mov    -0xc(%ebp),%edi
	s32_t elapsed_ticks = (now - last_tick_time)/tick_period;
    40dd:	89 c1                	mov    %eax,%ecx
	last_tick_time += elapsed_ticks*tick_period;
    40df:	99                   	cltd   
    40e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
	s32_t elapsed_ticks = (now - last_tick_time)/tick_period;
    40e3:	83 c4 10             	add    $0x10,%esp
	z_clock_announce(elapsed_ticks);
    40e6:	89 4d 08             	mov    %ecx,0x8(%ebp)
	last_tick_time += elapsed_ticks*tick_period;
    40e9:	0f af f9             	imul   %ecx,%edi
    40ec:	0f af c2             	imul   %edx,%eax
    40ef:	01 c7                	add    %eax,%edi
    40f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    40f4:	f7 e1                	mul    %ecx
    40f6:	01 fa                	add    %edi,%edx
    40f8:	03 45 e8             	add    -0x18(%ebp),%eax
    40fb:	13 55 ec             	adc    -0x14(%ebp),%edx
    40fe:	a3 80 d9 00 00       	mov    %eax,0xd980
    4103:	89 15 84 d9 00 00    	mov    %edx,0xd984
}
    4109:	8d 65 f8             	lea    -0x8(%ebp),%esp
    410c:	5e                   	pop    %esi
    410d:	5f                   	pop    %edi
    410e:	5d                   	pop    %ebp
	z_clock_announce(elapsed_ticks);
    410f:	e9 01 47 00 00       	jmp    8815 <z_clock_announce>

00004114 <z_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
int z_clock_driver_init(struct device *device)
{
    4114:	55                   	push   %ebp
    4115:	89 e5                	mov    %esp,%ebp
    4117:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(device);

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
    411a:	c7 05 88 d9 00 00 10 	movl   $0x2710,0xd988
    4121:	27 00 00 
    4124:	c7 05 8c d9 00 00 00 	movl   $0x0,0xd98c
    412b:	00 00 00 

	last_tick_time = hwm_get_time();
    412e:	e8 a9 0b 00 00       	call   4cdc <hwm_get_time>
    4133:	89 15 84 d9 00 00    	mov    %edx,0xd984
	hwtimer_enable(tick_period);
    4139:	52                   	push   %edx
    413a:	52                   	push   %edx
    413b:	ff 35 8c d9 00 00    	pushl  0xd98c
    4141:	ff 35 88 d9 00 00    	pushl  0xd988
	last_tick_time = hwm_get_time();
    4147:	a3 80 d9 00 00       	mov    %eax,0xd980
	hwtimer_enable(tick_period);
    414c:	e8 8a 0f 00 00       	call   50db <hwtimer_enable>
    4151:	83 c4 10             	add    $0x10,%esp

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
    4154:	6a 00                	push   $0x0
    4156:	68 9a 40 00 00       	push   $0x409a
    415b:	6a 00                	push   $0x0
    415d:	6a 00                	push   $0x0
    415f:	e8 3c 13 00 00       	call   54a0 <posix_isr_declare>
    4164:	83 c4 0c             	add    $0xc,%esp
    4167:	6a 00                	push   $0x0
    4169:	6a 01                	push   $0x1
    416b:	6a 00                	push   $0x0
    416d:	e8 59 13 00 00       	call   54cb <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
    4172:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    4179:	e8 9f 00 00 00       	call   421d <arch_irq_enable>
    417e:	83 c4 10             	add    $0x10,%esp

	return 0;
}
    4181:	31 c0                	xor    %eax,%eax
    4183:	c9                   	leave  
    4184:	c3                   	ret    

00004185 <z_clock_set_timeout>:
 * @param ticks Timeout in tick units
 * @param idle Hint to the driver that the system is about to enter
 *        the idle state immediately after setting the timeout
 */
void z_clock_set_timeout(s32_t ticks, bool idle)
{
    4185:	55                   	push   %ebp

	/* Note that we treat INT_MAX literally as anyhow the maximum amount of
	 * ticks we can report with z_clock_announce() is INT_MAX
	 */
	if (ticks == K_FOREVER) {
		silent_ticks = INT64_MAX;
    4186:	83 c9 ff             	or     $0xffffffff,%ecx
{
    4189:	89 e5                	mov    %esp,%ebp
    418b:	53                   	push   %ebx
		silent_ticks = INT64_MAX;
    418c:	bb ff ff ff 7f       	mov    $0x7fffffff,%ebx
{
    4191:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ticks == K_FOREVER) {
    4194:	83 f8 ff             	cmp    $0xffffffff,%eax
    4197:	74 10                	je     41a9 <z_clock_set_timeout+0x24>
	} else if (ticks > 0) {
		silent_ticks = ticks - 1;
	} else {
		silent_ticks = 0;
    4199:	31 c9                	xor    %ecx,%ecx
    419b:	31 db                	xor    %ebx,%ebx
	} else if (ticks > 0) {
    419d:	85 c0                	test   %eax,%eax
    419f:	7e 08                	jle    41a9 <z_clock_set_timeout+0x24>
		silent_ticks = ticks - 1;
    41a1:	48                   	dec    %eax
    41a2:	89 c3                	mov    %eax,%ebx
    41a4:	89 c1                	mov    %eax,%ecx
    41a6:	c1 fb 1f             	sar    $0x1f,%ebx
	}
	hwtimer_set_silent_ticks(silent_ticks);
    41a9:	89 5d 0c             	mov    %ebx,0xc(%ebp)
    41ac:	89 4d 08             	mov    %ecx,0x8(%ebp)
#endif
}
    41af:	5b                   	pop    %ebx
    41b0:	5d                   	pop    %ebp
	hwtimer_set_silent_ticks(silent_ticks);
    41b1:	e9 5e 11 00 00       	jmp    5314 <hwtimer_set_silent_ticks>

000041b6 <z_clock_elapsed>:
 * last call to z_clock_announce() was made.  The kernel will call
 * this with appropriate locking, the driver needs only provide an
 * instantaneous answer.
 */
u32_t z_clock_elapsed(void)
{
    41b6:	55                   	push   %ebp
    41b7:	89 e5                	mov    %esp,%ebp
    41b9:	83 ec 08             	sub    $0x8,%esp
	return (hwm_get_time() - last_tick_time)/tick_period;
    41bc:	e8 1b 0b 00 00       	call   4cdc <hwm_get_time>
    41c1:	2b 05 80 d9 00 00    	sub    0xd980,%eax
    41c7:	ff 35 8c d9 00 00    	pushl  0xd98c
    41cd:	1b 15 84 d9 00 00    	sbb    0xd984,%edx
    41d3:	ff 35 88 d9 00 00    	pushl  0xd988
    41d9:	52                   	push   %edx
    41da:	50                   	push   %eax
    41db:	e8 40 f3 ff ff       	call   3520 <__udivdi3>
    41e0:	83 c4 10             	add    $0x10,%esp
}
    41e3:	c9                   	leave  
    41e4:	c3                   	ret    

000041e5 <arch_cpu_idle>:
#include "posix_core.h"
#include <arch/posix/posix_soc_if.h>
#include <tracing/tracing.h>

void arch_cpu_idle(void)
{
    41e5:	55                   	push   %ebp
    41e6:	89 e5                	mov    %esp,%ebp
    41e8:	83 ec 08             	sub    $0x8,%esp
	sys_trace_idle();
	posix_irq_full_unlock();
    41eb:	e8 95 12 00 00       	call   5485 <posix_irq_full_unlock>
	posix_halt_cpu();
}
    41f0:	c9                   	leave  
	posix_halt_cpu();
    41f1:	e9 4f 07 00 00       	jmp    4945 <posix_halt_cpu>

000041f6 <arch_system_halt>:
#include <inttypes.h>
#include <logging/log_ctrl.h>
#include <arch/posix/posix_soc_if.h>

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
    41f6:	55                   	push   %ebp
    41f7:	89 e5                	mov    %esp,%ebp
    41f9:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
    41fc:	68 d1 8c 00 00       	push   $0x8cd1
    4201:	e8 df 16 00 00       	call   58e5 <posix_print_error_and_exit>
    4206:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    4209:	6a 15                	push   $0x15
    420b:	68 ed 8c 00 00       	push   $0x8ced
    4210:	68 70 8c 00 00       	push   $0x8c70
    4215:	e8 cb 16 00 00       	call   58e5 <posix_print_error_and_exit>
    421a:	83 c4 10             	add    $0x10,%esp

0000421d <arch_irq_enable>:
	posix_irq_offload(routine, parameter);
}
#endif

void arch_irq_enable(unsigned int irq)
{
    421d:	55                   	push   %ebp
    421e:	89 e5                	mov    %esp,%ebp
	posix_irq_enable(irq);
}
    4220:	5d                   	pop    %ebp
	posix_irq_enable(irq);
    4221:	e9 71 12 00 00       	jmp    5497 <posix_irq_enable>

00004226 <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
    4226:	85 c0                	test   %eax,%eax
    4228:	74 16                	je     4240 <pc_safe_call+0x1a>
{
    422a:	55                   	push   %ebp
    422b:	89 e5                	mov    %esp,%ebp
    422d:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    4230:	52                   	push   %edx
    4231:	68 27 8d 00 00       	push   $0x8d27
    4236:	e8 aa 16 00 00       	call   58e5 <posix_print_error_and_exit>
    423b:	83 c4 10             	add    $0x10,%esp
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
    423e:	c9                   	leave  
    423f:	c3                   	ret    
    4240:	c3                   	ret    

00004241 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
    4241:	55                   	push   %ebp
    4242:	89 e5                	mov    %esp,%ebp
    4244:	83 ec 14             	sub    $0x14,%esp
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    4247:	68 04 da 00 00       	push   $0xda04
    424c:	e8 fc ff ff ff       	call   424d <posix_preexit_cleanup+0xc>
    4251:	83 c4 10             	add    $0x10,%esp
    4254:	ba 41 8d 00 00       	mov    $0x8d41,%edx
    4259:	e8 c8 ff ff ff       	call   4226 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    425e:	e8 fc ff ff ff       	call   425f <posix_preexit_cleanup+0x1e>
    4263:	83 ec 0c             	sub    $0xc,%esp
    4266:	50                   	push   %eax
    4267:	e8 fc ff ff ff       	call   4268 <posix_preexit_cleanup+0x27>
    426c:	83 c4 10             	add    $0x10,%esp
}
    426f:	c9                   	leave  
    4270:	c3                   	ret    

00004271 <abort_tail>:
{
    4271:	55                   	push   %ebp
	threads_table[this_th_nbr].running = false;
    4272:	6b c0 14             	imul   $0x14,%eax,%eax
{
    4275:	89 e5                	mov    %esp,%ebp
    4277:	83 ec 08             	sub    $0x8,%esp
	threads_table[this_th_nbr].running = false;
    427a:	03 05 20 da 00 00    	add    0xda20,%eax
    4280:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	threads_table[this_th_nbr].state = ABORTED;
    4284:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	posix_preexit_cleanup();
    428a:	e8 b2 ff ff ff       	call   4241 <posix_preexit_cleanup>
	pthread_exit(NULL);
    428f:	83 ec 0c             	sub    $0xc,%esp
    4292:	6a 00                	push   $0x0
    4294:	e8 fc ff ff ff       	call   4295 <abort_tail+0x24>

00004299 <posix_wait_until_allowed>:
{
    4299:	55                   	push   %ebp
    429a:	89 e5                	mov    %esp,%ebp
    429c:	56                   	push   %esi
    429d:	89 c6                	mov    %eax,%esi
    429f:	53                   	push   %ebx
	threads_table[this_th_nbr].running = false;
    42a0:	6b d8 14             	imul   $0x14,%eax,%ebx
    42a3:	a1 20 da 00 00       	mov    0xda20,%eax
    42a8:	c6 44 18 04 00       	movb   $0x0,0x4(%eax,%ebx,1)
	while (this_th_nbr != currently_allowed_thread) {
    42ad:	39 35 00 da 00 00    	cmp    %esi,0xda00
    42b3:	74 2a                	je     42df <posix_wait_until_allowed+0x46>
		pthread_cond_wait(&cond_threads, &mtx_threads);
    42b5:	50                   	push   %eax
    42b6:	50                   	push   %eax
    42b7:	68 04 da 00 00       	push   $0xda04
    42bc:	68 80 d4 00 00       	push   $0xd480
    42c1:	e8 fc ff ff ff       	call   42c2 <posix_wait_until_allowed+0x29>
		if (threads_table &&
    42c6:	a1 20 da 00 00       	mov    0xda20,%eax
		pthread_cond_wait(&cond_threads, &mtx_threads);
    42cb:	83 c4 10             	add    $0x10,%esp
		if (threads_table &&
    42ce:	85 c0                	test   %eax,%eax
    42d0:	74 db                	je     42ad <posix_wait_until_allowed+0x14>
    42d2:	83 3c 18 02          	cmpl   $0x2,(%eax,%ebx,1)
    42d6:	75 d5                	jne    42ad <posix_wait_until_allowed+0x14>
			abort_tail(this_th_nbr);
    42d8:	89 f0                	mov    %esi,%eax
    42da:	e8 92 ff ff ff       	call   4271 <abort_tail>
	threads_table[this_th_nbr].running = true;
    42df:	a1 20 da 00 00       	mov    0xda20,%eax
    42e4:	c6 44 18 04 01       	movb   $0x1,0x4(%eax,%ebx,1)
}
    42e9:	8d 65 f8             	lea    -0x8(%ebp),%esp
    42ec:	5b                   	pop    %ebx
    42ed:	5e                   	pop    %esi
    42ee:	5d                   	pop    %ebp
    42ef:	c3                   	ret    

000042f0 <posix_cleanup_handler>:
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
    42f0:	80 3d 9d da 00 00 00 	cmpb   $0x0,0xda9d
    42f7:	74 2b                	je     4324 <posix_cleanup_handler+0x34>
{
    42f9:	55                   	push   %ebp
    42fa:	89 e5                	mov    %esp,%ebp
    42fc:	83 ec 14             	sub    $0x14,%esp
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
    42ff:	68 04 da 00 00       	push   $0xda04
    4304:	e8 fc ff ff ff       	call   4305 <posix_cleanup_handler+0x15>
    4309:	83 c4 10             	add    $0x10,%esp
    430c:	ba 41 8d 00 00       	mov    $0x8d41,%edx
    4311:	e8 10 ff ff ff       	call   4226 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
    4316:	e8 fc ff ff ff       	call   4317 <posix_cleanup_handler+0x27>
    431b:	89 45 08             	mov    %eax,0x8(%ebp)
}
    431e:	c9                   	leave  
	pthread_detach(pthread_self());
    431f:	e9 fc ff ff ff       	jmp    4320 <posix_cleanup_handler+0x30>
    4324:	c3                   	ret    

00004325 <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
    4325:	55                   	push   %ebp
    4326:	89 e5                	mov    %esp,%ebp
    4328:	83 ec 54             	sub    $0x54,%esp
    432b:	8b 45 08             	mov    0x8(%ebp),%eax

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    432e:	68 04 da 00 00       	push   $0xda04
{
    4333:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    4336:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    433c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    433f:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    4341:	e8 fc ff ff ff       	call   4342 <posix_thread_starter+0x1d>
    4346:	83 c4 10             	add    $0x10,%esp
    4349:	ba 64 8d 00 00       	mov    $0x8d64,%edx
    434e:	e8 d3 fe ff ff       	call   4226 <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
    4353:	83 3d 20 da 00 00 00 	cmpl   $0x0,0xda20
    435a:	75 17                	jne    4373 <posix_thread_starter+0x4e>
		posix_cleanup_handler(arg);
    435c:	83 ec 0c             	sub    $0xc,%esp
    435f:	ff 75 c4             	pushl  -0x3c(%ebp)
    4362:	e8 89 ff ff ff       	call   42f0 <posix_cleanup_handler>
		pthread_exit(NULL);
    4367:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    436e:	e8 fc ff ff ff       	call   436f <posix_thread_starter+0x4a>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
    4373:	50                   	push   %eax
    4374:	50                   	push   %eax
    4375:	8d 45 c8             	lea    -0x38(%ebp),%eax
    4378:	6a 00                	push   $0x0
    437a:	50                   	push   %eax
    437b:	e8 fc ff ff ff       	call   437c <posix_thread_starter+0x57>
    4380:	83 c4 10             	add    $0x10,%esp
    4383:	85 c0                	test   %eax,%eax
    4385:	74 16                	je     439d <posix_thread_starter+0x78>
    4387:	83 ec 0c             	sub    $0xc,%esp
    438a:	ff 75 c4             	pushl  -0x3c(%ebp)
    438d:	e8 5e ff ff ff       	call   42f0 <posix_cleanup_handler>
    4392:	8d 45 c8             	lea    -0x38(%ebp),%eax
    4395:	83 c4 10             	add    $0x10,%esp
    4398:	e8 fc ff ff ff       	call   4399 <posix_thread_starter+0x74>
    439d:	8d 45 c8             	lea    -0x38(%ebp),%eax
    43a0:	e8 fc ff ff ff       	call   43a1 <posix_thread_starter+0x7c>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
    43a5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    43a8:	e8 ec fe ff ff       	call   4299 <posix_wait_until_allowed>

	posix_new_thread_pre_start();
    43ad:	e8 76 04 00 00       	call   4828 <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
    43b2:	6b 45 c4 14          	imul   $0x14,-0x3c(%ebp),%eax
    43b6:	03 05 20 da 00 00    	add    0xda20,%eax
    43bc:	8b 40 10             	mov    0x10(%eax),%eax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
    43bf:	ff 70 0c             	pushl  0xc(%eax)
    43c2:	ff 70 08             	pushl  0x8(%eax)
    43c5:	ff 70 04             	pushl  0x4(%eax)
    43c8:	ff 30                	pushl  (%eax)
    43ca:	e8 d7 fb ff ff       	call   3fa6 <z_thread_entry>

000043cf <posix_swap>:
{
    43cf:	55                   	push   %ebp
    43d0:	89 e5                	mov    %esp,%ebp
    43d2:	53                   	push   %ebx
    43d3:	83 ec 10             	sub    $0x10,%esp
	currently_allowed_thread = next_allowed_th;
    43d6:	8b 45 08             	mov    0x8(%ebp),%eax
{
    43d9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    43dc:	68 80 d4 00 00       	push   $0xd480
	currently_allowed_thread = next_allowed_th;
    43e1:	a3 00 da 00 00       	mov    %eax,0xda00
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    43e6:	e8 fc ff ff ff       	call   43e7 <posix_swap+0x18>
    43eb:	83 c4 10             	add    $0x10,%esp
    43ee:	ba 85 8d 00 00       	mov    $0x8d85,%edx
    43f3:	e8 2e fe ff ff       	call   4226 <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
    43f8:	6b c3 14             	imul   $0x14,%ebx,%eax
    43fb:	03 05 20 da 00 00    	add    0xda20,%eax
    4401:	83 38 02             	cmpl   $0x2,(%eax)
		abort_tail(this_th_nbr);
    4404:	89 d8                	mov    %ebx,%eax
	if (threads_table[this_th_nbr].state == ABORTING) {
    4406:	75 05                	jne    440d <posix_swap+0x3e>
		abort_tail(this_th_nbr);
    4408:	e8 64 fe ff ff       	call   4271 <abort_tail>
}
    440d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4410:	c9                   	leave  
		posix_wait_until_allowed(this_th_nbr);
    4411:	e9 83 fe ff ff       	jmp    4299 <posix_wait_until_allowed>

00004416 <posix_main_thread_start>:
{
    4416:	55                   	push   %ebp
    4417:	89 e5                	mov    %esp,%ebp
    4419:	83 ec 14             	sub    $0x14,%esp
	currently_allowed_thread = next_allowed_th;
    441c:	8b 45 08             	mov    0x8(%ebp),%eax
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    441f:	68 80 d4 00 00       	push   $0xd480
	currently_allowed_thread = next_allowed_th;
    4424:	a3 00 da 00 00       	mov    %eax,0xda00
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
    4429:	e8 fc ff ff ff       	call   442a <posix_main_thread_start+0x14>
    442e:	83 c4 10             	add    $0x10,%esp
    4431:	ba 85 8d 00 00       	mov    $0x8d85,%edx
    4436:	e8 eb fd ff ff       	call   4226 <pc_safe_call>
	posix_preexit_cleanup();
    443b:	e8 01 fe ff ff       	call   4241 <posix_preexit_cleanup>
	pthread_exit(NULL);
    4440:	83 ec 0c             	sub    $0xc,%esp
    4443:	6a 00                	push   $0x0
    4445:	e8 fc ff ff ff       	call   4446 <posix_main_thread_start+0x30>

0000444a <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
    444a:	55                   	push   %ebp
	for (int i = 0; i < threads_table_size; i++) {
    444b:	31 d2                	xor    %edx,%edx
{
    444d:	89 e5                	mov    %esp,%ebp
    444f:	57                   	push   %edi
    4450:	56                   	push   %esi
    4451:	53                   	push   %ebx
    4452:	83 ec 0c             	sub    $0xc,%esp
    4455:	8b 75 08             	mov    0x8(%ebp),%esi
	for (int i = 0; i < threads_table_size; i++) {
    4458:	a1 24 da 00 00       	mov    0xda24,%eax
		if ((threads_table[i].state == NOTUSED)
    445d:	8b 0d 20 da 00 00    	mov    0xda20,%ecx
	for (int i = 0; i < threads_table_size; i++) {
    4463:	39 c2                	cmp    %eax,%edx
    4465:	7d 0c                	jge    4473 <posix_new_thread+0x29>
		if ((threads_table[i].state == NOTUSED)
    4467:	6b da 14             	imul   $0x14,%edx,%ebx
    446a:	83 3c 19 00          	cmpl   $0x0,(%ecx,%ebx,1)
    446e:	74 50                	je     44c0 <posix_new_thread+0x76>
	for (int i = 0; i < threads_table_size; i++) {
    4470:	42                   	inc    %edx
    4471:	eb f0                	jmp    4463 <posix_new_thread+0x19>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
    4473:	83 c0 40             	add    $0x40,%eax
	threads_table = realloc(threads_table,
    4476:	52                   	push   %edx
    4477:	52                   	push   %edx
    4478:	6b c0 14             	imul   $0x14,%eax,%eax
    447b:	50                   	push   %eax
    447c:	51                   	push   %ecx
    447d:	e8 fc ff ff ff       	call   447e <posix_new_thread+0x34>
    4482:	83 c4 10             	add    $0x10,%esp
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    4485:	85 c0                	test   %eax,%eax
	threads_table = realloc(threads_table,
    4487:	a3 20 da 00 00       	mov    %eax,0xda20
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    448c:	75 10                	jne    449e <posix_new_thread+0x54>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    448e:	83 ec 0c             	sub    $0xc,%esp
    4491:	68 ab 8d 00 00       	push   $0x8dab
    4496:	e8 4a 14 00 00       	call   58e5 <posix_print_error_and_exit>
    449b:	83 c4 10             	add    $0x10,%esp
	(void)memset(&threads_table[threads_table_size], 0,
    449e:	8b 15 24 da 00 00    	mov    0xda24,%edx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
    44a4:	31 c0                	xor    %eax,%eax
    44a6:	b9 40 01 00 00       	mov    $0x140,%ecx
    44ab:	6b da 14             	imul   $0x14,%edx,%ebx
    44ae:	03 1d 20 da 00 00    	add    0xda20,%ebx
    44b4:	89 df                	mov    %ebx,%edi
    44b6:	f3 ab                	rep stos %eax,%es:(%edi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
    44b8:	8d 42 40             	lea    0x40(%edx),%eax
    44bb:	a3 24 da 00 00       	mov    %eax,0xda24
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
    44c0:	8b 0d 1c da 00 00    	mov    0xda1c,%ecx
    44c6:	8d 59 01             	lea    0x1(%ecx),%ebx
	threads_table[t_slot].state = USED;
    44c9:	6b c2 14             	imul   $0x14,%edx,%eax
    44cc:	03 05 20 da 00 00    	add    0xda20,%eax
	threads_table[t_slot].thead_cnt = thread_create_count++;
    44d2:	89 1d 1c da 00 00    	mov    %ebx,0xda1c
	threads_table[t_slot].t_status = ptr;
    44d8:	89 70 10             	mov    %esi,0x10(%eax)
	threads_table[t_slot].state = USED;
    44db:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    44e1:	83 c0 08             	add    $0x8,%eax
	threads_table[t_slot].running = false;
    44e4:	c6 40 fc 00          	movb   $0x0,-0x4(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
    44e8:	89 48 04             	mov    %ecx,0x4(%eax)
	ptr->thread_idx = t_slot;
    44eb:	89 56 10             	mov    %edx,0x10(%esi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    44ee:	52                   	push   %edx
    44ef:	68 25 43 00 00       	push   $0x4325
    44f4:	6a 00                	push   $0x0
    44f6:	50                   	push   %eax
    44f7:	e8 fc ff ff ff       	call   44f8 <posix_new_thread+0xae>
    44fc:	83 c4 10             	add    $0x10,%esp
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
    44ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    4502:	ba d3 8d 00 00       	mov    $0x8dd3,%edx
}
    4507:	5b                   	pop    %ebx
    4508:	5e                   	pop    %esi
    4509:	5f                   	pop    %edi
    450a:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
    450b:	e9 16 fd ff ff       	jmp    4226 <pc_safe_call>

00004510 <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
    4510:	55                   	push   %ebp
    4511:	89 e5                	mov    %esp,%ebp
    4513:	83 ec 10             	sub    $0x10,%esp
	thread_create_count = 0;
    4516:	c7 05 1c da 00 00 00 	movl   $0x0,0xda1c
    451d:	00 00 00 

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    4520:	6a 14                	push   $0x14
    4522:	6a 40                	push   $0x40
	currently_allowed_thread = -1;
    4524:	c7 05 00 da 00 00 ff 	movl   $0xffffffff,0xda00
    452b:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    452e:	e8 fc ff ff ff       	call   452f <posix_init_multithreading+0x1f>
    4533:	83 c4 10             	add    $0x10,%esp
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    4536:	85 c0                	test   %eax,%eax
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
    4538:	a3 20 da 00 00       	mov    %eax,0xda20
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
    453d:	75 10                	jne    454f <posix_init_multithreading+0x3f>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
    453f:	83 ec 0c             	sub    $0xc,%esp
    4542:	68 ab 8d 00 00       	push   $0x8dab
    4547:	e8 99 13 00 00       	call   58e5 <posix_print_error_and_exit>
    454c:	83 c4 10             	add    $0x10,%esp
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    454f:	83 ec 0c             	sub    $0xc,%esp
	threads_table_size = PC_ALLOC_CHUNK_SIZE;
    4552:	c7 05 24 da 00 00 40 	movl   $0x40,0xda24
    4559:	00 00 00 
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    455c:	68 04 da 00 00       	push   $0xda04
    4561:	e8 fc ff ff ff       	call   4562 <posix_init_multithreading+0x52>
    4566:	83 c4 10             	add    $0x10,%esp
}
    4569:	c9                   	leave  
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
    456a:	ba 64 8d 00 00       	mov    $0x8d64,%edx
    456f:	e9 b2 fc ff ff       	jmp    4226 <pc_safe_call>

00004574 <posix_core_clean_up>:
 *
 */
void posix_core_clean_up(void)
{

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
    4574:	83 3d 20 da 00 00 00 	cmpl   $0x0,0xda20
    457b:	74 65                	je     45e2 <posix_core_clean_up+0x6e>
{
    457d:	55                   	push   %ebp
    457e:	89 e5                	mov    %esp,%ebp
    4580:	53                   	push   %ebx
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;

	for (int i = 0; i < threads_table_size; i++) {
    4581:	31 db                	xor    %ebx,%ebx
{
    4583:	52                   	push   %edx
	terminate = true;
    4584:	c6 05 9d da 00 00 01 	movb   $0x1,0xda9d
	for (int i = 0; i < threads_table_size; i++) {
    458b:	39 1d 24 da 00 00    	cmp    %ebx,0xda24
    4591:	a1 20 da 00 00       	mov    0xda20,%eax
    4596:	7e 2f                	jle    45c7 <posix_core_clean_up+0x53>
		if (threads_table[i].state != USED) {
    4598:	6b d3 14             	imul   $0x14,%ebx,%edx
    459b:	01 d0                	add    %edx,%eax
    459d:	83 38 01             	cmpl   $0x1,(%eax)
    45a0:	75 22                	jne    45c4 <posix_core_clean_up+0x50>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
    45a2:	83 ec 0c             	sub    $0xc,%esp
    45a5:	ff 70 08             	pushl  0x8(%eax)
    45a8:	e8 fc ff ff ff       	call   45a9 <posix_core_clean_up+0x35>
    45ad:	83 c4 10             	add    $0x10,%esp
    45b0:	85 c0                	test   %eax,%eax
    45b2:	74 10                	je     45c4 <posix_core_clean_up+0x50>
			posix_print_warning(
    45b4:	50                   	push   %eax
    45b5:	50                   	push   %eax
    45b6:	53                   	push   %ebx
    45b7:	68 37 8e 00 00       	push   $0x8e37
    45bc:	e8 4f 13 00 00       	call   5910 <posix_print_warning>
    45c1:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < threads_table_size; i++) {
    45c4:	43                   	inc    %ebx
    45c5:	eb c4                	jmp    458b <posix_core_clean_up+0x17>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
    45c7:	83 ec 0c             	sub    $0xc,%esp
    45ca:	50                   	push   %eax
    45cb:	e8 fc ff ff ff       	call   45cc <posix_core_clean_up+0x58>
    45d0:	83 c4 10             	add    $0x10,%esp
	threads_table = NULL;
    45d3:	c7 05 20 da 00 00 00 	movl   $0x0,0xda20
    45da:	00 00 00 
}
    45dd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    45e0:	c9                   	leave  
    45e1:	c3                   	ret    
    45e2:	c3                   	ret    

000045e3 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
    45e3:	55                   	push   %ebp
    45e4:	89 e5                	mov    %esp,%ebp
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
    45e6:	6b 45 08 14          	imul   $0x14,0x8(%ebp),%eax
    45ea:	03 05 20 da 00 00    	add    0xda20,%eax
    45f0:	83 38 01             	cmpl   $0x1,(%eax)
    45f3:	75 06                	jne    45fb <posix_abort_thread+0x18>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
    45f5:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
    45fb:	5d                   	pop    %ebp
    45fc:	c3                   	ret    

000045fd <z_impl_k_thread_abort>:
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    45fd:	55                   	push   %ebp
    45fe:	89 e5                	mov    %esp,%ebp
    4600:	57                   	push   %edi
    4601:	56                   	push   %esi
    4602:	53                   	push   %ebx
    4603:	83 ec 1c             	sub    $0x1c,%esp
    4606:	8b 75 08             	mov    0x8(%ebp),%esi
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
    4609:	8b 7e 30             	mov    0x30(%esi),%edi
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
    460c:	8b 5f 10             	mov    0x10(%edi),%ebx
	return posix_irq_lock();
    460f:	e8 56 0e 00 00       	call   546a <posix_irq_lock>

	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
    4614:	f6 46 0c 01          	testb  $0x1,0xc(%esi)
    4618:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    461b:	74 39                	je     4656 <z_impl_k_thread_abort+0x59>
    461d:	68 f1 01 00 00       	push   $0x1f1
    4622:	68 6b 8e 00 00       	push   $0x8e6b
    4627:	68 aa 8e 00 00       	push   $0x8eaa
    462c:	68 e6 8b 00 00       	push   $0x8be6
    4631:	e8 59 f9 ff ff       	call   3f8f <printk>
    4636:	c7 04 24 d8 8e 00 00 	movl   $0x8ed8,(%esp)
    463d:	e8 4d f9 ff ff       	call   3f8f <printk>
    4642:	5a                   	pop    %edx
    4643:	59                   	pop    %ecx
    4644:	68 f1 01 00 00       	push   $0x1f1
    4649:	68 6b 8e 00 00       	push   $0x8e6b
    464e:	e8 d0 f9 ff ff       	call   4023 <assert_post_action>
    4653:	83 c4 10             	add    $0x10,%esp
		 "essential thread aborted");

	z_thread_single_abort(thread);
    4656:	83 ec 0c             	sub    $0xc,%esp
    4659:	56                   	push   %esi
    465a:	e8 3b 2f 00 00       	call   759a <z_thread_single_abort>
    465f:	83 c4 10             	add    $0x10,%esp
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    4662:	39 35 c8 d8 00 00    	cmp    %esi,0xd8c8
    4668:	75 53                	jne    46bd <z_impl_k_thread_abort+0xc0>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
    466a:	83 7f 14 00          	cmpl   $0x0,0x14(%edi)
    466e:	75 09                	jne    4679 <z_impl_k_thread_abort+0x7c>
			tstatus->aborted = 1;
    4670:	c7 47 14 01 00 00 00 	movl   $0x1,0x14(%edi)
    4677:	eb 10                	jmp    4689 <z_impl_k_thread_abort+0x8c>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
    4679:	50                   	push   %eax
    467a:	50                   	push   %eax
    467b:	53                   	push   %ebx
    467c:	68 f3 8e 00 00       	push   $0x8ef3
    4681:	e8 8a 12 00 00       	call   5910 <posix_print_warning>
    4686:	83 c4 10             	add    $0x10,%esp
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
    4689:	6b db 14             	imul   $0x14,%ebx,%ebx
    468c:	03 1d 20 da 00 00    	add    0xda20,%ebx
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
    4692:	83 ec 0c             	sub    $0xc,%esp
    4695:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
    469b:	ff 75 e4             	pushl  -0x1c(%ebp)
    469e:	e8 45 00 00 00       	call   46e8 <arch_swap>
    46a3:	83 c4 0c             	add    $0xc,%esp
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);

		(void)z_swap_irqlock(key);
		CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    46a6:	68 08 02 00 00       	push   $0x208
    46ab:	68 6b 8e 00 00       	push   $0x8e6b
    46b0:	68 70 8c 00 00       	push   $0x8c70
    46b5:	e8 2b 12 00 00       	call   58e5 <posix_print_error_and_exit>
    46ba:	83 c4 10             	add    $0x10,%esp
	}

	if (tstatus->aborted == 0) {
    46bd:	83 7f 14 00          	cmpl   $0x0,0x14(%edi)
    46c1:	75 13                	jne    46d6 <z_impl_k_thread_abort+0xd9>
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
		posix_abort_thread(thread_idx);
    46c3:	83 ec 0c             	sub    $0xc,%esp
		tstatus->aborted = 1;
    46c6:	c7 47 14 01 00 00 00 	movl   $0x1,0x14(%edi)
		posix_abort_thread(thread_idx);
    46cd:	53                   	push   %ebx
    46ce:	e8 10 ff ff ff       	call   45e3 <posix_abort_thread>
    46d3:	83 c4 10             	add    $0x10,%esp
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    46d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    46d9:	89 45 08             	mov    %eax,0x8(%ebp)
}
    46dc:	8d 65 f4             	lea    -0xc(%ebp),%esp
    46df:	5b                   	pop    %ebx
    46e0:	5e                   	pop    %esi
    46e1:	5f                   	pop    %edi
    46e2:	5d                   	pop    %ebp
	z_reschedule_irqlock(key);
    46e3:	e9 c0 24 00 00       	jmp    6ba8 <z_reschedule_irqlock>

000046e8 <arch_swap>:
#include "posix_core.h"
#include "irq.h"
#include "kswap.h"

int arch_swap(unsigned int key)
{
    46e8:	55                   	push   %ebp
    46e9:	89 e5                	mov    %esp,%ebp
    46eb:	83 ec 10             	sub    $0x10,%esp
	 *
	 * Here a "real" arch would save all processor registers, stack pointer
	 * and so forth.  But we do not need to do so because we use posix
	 * threads => those are all nicely kept by the native OS kernel
	 */
	_kernel.current->callee_saved.key = key;
    46ee:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
    46f3:	8b 55 08             	mov    0x8(%ebp),%edx
	_kernel.current->callee_saved.retval = -EAGAIN;
    46f6:	c7 40 2c f5 ff ff ff 	movl   $0xfffffff5,0x2c(%eax)
	_kernel.current->callee_saved.key = key;
    46fd:	89 50 28             	mov    %edx,0x28(%eax)
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
    4700:	8b 15 e0 d8 00 00    	mov    0xd8e0,%edx

	posix_thread_status_t *this_thread_ptr  =
    4706:	8b 40 30             	mov    0x30(%eax),%eax
	posix_thread_status_t *ready_thread_ptr =
    4709:	8b 4a 30             	mov    0x30(%edx),%ecx
		(posix_thread_status_t *)
		_kernel.current->callee_saved.thread_status;


	_kernel.current = _kernel.ready_q.cache;
    470c:	89 15 c8 d8 00 00    	mov    %edx,0xd8c8
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
    4712:	ff 70 10             	pushl  0x10(%eax)
    4715:	ff 71 10             	pushl  0x10(%ecx)
    4718:	e8 b2 fc ff ff       	call   43cf <posix_swap>
    471d:	58                   	pop    %eax
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_kernel.current->callee_saved.key);
    471e:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
	posix_irq_unlock(key);
    4723:	ff 70 28             	pushl  0x28(%eax)
    4726:	e8 51 0d 00 00       	call   547c <posix_irq_unlock>

	return _kernel.current->callee_saved.retval;
    472b:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
    4730:	83 c4 10             	add    $0x10,%esp
    4733:	8b 40 2c             	mov    0x2c(%eax),%eax
}
    4736:	c9                   	leave  
    4737:	c3                   	ret    

00004738 <arch_switch_to_main_thread>:
				k_thread_stack_t *main_stack,
				size_t main_stack_size, k_thread_entry_t _main)
{
	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
    4738:	a1 e0 d8 00 00       	mov    0xd8e0,%eax
{
    473d:	55                   	push   %ebp
    473e:	89 e5                	mov    %esp,%ebp
	posix_thread_status_t *ready_thread_ptr =
    4740:	8b 50 30             	mov    0x30(%eax),%edx

	sys_trace_thread_switched_out();

	_kernel.current = _kernel.ready_q.cache;
    4743:	a3 c8 d8 00 00       	mov    %eax,0xd8c8

	sys_trace_thread_switched_in();

	posix_main_thread_start(ready_thread_ptr->thread_idx);
    4748:	8b 42 10             	mov    0x10(%edx),%eax
    474b:	89 45 08             	mov    %eax,0x8(%ebp)
} /* LCOV_EXCL_LINE */
    474e:	5d                   	pop    %ebp
	posix_main_thread_start(ready_thread_ptr->thread_idx);
    474f:	e9 c2 fc ff ff       	jmp    4416 <posix_main_thread_start>

00004754 <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stack_size, k_thread_entry_t thread_func,
		     void *arg1, void *arg2, void *arg3,
		     int priority, unsigned int options)
{
    4754:	55                   	push   %ebp
    4755:	89 e5                	mov    %esp,%ebp
    4757:	57                   	push   %edi
    4758:	56                   	push   %esi
    4759:	53                   	push   %ebx
    475a:	83 ec 2c             	sub    $0x2c,%esp
    475d:	8b 45 08             	mov    0x8(%ebp),%eax
    4760:	8b 5d 24             	mov    0x24(%ebp),%ebx
    4763:	8b 7d 0c             	mov    0xc(%ebp),%edi
    4766:	8b 75 10             	mov    0x10(%ebp),%esi
    4769:	8b 55 28             	mov    0x28(%ebp),%edx
    476c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    476f:	8b 45 14             	mov    0x14(%ebp),%eax

	char *stack_memory = Z_THREAD_STACK_BUFFER(stack);

	Z_ASSERT_VALID_PRIO(priority, thread_func);
    4772:	83 fb 0f             	cmp    $0xf,%ebx
{
    4775:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4778:	8b 45 18             	mov    0x18(%ebp),%eax
    477b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    477e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    4781:	89 45 d8             	mov    %eax,-0x28(%ebp)
    4784:	8b 45 20             	mov    0x20(%ebp),%eax
    4787:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	Z_ASSERT_VALID_PRIO(priority, thread_func);
    478a:	75 09                	jne    4795 <arch_new_thread+0x41>
    478c:	81 7d e0 b4 64 00 00 	cmpl   $0x64b4,-0x20(%ebp)
    4793:	74 47                	je     47dc <arch_new_thread+0x88>
    4795:	8d 4b 10             	lea    0x10(%ebx),%ecx
    4798:	83 f9 1e             	cmp    $0x1e,%ecx
    479b:	76 3f                	jbe    47dc <arch_new_thread+0x88>
    479d:	6a 23                	push   $0x23
    479f:	68 6f 8f 00 00       	push   $0x8f6f
    47a4:	68 aa 8f 00 00       	push   $0x8faa
    47a9:	68 e6 8b 00 00       	push   $0x8be6
    47ae:	89 55 d0             	mov    %edx,-0x30(%ebp)
    47b1:	e8 d9 f7 ff ff       	call   3f8f <printk>
    47b6:	83 c4 10             	add    $0x10,%esp
    47b9:	6a f0                	push   $0xfffffff0
    47bb:	6a 0e                	push   $0xe
    47bd:	53                   	push   %ebx
    47be:	68 3c 90 00 00       	push   $0x903c
    47c3:	e8 c7 f7 ff ff       	call   3f8f <printk>
    47c8:	58                   	pop    %eax
    47c9:	5a                   	pop    %edx
    47ca:	6a 23                	push   $0x23
    47cc:	68 6f 8f 00 00       	push   $0x8f6f
    47d1:	e8 4d f8 ff ff       	call   4023 <assert_post_action>
    47d6:	8b 55 d0             	mov    -0x30(%ebp),%edx
    47d9:	83 c4 10             	add    $0x10,%esp

	posix_thread_status_t *thread_status;

	z_new_thread_init(thread, stack_memory, stack_size, priority, options);
    47dc:	83 ec 0c             	sub    $0xc,%esp
    47df:	52                   	push   %edx
    47e0:	53                   	push   %ebx
    47e1:	56                   	push   %esi
    47e2:	57                   	push   %edi
    47e3:	ff 75 e4             	pushl  -0x1c(%ebp)
    47e6:	e8 f4 37 00 00       	call   7fdf <z_new_thread_init>
	thread_status = (posix_thread_status_t *)
		STACK_ROUND_DOWN(stack_memory + stack_size
				- sizeof(*thread_status));

	/* z_thread_entry() arguments */
	thread_status->entry_point = thread_func;
    47eb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
		STACK_ROUND_DOWN(stack_memory + stack_size
    47ee:	8d 44 37 e8          	lea    -0x18(%edi,%esi,1),%eax
	thread_status->arg1 = arg1;
	thread_status->arg2 = arg2;
	thread_status->arg3 = arg3;
    47f2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	thread_status->arg1 = arg1;
    47f5:	8b 75 dc             	mov    -0x24(%ebp),%esi
	thread_status->arg2 = arg2;
    47f8:	8b 7d d8             	mov    -0x28(%ebp),%edi
	z_new_thread_init(thread, stack_memory, stack_size, priority, options);
    47fb:	83 c4 20             	add    $0x20,%esp
		STACK_ROUND_DOWN(stack_memory + stack_size
    47fe:	83 e0 fc             	and    $0xfffffffc,%eax
	thread_status->entry_point = thread_func;
    4801:	89 08                	mov    %ecx,(%eax)
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
#endif

	thread->callee_saved.thread_status = thread_status;
    4803:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	thread_status->arg1 = arg1;
    4806:	89 70 04             	mov    %esi,0x4(%eax)
	thread_status->arg2 = arg2;
    4809:	89 78 08             	mov    %edi,0x8(%eax)
	thread_status->arg3 = arg3;
    480c:	89 50 0c             	mov    %edx,0xc(%eax)
	thread_status->aborted = 0;
    480f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	thread->callee_saved.thread_status = thread_status;
    4816:	89 41 30             	mov    %eax,0x30(%ecx)

	posix_new_thread(thread_status);
    4819:	89 45 08             	mov    %eax,0x8(%ebp)
}
    481c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    481f:	5b                   	pop    %ebx
    4820:	5e                   	pop    %esi
    4821:	5f                   	pop    %edi
    4822:	5d                   	pop    %ebp
	posix_new_thread(thread_status);
    4823:	e9 22 fc ff ff       	jmp    444a <posix_new_thread>

00004828 <posix_new_thread_pre_start>:

void posix_new_thread_pre_start(void)
{
    4828:	55                   	push   %ebp
    4829:	89 e5                	mov    %esp,%ebp
	posix_irq_full_unlock();
}
    482b:	5d                   	pop    %ebp
	posix_irq_full_unlock();
    482c:	e9 54 0c 00 00       	jmp    5485 <posix_irq_full_unlock>

00004831 <pc_safe_call>:
	if (unlikely(test)) {
    4831:	85 c0                	test   %eax,%eax
    4833:	74 16                	je     484b <pc_safe_call+0x1a>
{
    4835:	55                   	push   %ebp
    4836:	89 e5                	mov    %esp,%ebp
    4838:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    483b:	52                   	push   %edx
    483c:	68 27 8d 00 00       	push   $0x8d27
    4841:	e8 9f 10 00 00       	call   58e5 <posix_print_error_and_exit>
    4846:	83 c4 10             	add    $0x10,%esp
}
    4849:	c9                   	leave  
    484a:	c3                   	ret    
    484b:	c3                   	ret    

0000484c <posix_change_cpu_state_and_wait>:
 * This is how the idle thread halts the CPU and gets halted until the HW models
 * raise a new interrupt; and how the HW models awake the CPU, and wait for it
 * to complete and go to idle.
 */
static void posix_change_cpu_state_and_wait(bool halted)
{
    484c:	55                   	push   %ebp
    484d:	89 e5                	mov    %esp,%ebp
    484f:	56                   	push   %esi
    4850:	53                   	push   %ebx
    4851:	89 c6                	mov    %eax,%esi
    4853:	89 c3                	mov    %eax,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    4855:	83 ec 0c             	sub    $0xc,%esp
    4858:	68 28 da 00 00       	push   $0xda28
    485d:	e8 fc ff ff ff       	call   485e <posix_change_cpu_state_and_wait+0x12>
    4862:	ba 6d 90 00 00       	mov    $0x906d,%edx
    4867:	83 c4 10             	add    $0x10,%esp
    486a:	e8 c2 ff ff ff       	call   4831 <pc_safe_call>
	PS_DEBUG("Going to halted = %d\n", halted);

	cpu_halted = halted;

	/* We let the other side know the CPU has changed state */
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    486f:	83 ec 0c             	sub    $0xc,%esp
	cpu_halted = halted;
    4872:	88 1d 18 c2 00 00    	mov    %bl,0xc218
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    4878:	68 c0 d4 00 00       	push   $0xd4c0
    487d:	e8 fc ff ff ff       	call   487e <posix_change_cpu_state_and_wait+0x32>
    4882:	83 c4 10             	add    $0x10,%esp
    4885:	ba 8a 90 00 00       	mov    $0x908a,%edx
    488a:	e8 a2 ff ff ff       	call   4831 <pc_safe_call>
	 * anything else)
	 *  or
	 * we are just hanging it, and therefore wait until the HW models awake
	 * it again
	 */
	while (cpu_halted == halted) {
    488f:	89 f0                	mov    %esi,%eax
    4891:	38 05 18 c2 00 00    	cmp    %al,0xc218
    4897:	75 16                	jne    48af <posix_change_cpu_state_and_wait+0x63>
		/* Here we unlock the mutex while waiting */
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    4899:	50                   	push   %eax
    489a:	50                   	push   %eax
    489b:	68 28 da 00 00       	push   $0xda28
    48a0:	68 c0 d4 00 00       	push   $0xd4c0
    48a5:	e8 fc ff ff ff       	call   48a6 <posix_change_cpu_state_and_wait+0x5a>
    48aa:	83 c4 10             	add    $0x10,%esp
    48ad:	eb e0                	jmp    488f <posix_change_cpu_state_and_wait+0x43>
	}

	PS_DEBUG("Awaken after halted = %d\n", halted);

	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    48af:	83 ec 0c             	sub    $0xc,%esp
    48b2:	68 28 da 00 00       	push   $0xda28
    48b7:	e8 fc ff ff ff       	call   48b8 <posix_change_cpu_state_and_wait+0x6c>
    48bc:	83 c4 10             	add    $0x10,%esp
}
    48bf:	8d 65 f8             	lea    -0x8(%ebp),%esp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    48c2:	ba ac 90 00 00       	mov    $0x90ac,%edx
}
    48c7:	5b                   	pop    %ebx
    48c8:	5e                   	pop    %esi
    48c9:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    48ca:	e9 62 ff ff ff       	jmp    4831 <pc_safe_call>

000048cf <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
    48cf:	55                   	push   %ebp
    48d0:	89 e5                	mov    %esp,%ebp
    48d2:	83 ec 14             	sub    $0x14,%esp
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    48d5:	68 28 da 00 00       	push   $0xda28
    48da:	e8 fc ff ff ff       	call   48db <zephyr_wrapper+0xc>
    48df:	ba 6d 90 00 00       	mov    $0x906d,%edx
    48e4:	83 c4 10             	add    $0x10,%esp
    48e7:	e8 45 ff ff ff       	call   4831 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    48ec:	83 ec 0c             	sub    $0xc,%esp
    48ef:	68 28 da 00 00       	push   $0xda28
    48f4:	e8 fc ff ff ff       	call   48f5 <zephyr_wrapper+0x26>
    48f9:	83 c4 10             	add    $0x10,%esp
    48fc:	ba ac 90 00 00       	mov    $0x90ac,%edx
    4901:	e8 2b ff ff ff       	call   4831 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
    4906:	e8 05 fc ff ff       	call   4510 <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
    490b:	e8 1f 1c 00 00       	call   652f <z_cstart>

00004910 <posix_is_cpu_running>:
	return !cpu_halted;
    4910:	a0 18 c2 00 00       	mov    0xc218,%al
{
    4915:	55                   	push   %ebp
    4916:	89 e5                	mov    %esp,%ebp
	return !cpu_halted;
    4918:	83 f0 01             	xor    $0x1,%eax
    491b:	0f b6 c0             	movzbl %al,%eax
}
    491e:	5d                   	pop    %ebp
    491f:	c3                   	ret    

00004920 <posix_interrupt_raised>:
{
    4920:	55                   	push   %ebp
	posix_change_cpu_state_and_wait(false);
    4921:	31 c0                	xor    %eax,%eax
{
    4923:	89 e5                	mov    %esp,%ebp
    4925:	83 ec 08             	sub    $0x8,%esp
	posix_change_cpu_state_and_wait(false);
    4928:	e8 1f ff ff ff       	call   484c <posix_change_cpu_state_and_wait>
	if (soc_terminate) {
    492d:	80 3d 9e da 00 00 00 	cmpb   $0x0,0xda9e
    4934:	74 0d                	je     4943 <posix_interrupt_raised+0x23>
		posix_exit(0);
    4936:	83 ec 0c             	sub    $0xc,%esp
    4939:	6a 00                	push   $0x0
    493b:	e8 74 0e 00 00       	call   57b4 <posix_exit>
    4940:	83 c4 10             	add    $0x10,%esp
}
    4943:	c9                   	leave  
    4944:	c3                   	ret    

00004945 <posix_halt_cpu>:
{
    4945:	55                   	push   %ebp
	posix_change_cpu_state_and_wait(true);
    4946:	b8 01 00 00 00       	mov    $0x1,%eax
{
    494b:	89 e5                	mov    %esp,%ebp
    494d:	83 ec 08             	sub    $0x8,%esp
	posix_change_cpu_state_and_wait(true);
    4950:	e8 f7 fe ff ff       	call   484c <posix_change_cpu_state_and_wait>
}
    4955:	c9                   	leave  
	posix_irq_handler();
    4956:	e9 cf 09 00 00       	jmp    532a <posix_irq_handler>

0000495b <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
    495b:	55                   	push   %ebp
    495c:	89 e5                	mov    %esp,%ebp
    495e:	83 ec 24             	sub    $0x24,%esp
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    4961:	68 28 da 00 00       	push   $0xda28
{
    4966:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    496c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    496f:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    4971:	e8 fc ff ff ff       	call   4972 <posix_boot_cpu+0x17>
    4976:	83 c4 10             	add    $0x10,%esp
    4979:	ba 6d 90 00 00       	mov    $0x906d,%edx
    497e:	e8 ae fe ff ff       	call   4831 <pc_safe_call>
	cpu_halted = false;

	pthread_t zephyr_thread;

	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    4983:	8d 45 f0             	lea    -0x10(%ebp),%eax
    4986:	6a 00                	push   $0x0
    4988:	68 cf 48 00 00       	push   $0x48cf
    498d:	6a 00                	push   $0x0
	cpu_halted = false;
    498f:	c6 05 18 c2 00 00 00 	movb   $0x0,0xc218
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
    4996:	50                   	push   %eax
    4997:	e8 fc ff ff ff       	call   4998 <posix_boot_cpu+0x3d>
    499c:	83 c4 10             	add    $0x10,%esp
    499f:	ba cb 90 00 00       	mov    $0x90cb,%edx
    49a4:	e8 88 fe ff ff       	call   4831 <pc_safe_call>

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
    49a9:	80 3d 18 c2 00 00 00 	cmpb   $0x0,0xc218
    49b0:	75 16                	jne    49c8 <posix_boot_cpu+0x6d>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
    49b2:	50                   	push   %eax
    49b3:	50                   	push   %eax
    49b4:	68 28 da 00 00       	push   $0xda28
    49b9:	68 c0 d4 00 00       	push   $0xd4c0
    49be:	e8 fc ff ff ff       	call   49bf <posix_boot_cpu+0x64>
    49c3:	83 c4 10             	add    $0x10,%esp
    49c6:	eb e1                	jmp    49a9 <posix_boot_cpu+0x4e>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    49c8:	83 ec 0c             	sub    $0xc,%esp
    49cb:	68 28 da 00 00       	push   $0xda28
    49d0:	e8 fc ff ff ff       	call   49d1 <posix_boot_cpu+0x76>
    49d5:	83 c4 10             	add    $0x10,%esp
    49d8:	ba ac 90 00 00       	mov    $0x90ac,%edx
    49dd:	e8 4f fe ff ff       	call   4831 <pc_safe_call>

	if (soc_terminate) {
    49e2:	80 3d 9e da 00 00 00 	cmpb   $0x0,0xda9e
    49e9:	74 0d                	je     49f8 <posix_boot_cpu+0x9d>
		posix_exit(0);
    49eb:	83 ec 0c             	sub    $0xc,%esp
    49ee:	6a 00                	push   $0x0
    49f0:	e8 bf 0d 00 00       	call   57b4 <posix_exit>
    49f5:	83 c4 10             	add    $0x10,%esp
	}
}
    49f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49fb:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    4a02:	74 05                	je     4a09 <posix_boot_cpu+0xae>
    4a04:	e8 fc ff ff ff       	call   4a05 <posix_boot_cpu+0xaa>
    4a09:	c9                   	leave  
    4a0a:	c3                   	ret    

00004a0b <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
    4a0b:	55                   	push   %ebp
    4a0c:	89 e5                	mov    %esp,%ebp
    4a0e:	56                   	push   %esi
    4a0f:	53                   	push   %ebx
    4a10:	8b 75 08             	mov    0x8(%ebp),%esi
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
    4a13:	8b 1c b5 a4 8a 00 00 	mov    0x8aa4(,%esi,4),%ebx
    4a1a:	39 1c b5 a8 8a 00 00 	cmp    %ebx,0x8aa8(,%esi,4)
    4a21:	76 0d                	jbe    4a30 <run_native_tasks+0x25>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
    4a23:	8b 03                	mov    (%ebx),%eax
    4a25:	85 c0                	test   %eax,%eax
    4a27:	74 02                	je     4a2b <run_native_tasks+0x20>
			(*fptr)();
    4a29:	ff d0                	call   *%eax
		fptr++) {
    4a2b:	83 c3 04             	add    $0x4,%ebx
    4a2e:	eb ea                	jmp    4a1a <run_native_tasks+0xf>
		}
	}
}
    4a30:	5b                   	pop    %ebx
    4a31:	5e                   	pop    %esi
    4a32:	5d                   	pop    %ebp
    4a33:	c3                   	ret    

00004a34 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
    4a34:	55                   	push   %ebp
    4a35:	89 e5                	mov    %esp,%ebp
    4a37:	83 ec 08             	sub    $0x8,%esp
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
    4a3a:	80 3d 18 c2 00 00 00 	cmpb   $0x0,0xc218
    4a41:	74 14                	je     4a57 <posix_soc_clean_up+0x23>

		posix_core_clean_up();
    4a43:	e8 2c fb ff ff       	call   4574 <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
    4a48:	83 ec 0c             	sub    $0xc,%esp
    4a4b:	6a 04                	push   $0x4
    4a4d:	e8 b9 ff ff ff       	call   4a0b <run_native_tasks>
    4a52:	83 c4 10             	add    $0x10,%esp
    4a55:	eb 74                	jmp    4acb <posix_soc_clean_up+0x97>

	} else if (soc_terminate == false) {
    4a57:	80 3d 9e da 00 00 00 	cmpb   $0x0,0xda9e
    4a5e:	75 6b                	jne    4acb <posix_soc_clean_up+0x97>

		soc_terminate = true;

		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    4a60:	83 ec 0c             	sub    $0xc,%esp
		soc_terminate = true;
    4a63:	c6 05 9e da 00 00 01 	movb   $0x1,0xda9e
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
    4a6a:	68 28 da 00 00       	push   $0xda28
    4a6f:	e8 fc ff ff ff       	call   4a70 <posix_soc_clean_up+0x3c>
    4a74:	ba 6d 90 00 00       	mov    $0x906d,%edx
    4a79:	83 c4 10             	add    $0x10,%esp
    4a7c:	e8 b0 fd ff ff       	call   4831 <pc_safe_call>

		cpu_halted = true;

		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    4a81:	83 ec 0c             	sub    $0xc,%esp
		cpu_halted = true;
    4a84:	c6 05 18 c2 00 00 01 	movb   $0x1,0xc218
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
    4a8b:	68 c0 d4 00 00       	push   $0xd4c0
    4a90:	e8 fc ff ff ff       	call   4a91 <posix_soc_clean_up+0x5d>
    4a95:	ba 8a 90 00 00       	mov    $0x908a,%edx
    4a9a:	83 c4 10             	add    $0x10,%esp
    4a9d:	e8 8f fd ff ff       	call   4831 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
    4aa2:	83 ec 0c             	sub    $0xc,%esp
    4aa5:	68 28 da 00 00       	push   $0xda28
    4aaa:	e8 fc ff ff ff       	call   4aab <posix_soc_clean_up+0x77>
    4aaf:	83 c4 10             	add    $0x10,%esp
    4ab2:	ba ac 90 00 00       	mov    $0x90ac,%edx
    4ab7:	e8 75 fd ff ff       	call   4831 <pc_safe_call>

		while (1) {
			sleep(1);
    4abc:	83 ec 0c             	sub    $0xc,%esp
    4abf:	6a 01                	push   $0x1
    4ac1:	e8 fc ff ff ff       	call   4ac2 <posix_soc_clean_up+0x8e>
    4ac6:	83 c4 10             	add    $0x10,%esp
    4ac9:	eb f1                	jmp    4abc <posix_soc_clean_up+0x88>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
    4acb:	c9                   	leave  
    4acc:	c3                   	ret    

00004acd <hwm_signal_end_handler>:

/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
    4acd:	55                   	push   %ebp
	signaled_end = 1;
    4ace:	c7 05 40 da 00 00 01 	movl   $0x1,0xda40
    4ad5:	00 00 00 
{
    4ad8:	89 e5                	mov    %esp,%ebp
}
    4ada:	5d                   	pop    %ebp
    4adb:	c3                   	ret    

00004adc <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
    4adc:	55                   	push   %ebp
    4add:	89 e5                	mov    %esp,%ebp
    4adf:	53                   	push   %ebx
    4ae0:	81 ec a0 00 00 00    	sub    $0xa0,%esp
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
    4ae6:	c7 85 68 ff ff ff cd 	movl   $0x4acd,-0x98(%ebp)
    4aed:	4a 00 00 
{
    4af0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    4af6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4af9:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
    4afb:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    4b01:	50                   	push   %eax
    4b02:	e8 fc ff ff ff       	call   4b03 <hwm_set_sig_handler+0x27>
    4b07:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
    4b0a:	85 c0                	test   %eax,%eax
    4b0c:	74 14                	je     4b22 <hwm_set_sig_handler+0x46>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    4b0e:	50                   	push   %eax
    4b0f:	50                   	push   %eax
    4b10:	68 06 91 00 00       	push   $0x9106
    4b15:	68 27 8d 00 00       	push   $0x8d27
    4b1a:	e8 c6 0d 00 00       	call   58e5 <posix_print_error_and_exit>
    4b1f:	83 c4 10             	add    $0x10,%esp

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    4b22:	53                   	push   %ebx
    4b23:	8d 9d 68 ff ff ff    	lea    -0x98(%ebp),%ebx
    4b29:	6a 00                	push   $0x0
	act.sa_flags = SA_RESETHAND;
    4b2b:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
    4b32:	53                   	push   %ebx
    4b33:	6a 0f                	push   $0xf
    4b35:	e8 fc ff ff ff       	call   4b36 <hwm_set_sig_handler+0x5a>
    4b3a:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
    4b3d:	85 c0                	test   %eax,%eax
    4b3f:	74 14                	je     4b55 <hwm_set_sig_handler+0x79>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    4b41:	51                   	push   %ecx
    4b42:	51                   	push   %ecx
    4b43:	68 20 91 00 00       	push   $0x9120
    4b48:	68 27 8d 00 00       	push   $0x8d27
    4b4d:	e8 93 0d 00 00       	call   58e5 <posix_print_error_and_exit>
    4b52:	83 c4 10             	add    $0x10,%esp
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
    4b55:	52                   	push   %edx
    4b56:	6a 00                	push   $0x0
    4b58:	53                   	push   %ebx
    4b59:	6a 02                	push   $0x2
    4b5b:	e8 fc ff ff ff       	call   4b5c <hwm_set_sig_handler+0x80>
    4b60:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
    4b63:	85 c0                	test   %eax,%eax
    4b65:	74 14                	je     4b7b <hwm_set_sig_handler+0x9f>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
    4b67:	50                   	push   %eax
    4b68:	50                   	push   %eax
    4b69:	68 3f 91 00 00       	push   $0x913f
    4b6e:	68 27 8d 00 00       	push   $0x8d27
    4b73:	e8 6d 0d 00 00       	call   58e5 <posix_print_error_and_exit>
    4b78:	83 c4 10             	add    $0x10,%esp
}
    4b7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b7e:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    4b85:	74 05                	je     4b8c <hwm_set_sig_handler+0xb0>
    4b87:	e8 fc ff ff ff       	call   4b88 <hwm_set_sig_handler+0xac>
    4b8c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4b8f:	c9                   	leave  
    4b90:	c3                   	ret    

00004b91 <hwm_find_next_timer>:
/**
 * Find in between all timers which is the next one
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
    4b91:	55                   	push   %ebp
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
    4b92:	a1 ec c1 00 00       	mov    0xc1ec,%eax
	next_timer_time  = *Timer_list[0];
    4b97:	8b 0d d8 d9 00 00    	mov    0xd9d8,%ecx
	next_timer_index = 0;
    4b9d:	c7 05 f8 c1 00 00 00 	movl   $0x0,0xc1f8
    4ba4:	00 00 00 
{
    4ba7:	89 e5                	mov    %esp,%ebp
    4ba9:	53                   	push   %ebx
	next_timer_time  = *Timer_list[0];
    4baa:	8b 1d dc d9 00 00    	mov    0xd9dc,%ebx
		if (next_timer_time > *Timer_list[i]) {
    4bb0:	8b 15 e8 c1 00 00    	mov    0xc1e8,%edx
	next_timer_time  = *Timer_list[0];
    4bb6:	89 0d 90 d9 00 00    	mov    %ecx,0xd990
		if (next_timer_time > *Timer_list[i]) {
    4bbc:	39 c3                	cmp    %eax,%ebx
	next_timer_time  = *Timer_list[0];
    4bbe:	89 1d 94 d9 00 00    	mov    %ebx,0xd994
		if (next_timer_time > *Timer_list[i]) {
    4bc4:	72 1b                	jb     4be1 <hwm_find_next_timer+0x50>
    4bc6:	77 04                	ja     4bcc <hwm_find_next_timer+0x3b>
    4bc8:	39 d1                	cmp    %edx,%ecx
    4bca:	76 15                	jbe    4be1 <hwm_find_next_timer+0x50>
			next_timer_index = i;
    4bcc:	c7 05 f8 c1 00 00 01 	movl   $0x1,0xc1f8
    4bd3:	00 00 00 
			next_timer_time = *Timer_list[i];
    4bd6:	89 15 90 d9 00 00    	mov    %edx,0xd990
    4bdc:	a3 94 d9 00 00       	mov    %eax,0xd994
		}
	}
}
    4be1:	5b                   	pop    %ebx
    4be2:	5d                   	pop    %ebp
    4be3:	c3                   	ret    

00004be4 <hwm_main_loop>:
/**
 * Entry point for the HW models
 * The HW models execute in an infinite loop until terminated
 */
void hwm_main_loop(void)
{
    4be4:	55                   	push   %ebp
    4be5:	89 e5                	mov    %esp,%ebp
    4be7:	53                   	push   %ebx
    4be8:	83 ec 14             	sub    $0x14,%esp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
    4beb:	8b 15 94 d9 00 00    	mov    0xd994,%edx
    4bf1:	8b 1d 9c d9 00 00    	mov    0xd99c,%ebx
    4bf7:	a1 90 d9 00 00       	mov    0xd990,%eax
    4bfc:	8b 0d 98 d9 00 00    	mov    0xd998,%ecx
    4c02:	39 da                	cmp    %ebx,%edx
    4c04:	72 13                	jb     4c19 <hwm_main_loop+0x35>
    4c06:	77 04                	ja     4c0c <hwm_main_loop+0x28>
    4c08:	39 c8                	cmp    %ecx,%eax
    4c0a:	72 0d                	jb     4c19 <hwm_main_loop+0x35>
		simu_time = next_timer_time;
    4c0c:	a3 98 d9 00 00       	mov    %eax,0xd998
    4c11:	89 15 9c d9 00 00    	mov    %edx,0xd99c
    4c17:	eb 1a                	jmp    4c33 <hwm_main_loop+0x4f>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
    4c19:	83 ec 08             	sub    $0x8,%esp
    4c1c:	ff 35 f8 c1 00 00    	pushl  0xc1f8
    4c22:	53                   	push   %ebx
    4c23:	51                   	push   %ecx
    4c24:	52                   	push   %edx
    4c25:	50                   	push   %eax
    4c26:	68 5d 91 00 00       	push   $0x915d
    4c2b:	e8 e0 0c 00 00       	call   5910 <posix_print_warning>
    4c30:	83 c4 20             	add    $0x20,%esp
	if (signaled_end || (simu_time > end_of_time)) {
    4c33:	8b 0d 40 da 00 00    	mov    0xda40,%ecx
    4c39:	a1 98 d9 00 00       	mov    0xd998,%eax
    4c3e:	8b 15 9c d9 00 00    	mov    0xd99c,%edx
    4c44:	85 c9                	test   %ecx,%ecx
    4c46:	75 12                	jne    4c5a <hwm_main_loop+0x76>
    4c48:	39 15 dc c1 00 00    	cmp    %edx,0xc1dc
    4c4e:	77 42                	ja     4c92 <hwm_main_loop+0xae>
    4c50:	72 08                	jb     4c5a <hwm_main_loop+0x76>
    4c52:	39 05 d8 c1 00 00    	cmp    %eax,0xc1d8
    4c58:	73 38                	jae    4c92 <hwm_main_loop+0xae>
				((long double)simu_time)/1.0e6);
    4c5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    4c5d:	89 55 f4             	mov    %edx,-0xc(%ebp)
    4c60:	85 d2                	test   %edx,%edx
    4c62:	df 6d f0             	fildll -0x10(%ebp)
    4c65:	79 06                	jns    4c6d <hwm_main_loop+0x89>
    4c67:	d8 05 bc 8a 00 00    	fadds  0x8abc
		posix_print_trace("\nStopped at %.3Lfs\n",
    4c6d:	d8 35 c0 8a 00 00    	fdivs  0x8ac0
    4c73:	83 ec 0c             	sub    $0xc,%esp
    4c76:	db 3c 24             	fstpt  (%esp)
    4c79:	68 94 91 00 00       	push   $0x9194
    4c7e:	e8 ac 0c 00 00       	call   592f <posix_print_trace>
		posix_exit(0);
    4c83:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    4c8a:	e8 25 0b 00 00       	call   57b4 <posix_exit>
    4c8f:	83 c4 10             	add    $0x10,%esp
	while (1) {
		hwm_sleep_until_next_timer();

		switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
    4c92:	a1 f8 c1 00 00       	mov    0xc1f8,%eax
    4c97:	85 c0                	test   %eax,%eax
    4c99:	74 0a                	je     4ca5 <hwm_main_loop+0xc1>
    4c9b:	48                   	dec    %eax
    4c9c:	75 0e                	jne    4cac <hwm_main_loop+0xc8>
		case HWTIMER:
			hwtimer_timer_reached();
			break;
		case IRQCNT:
			hw_irq_ctrl_timer_triggered();
    4c9e:	e8 f4 0a 00 00       	call   5797 <hw_irq_ctrl_timer_triggered>
			break;
    4ca3:	eb 17                	jmp    4cbc <hwm_main_loop+0xd8>
			hwtimer_timer_reached();
    4ca5:	e8 6f 04 00 00       	call   5119 <hwtimer_timer_reached>
			break;
    4caa:	eb 10                	jmp    4cbc <hwm_main_loop+0xd8>
			sdl_handle_events();
			break;
#endif
		default:
			/* LCOV_EXCL_START */
			posix_print_error_and_exit(
    4cac:	83 ec 0c             	sub    $0xc,%esp
    4caf:	68 a8 91 00 00       	push   $0x91a8
    4cb4:	e8 2c 0c 00 00       	call   58e5 <posix_print_error_and_exit>
    4cb9:	83 c4 10             	add    $0x10,%esp
					"next_timer_index corrupted\n");
			break;
			/* LCOV_EXCL_STOP */
		}

		hwm_find_next_timer();
    4cbc:	e8 d0 fe ff ff       	call   4b91 <hwm_find_next_timer>
		hwm_sleep_until_next_timer();
    4cc1:	e9 25 ff ff ff       	jmp    4beb <hwm_main_loop+0x7>

00004cc6 <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(u64_t new_end_of_time)
{
    4cc6:	55                   	push   %ebp
    4cc7:	89 e5                	mov    %esp,%ebp
	end_of_time = new_end_of_time;
    4cc9:	8b 45 08             	mov    0x8(%ebp),%eax
    4ccc:	8b 55 0c             	mov    0xc(%ebp),%edx
}
    4ccf:	5d                   	pop    %ebp
	end_of_time = new_end_of_time;
    4cd0:	a3 d8 c1 00 00       	mov    %eax,0xc1d8
    4cd5:	89 15 dc c1 00 00    	mov    %edx,0xc1dc
}
    4cdb:	c3                   	ret    

00004cdc <hwm_get_time>:

/**
 * Return the current time as known by the device
 */
u64_t hwm_get_time(void)
{
    4cdc:	55                   	push   %ebp
	return simu_time;
}
    4cdd:	a1 98 d9 00 00       	mov    0xd998,%eax
    4ce2:	8b 15 9c d9 00 00    	mov    0xd99c,%edx
{
    4ce8:	89 e5                	mov    %esp,%ebp
}
    4cea:	5d                   	pop    %ebp
    4ceb:	c3                   	ret    

00004cec <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
    4cec:	55                   	push   %ebp
    4ced:	89 e5                	mov    %esp,%ebp
    4cef:	83 ec 08             	sub    $0x8,%esp
	hwm_set_sig_handler();
    4cf2:	e8 e5 fd ff ff       	call   4adc <hwm_set_sig_handler>
	hwtimer_init();
    4cf7:	e8 91 02 00 00       	call   4f8d <hwtimer_init>
	hw_irq_ctrl_init();
    4cfc:	e8 5f 08 00 00       	call   5560 <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
    4d01:	c9                   	leave  
	hwm_find_next_timer();
    4d02:	e9 8a fe ff ff       	jmp    4b91 <hwm_find_next_timer>

00004d07 <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
    4d07:	55                   	push   %ebp
    4d08:	89 e5                	mov    %esp,%ebp
    4d0a:	83 ec 08             	sub    $0x8,%esp
	hwtimer_cleanup();
    4d0d:	e8 c4 03 00 00       	call   50d6 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
    4d12:	c9                   	leave  
	hw_irq_ctrl_cleanup();
    4d13:	e9 92 08 00 00       	jmp    55aa <hw_irq_ctrl_cleanup>

00004d18 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    4d18:	8b 0d d4 d9 00 00    	mov    0xd9d4,%ecx
    4d1e:	a1 cc d9 00 00       	mov    0xd9cc,%eax
{
    4d23:	55                   	push   %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    4d24:	8b 15 c8 d9 00 00    	mov    0xd9c8,%edx
    4d2a:	39 c8                	cmp    %ecx,%eax
{
    4d2c:	89 e5                	mov    %esp,%ebp
    4d2e:	53                   	push   %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    4d2f:	8b 1d d0 d9 00 00    	mov    0xd9d0,%ebx
    4d35:	72 0a                	jb     4d41 <hwtimer_update_timer+0x29>
    4d37:	77 04                	ja     4d3d <hwtimer_update_timer+0x25>
    4d39:	39 da                	cmp    %ebx,%edx
    4d3b:	76 04                	jbe    4d41 <hwtimer_update_timer+0x29>
    4d3d:	89 da                	mov    %ebx,%edx
    4d3f:	89 c8                	mov    %ecx,%eax
}
    4d41:	5b                   	pop    %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
    4d42:	89 15 d8 d9 00 00    	mov    %edx,0xd9d8
    4d48:	a3 dc d9 00 00       	mov    %eax,0xd9dc
}
    4d4d:	5d                   	pop    %ebp
    4d4e:	c3                   	ret    

00004d4f <cmd_realtime_found>:
	}
	hwm_set_end_of_time(args.stop_at*1e6);
}

static void cmd_realtime_found(char *argv, int offset)
{
    4d4f:	55                   	push   %ebp
	real_time_mode = new_rt;
    4d50:	c6 05 a0 da 00 00 01 	movb   $0x1,0xdaa0
{
    4d57:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(true);
}
    4d59:	5d                   	pop    %ebp
    4d5a:	c3                   	ret    

00004d5b <cmd_no_realtime_found>:

static void cmd_no_realtime_found(char *argv, int offset)
{
    4d5b:	55                   	push   %ebp
	real_time_mode = new_rt;
    4d5c:	c6 05 a0 da 00 00 00 	movb   $0x0,0xdaa0
{
    4d63:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(false);
}
    4d65:	5d                   	pop    %ebp
    4d66:	c3                   	ret    

00004d67 <cmd_rtcoffset_found>:

static void cmd_rtcoffset_found(char *argv, int offset)
{
    4d67:	55                   	push   %ebp
    4d68:	89 e5                	mov    %esp,%ebp
    4d6a:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
    4d6d:	d9 05 c0 8a 00 00    	flds   0x8ac0
    4d73:	d9 7d fe             	fnstcw -0x2(%ebp)
    4d76:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
    4d7a:	dc 0d 08 d5 00 00    	fmull  0xd508
    4d80:	80 cc 0c             	or     $0xc,%ah
    4d83:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    4d87:	d9 6d fc             	fldcw  -0x4(%ebp)
    4d8a:	df 3d b0 d9 00 00    	fistpll 0xd9b0
    4d90:	d9 6d fe             	fldcw  -0x2(%ebp)
}
    4d93:	c9                   	leave  
    4d94:	c3                   	ret    

00004d95 <cmd_rtcreset_found>:
	}
	hwtimer_set_rt_ratio(args.rt_ratio);
}

static void cmd_rtcreset_found(char *argv, int offset)
{
    4d95:	55                   	push   %ebp
	reset_rtc = true;
    4d96:	c6 05 9f da 00 00 01 	movb   $0x1,0xda9f
{
    4d9d:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}
    4d9f:	5d                   	pop    %ebp
    4da0:	c3                   	ret    

00004da1 <native_add_time_options>:

static void native_add_time_options(void)
{
    4da1:	55                   	push   %ebp
    4da2:	89 e5                	mov    %esp,%ebp
    4da4:	83 ec 14             	sub    $0x14,%esp
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
    4da7:	68 40 c0 00 00       	push   $0xc040
    4dac:	e8 8b 12 00 00       	call   603c <native_add_command_line_opts>
    4db1:	83 c4 10             	add    $0x10,%esp
}
    4db4:	c9                   	leave  
    4db5:	c3                   	ret    

00004db6 <cmd_rt_ratio_found>:
	if ((args.rt_ratio <= 0)) {
    4db6:	dd 05 18 d5 00 00    	fldl   0xd518
    4dbc:	d9 ee                	fldz   
    4dbe:	df e9                	fucomip %st(1),%st
    4dc0:	dd d8                	fstp   %st(0)
    4dc2:	72 21                	jb     4de5 <cmd_rt_ratio_found+0x2f>
{
    4dc4:	55                   	push   %ebp
    4dc5:	89 e5                	mov    %esp,%ebp
    4dc7:	83 ec 14             	sub    $0x14,%esp
		posix_print_error_and_exit("The ratio needs to be > 0. "
    4dca:	68 c4 91 00 00       	push   $0x91c4
    4dcf:	e8 11 0b 00 00       	call   58e5 <posix_print_error_and_exit>
	clock_ratio = ratio;
    4dd4:	dd 05 18 d5 00 00    	fldl   0xd518
		posix_print_error_and_exit("The ratio needs to be > 0. "
    4dda:	83 c4 10             	add    $0x10,%esp
	clock_ratio = ratio;
    4ddd:	dd 1d e0 c1 00 00    	fstpl  0xc1e0
}
    4de3:	c9                   	leave  
    4de4:	c3                   	ret    
	clock_ratio = ratio;
    4de5:	dd 05 18 d5 00 00    	fldl   0xd518
    4deb:	dd 1d e0 c1 00 00    	fstpl  0xc1e0
    4df1:	c3                   	ret    

00004df2 <cmd_rt_drift_found>:
	if (!(args.rt_drift > -1)) {
    4df2:	d9 e8                	fld1   
{
    4df4:	55                   	push   %ebp
	if (!(args.rt_drift > -1)) {
    4df5:	d9 e0                	fchs   
{
    4df7:	89 e5                	mov    %esp,%ebp
    4df9:	83 ec 18             	sub    $0x18,%esp
	if (!(args.rt_drift > -1)) {
    4dfc:	dd 05 10 d5 00 00    	fldl   0xd510
    4e02:	df e9                	fucomip %st(1),%st
    4e04:	dd d8                	fstp   %st(0)
    4e06:	77 10                	ja     4e18 <cmd_rt_drift_found+0x26>
		posix_print_error_and_exit("The drift needs to be > -1. "
    4e08:	83 ec 0c             	sub    $0xc,%esp
    4e0b:	68 00 92 00 00       	push   $0x9200
    4e10:	e8 d0 0a 00 00       	call   58e5 <posix_print_error_and_exit>
    4e15:	83 c4 10             	add    $0x10,%esp
	args.rt_ratio = args.rt_drift + 1;
    4e18:	d9 e8                	fld1   
    4e1a:	dc 05 10 d5 00 00    	faddl  0xd510
    4e20:	dd 5d f0             	fstpl  -0x10(%ebp)
    4e23:	dd 45 f0             	fldl   -0x10(%ebp)
    4e26:	dd 15 18 d5 00 00    	fstl   0xd518
	clock_ratio = ratio;
    4e2c:	dd 1d e0 c1 00 00    	fstpl  0xc1e0
}
    4e32:	c9                   	leave  
    4e33:	c3                   	ret    

00004e34 <cmd_stop_at_found>:
{
    4e34:	55                   	push   %ebp
	if (args.stop_at < 0) {
    4e35:	d9 ee                	fldz   
{
    4e37:	89 e5                	mov    %esp,%ebp
    4e39:	53                   	push   %ebx
    4e3a:	83 ec 14             	sub    $0x14,%esp
    4e3d:	8b 45 08             	mov    0x8(%ebp),%eax
	if (args.stop_at < 0) {
    4e40:	dd 05 00 d5 00 00    	fldl   0xd500
    4e46:	d9 c9                	fxch   %st(1)
    4e48:	df e9                	fucomip %st(1),%st
    4e4a:	dd d8                	fstp   %st(0)
    4e4c:	76 10                	jbe    4e5e <cmd_stop_at_found+0x2a>
		posix_print_error_and_exit("Error: stop-at must be positive "
    4e4e:	52                   	push   %edx
    4e4f:	52                   	push   %edx
    4e50:	50                   	push   %eax
    4e51:	68 3d 92 00 00       	push   $0x923d
    4e56:	e8 8a 0a 00 00       	call   58e5 <posix_print_error_and_exit>
    4e5b:	83 c4 10             	add    $0x10,%esp
	hwm_set_end_of_time(args.stop_at*1e6);
    4e5e:	d9 05 c0 8a 00 00    	flds   0x8ac0
    4e64:	dc 0d 00 d5 00 00    	fmull  0xd500
    4e6a:	d9 05 c4 8a 00 00    	flds   0x8ac4
    4e70:	d9 c9                	fxch   %st(1)
    4e72:	db e9                	fucomi %st(1),%st
    4e74:	73 21                	jae    4e97 <cmd_stop_at_found+0x63>
    4e76:	dd d9                	fstp   %st(1)
    4e78:	d9 7d f6             	fnstcw -0xa(%ebp)
    4e7b:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
    4e7f:	80 cc 0c             	or     $0xc,%ah
    4e82:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    4e86:	d9 6d f4             	fldcw  -0xc(%ebp)
    4e89:	df 7d e8             	fistpll -0x18(%ebp)
    4e8c:	d9 6d f6             	fldcw  -0xa(%ebp)
    4e8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4e92:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4e95:	eb 27                	jmp    4ebe <cmd_stop_at_found+0x8a>
    4e97:	d9 7d f6             	fnstcw -0xa(%ebp)
    4e9a:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
    4e9e:	de e1                	fsubp  %st,%st(1)
    4ea0:	80 cc 0c             	or     $0xc,%ah
    4ea3:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
    4ea7:	d9 6d f4             	fldcw  -0xc(%ebp)
    4eaa:	df 7d e8             	fistpll -0x18(%ebp)
    4ead:	d9 6d f6             	fldcw  -0xa(%ebp)
    4eb0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4eb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4eb6:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
    4ebc:	89 ca                	mov    %ecx,%edx
    4ebe:	89 45 08             	mov    %eax,0x8(%ebp)
    4ec1:	89 55 0c             	mov    %edx,0xc(%ebp)
}
    4ec4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4ec7:	c9                   	leave  
	hwm_set_end_of_time(args.stop_at*1e6);
    4ec8:	e9 f9 fd ff ff       	jmp    4cc6 <hwm_set_end_of_time>

00004ecd <get_host_us_time>:
{
    4ecd:	55                   	push   %ebp
    4ece:	89 e5                	mov    %esp,%ebp
    4ed0:	53                   	push   %ebx
    4ed1:	83 ec 3c             	sub    $0x3c,%esp
    4ed4:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    4eda:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4edd:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    4edf:	8d 45 ec             	lea    -0x14(%ebp),%eax
    4ee2:	50                   	push   %eax
    4ee3:	6a 04                	push   $0x4
    4ee5:	e8 fc ff ff ff       	call   4ee6 <get_host_us_time+0x19>
	return (u64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    4eea:	8b 45 ec             	mov    -0x14(%ebp),%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
    4eed:	83 c4 10             	add    $0x10,%esp
	return (u64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    4ef0:	99                   	cltd   
    4ef1:	89 45 c8             	mov    %eax,-0x38(%ebp)
    4ef4:	89 55 cc             	mov    %edx,-0x34(%ebp)
    4ef7:	85 d2                	test   %edx,%edx
    4ef9:	df 6d c8             	fildll -0x38(%ebp)
    4efc:	79 06                	jns    4f04 <get_host_us_time+0x37>
    4efe:	d8 05 bc 8a 00 00    	fadds  0x8abc
    4f04:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f07:	dd 5d e0             	fstpl  -0x20(%ebp)
    4f0a:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    4f0f:	dd 45 e0             	fldl   -0x20(%ebp)
    4f12:	99                   	cltd   
    4f13:	f7 f9                	idiv   %ecx
    4f15:	d9 05 c0 8a 00 00    	flds   0x8ac0
    4f1b:	de c9                	fmulp  %st,%st(1)
    4f1d:	89 45 c8             	mov    %eax,-0x38(%ebp)
    4f20:	da 45 c8             	fiaddl -0x38(%ebp)
    4f23:	d9 05 c4 8a 00 00    	flds   0x8ac4
    4f29:	d9 c9                	fxch   %st(1)
    4f2b:	db e9                	fucomi %st(1),%st
    4f2d:	73 21                	jae    4f50 <get_host_us_time+0x83>
    4f2f:	dd d9                	fstp   %st(1)
    4f31:	d9 7d de             	fnstcw -0x22(%ebp)
    4f34:	66 8b 45 de          	mov    -0x22(%ebp),%ax
    4f38:	80 cc 0c             	or     $0xc,%ah
    4f3b:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
    4f3f:	d9 6d dc             	fldcw  -0x24(%ebp)
    4f42:	df 7d d0             	fistpll -0x30(%ebp)
    4f45:	d9 6d de             	fldcw  -0x22(%ebp)
    4f48:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4f4b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    4f4e:	eb 27                	jmp    4f77 <get_host_us_time+0xaa>
    4f50:	d9 7d de             	fnstcw -0x22(%ebp)
    4f53:	66 8b 45 de          	mov    -0x22(%ebp),%ax
    4f57:	de e1                	fsubp  %st,%st(1)
    4f59:	80 cc 0c             	or     $0xc,%ah
    4f5c:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
    4f60:	d9 6d dc             	fldcw  -0x24(%ebp)
    4f63:	df 7d d0             	fistpll -0x30(%ebp)
    4f66:	d9 6d de             	fldcw  -0x22(%ebp)
    4f69:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    4f6c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4f6f:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
    4f75:	89 ca                	mov    %ecx,%edx
}
    4f77:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    4f7a:	65 33 1d 14 00 00 00 	xor    %gs:0x14,%ebx
    4f81:	74 05                	je     4f88 <get_host_us_time+0xbb>
    4f83:	e8 fc ff ff ff       	call   4f84 <get_host_us_time+0xb7>
    4f88:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4f8b:	c9                   	leave  
    4f8c:	c3                   	ret    

00004f8d <hwtimer_init>:
{
    4f8d:	55                   	push   %ebp
    4f8e:	89 e5                	mov    %esp,%ebp
    4f90:	53                   	push   %ebx
    4f91:	83 ec 34             	sub    $0x34,%esp
	silent_ticks = 0;
    4f94:	c7 05 b8 d9 00 00 00 	movl   $0x0,0xd9b8
    4f9b:	00 00 00 
    4f9e:	c7 05 bc d9 00 00 00 	movl   $0x0,0xd9bc
    4fa5:	00 00 00 
{
    4fa8:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    4fae:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4fb1:	31 c0                	xor    %eax,%eax
	hw_timer_tick_timer = NEVER;
    4fb3:	c7 05 d0 d9 00 00 ff 	movl   $0xffffffff,0xd9d0
    4fba:	ff ff ff 
    4fbd:	c7 05 d4 d9 00 00 ff 	movl   $0xffffffff,0xd9d4
    4fc4:	ff ff ff 
	hw_timer_awake_timer = NEVER;
    4fc7:	c7 05 c8 d9 00 00 ff 	movl   $0xffffffff,0xd9c8
    4fce:	ff ff ff 
    4fd1:	c7 05 cc d9 00 00 ff 	movl   $0xffffffff,0xd9cc
    4fd8:	ff ff ff 
	hwtimer_update_timer();
    4fdb:	e8 38 fd ff ff       	call   4d18 <hwtimer_update_timer>
	if (real_time_mode) {
    4fe0:	80 3d a0 da 00 00 00 	cmpb   $0x0,0xdaa0
    4fe7:	74 24                	je     500d <hwtimer_init+0x80>
		boot_time = get_host_us_time();
    4fe9:	e8 df fe ff ff       	call   4ecd <get_host_us_time>
		last_radj_stime = 0U;
    4fee:	c7 05 a0 d9 00 00 00 	movl   $0x0,0xd9a0
    4ff5:	00 00 00 
		last_radj_rtime = boot_time;
    4ff8:	a3 a8 d9 00 00       	mov    %eax,0xd9a8
    4ffd:	89 15 ac d9 00 00    	mov    %edx,0xd9ac
		last_radj_stime = 0U;
    5003:	c7 05 a4 d9 00 00 00 	movl   $0x0,0xd9a4
    500a:	00 00 00 
	if (!reset_rtc) {
    500d:	80 3d 9f da 00 00 00 	cmpb   $0x0,0xda9f
    5014:	0f 85 a6 00 00 00    	jne    50c0 <hwtimer_init+0x133>
		clock_gettime(CLOCK_REALTIME, &tv);
    501a:	50                   	push   %eax
    501b:	50                   	push   %eax
    501c:	8d 45 ec             	lea    -0x14(%ebp),%eax
    501f:	50                   	push   %eax
    5020:	6a 00                	push   $0x0
    5022:	e8 fc ff ff ff       	call   5023 <hwtimer_init+0x96>
		realhosttime = (u64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    5027:	8b 45 ec             	mov    -0x14(%ebp),%eax
		clock_gettime(CLOCK_REALTIME, &tv);
    502a:	83 c4 10             	add    $0x10,%esp
		realhosttime = (u64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
    502d:	99                   	cltd   
    502e:	89 45 c8             	mov    %eax,-0x38(%ebp)
    5031:	89 55 cc             	mov    %edx,-0x34(%ebp)
    5034:	85 d2                	test   %edx,%edx
    5036:	df 6d c8             	fildll -0x38(%ebp)
    5039:	79 06                	jns    5041 <hwtimer_init+0xb4>
    503b:	d8 05 bc 8a 00 00    	fadds  0x8abc
    5041:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5044:	dd 5d e0             	fstpl  -0x20(%ebp)
    5047:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
    504c:	dd 45 e0             	fldl   -0x20(%ebp)
    504f:	99                   	cltd   
    5050:	f7 f9                	idiv   %ecx
    5052:	d9 05 c0 8a 00 00    	flds   0x8ac0
    5058:	de c9                	fmulp  %st,%st(1)
    505a:	89 45 c8             	mov    %eax,-0x38(%ebp)
    505d:	da 45 c8             	fiaddl -0x38(%ebp)
    5060:	d9 05 c4 8a 00 00    	flds   0x8ac4
    5066:	d9 c9                	fxch   %st(1)
    5068:	db e9                	fucomi %st(1),%st
    506a:	73 21                	jae    508d <hwtimer_init+0x100>
    506c:	dd d9                	fstp   %st(1)
    506e:	d9 7d de             	fnstcw -0x22(%ebp)
    5071:	66 8b 45 de          	mov    -0x22(%ebp),%ax
    5075:	80 cc 0c             	or     $0xc,%ah
    5078:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
    507c:	d9 6d dc             	fldcw  -0x24(%ebp)
    507f:	df 7d d0             	fistpll -0x30(%ebp)
    5082:	d9 6d de             	fldcw  -0x22(%ebp)
    5085:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5088:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    508b:	eb 27                	jmp    50b4 <hwtimer_init+0x127>
    508d:	d9 7d de             	fnstcw -0x22(%ebp)
    5090:	66 8b 45 de          	mov    -0x22(%ebp),%ax
    5094:	de e1                	fsubp  %st,%st(1)
    5096:	80 cc 0c             	or     $0xc,%ah
    5099:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
    509d:	d9 6d dc             	fldcw  -0x24(%ebp)
    50a0:	df 7d d0             	fistpll -0x30(%ebp)
    50a3:	d9 6d de             	fldcw  -0x22(%ebp)
    50a6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    50a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
    50ac:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
    50b2:	89 ca                	mov    %ecx,%edx
		rtc_offset += realhosttime;
    50b4:	01 05 b0 d9 00 00    	add    %eax,0xd9b0
    50ba:	11 15 b4 d9 00 00    	adc    %edx,0xd9b4
}
    50c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    50c3:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    50ca:	74 05                	je     50d1 <hwtimer_init+0x144>
    50cc:	e8 fc ff ff ff       	call   50cd <hwtimer_init+0x140>
    50d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    50d4:	c9                   	leave  
    50d5:	c3                   	ret    

000050d6 <hwtimer_cleanup>:
{
    50d6:	55                   	push   %ebp
    50d7:	89 e5                	mov    %esp,%ebp
}
    50d9:	5d                   	pop    %ebp
    50da:	c3                   	ret    

000050db <hwtimer_enable>:
{
    50db:	55                   	push   %ebp
    50dc:	89 e5                	mov    %esp,%ebp
    50de:	83 ec 08             	sub    $0x8,%esp
	tick_p = period;
    50e1:	8b 45 08             	mov    0x8(%ebp),%eax
    50e4:	8b 55 0c             	mov    0xc(%ebp),%edx
    50e7:	a3 c0 d9 00 00       	mov    %eax,0xd9c0
    50ec:	89 15 c4 d9 00 00    	mov    %edx,0xd9c4
	hw_timer_tick_timer = hwm_get_time() + tick_p;
    50f2:	e8 e5 fb ff ff       	call   4cdc <hwm_get_time>
    50f7:	03 05 c0 d9 00 00    	add    0xd9c0,%eax
    50fd:	13 15 c4 d9 00 00    	adc    0xd9c4,%edx
    5103:	a3 d0 d9 00 00       	mov    %eax,0xd9d0
    5108:	89 15 d4 d9 00 00    	mov    %edx,0xd9d4
	hwtimer_update_timer();
    510e:	e8 05 fc ff ff       	call   4d18 <hwtimer_update_timer>
}
    5113:	c9                   	leave  
	hwm_find_next_timer();
    5114:	e9 78 fa ff ff       	jmp    4b91 <hwm_find_next_timer>

00005119 <hwtimer_timer_reached>:
{
    5119:	55                   	push   %ebp
    511a:	89 e5                	mov    %esp,%ebp
    511c:	57                   	push   %edi
    511d:	56                   	push   %esi
    511e:	83 ec 40             	sub    $0x40,%esp
	u64_t Now = hw_timer_timer;
    5121:	8b 3d dc d9 00 00    	mov    0xd9dc,%edi
    5127:	8b 35 d8 d9 00 00    	mov    0xd9d8,%esi
{
    512d:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    5133:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5136:	31 c0                	xor    %eax,%eax
	if (hw_timer_awake_timer == Now) {
    5138:	39 3d cc d9 00 00    	cmp    %edi,0xd9cc
    513e:	75 31                	jne    5171 <hwtimer_timer_reached+0x58>
    5140:	39 35 c8 d9 00 00    	cmp    %esi,0xd9c8
    5146:	75 29                	jne    5171 <hwtimer_timer_reached+0x58>
	hw_timer_awake_timer = NEVER;
    5148:	c7 05 c8 d9 00 00 ff 	movl   $0xffffffff,0xd9c8
    514f:	ff ff ff 
    5152:	c7 05 cc d9 00 00 ff 	movl   $0xffffffff,0xd9cc
    5159:	ff ff ff 
	hwtimer_update_timer();
    515c:	e8 b7 fb ff ff       	call   4d18 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
    5161:	83 ec 0c             	sub    $0xc,%esp
    5164:	68 ff ff 00 00       	push   $0xffff
    5169:	e8 84 05 00 00       	call   56f2 <hw_irq_ctrl_set_irq>
    516e:	83 c4 10             	add    $0x10,%esp
	if (hw_timer_tick_timer == Now) {
    5171:	8b 15 d4 d9 00 00    	mov    0xd9d4,%edx
    5177:	a1 d0 d9 00 00       	mov    0xd9d0,%eax
    517c:	39 fa                	cmp    %edi,%edx
    517e:	0f 85 78 01 00 00    	jne    52fc <hwtimer_timer_reached+0x1e3>
    5184:	39 f0                	cmp    %esi,%eax
    5186:	0f 85 70 01 00 00    	jne    52fc <hwtimer_timer_reached+0x1e3>
	if (real_time_mode) {
    518c:	80 3d a0 da 00 00 00 	cmpb   $0x0,0xdaa0
    5193:	0f 84 10 01 00 00    	je     52a9 <hwtimer_timer_reached+0x190>
		u64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
    5199:	2b 05 a0 d9 00 00    	sub    0xd9a0,%eax
    519f:	1b 15 a4 d9 00 00    	sbb    0xd9a4,%edx
				    / clock_ratio
    51a5:	89 45 b8             	mov    %eax,-0x48(%ebp)
    51a8:	89 55 bc             	mov    %edx,-0x44(%ebp)
    51ab:	85 d2                	test   %edx,%edx
    51ad:	df 6d b8             	fildll -0x48(%ebp)
    51b0:	79 06                	jns    51b8 <hwtimer_timer_reached+0x9f>
    51b2:	d8 05 bc 8a 00 00    	fadds  0x8abc
    51b8:	dd 5d d0             	fstpl  -0x30(%ebp)
				    + last_radj_rtime;
    51bb:	83 3d ac d9 00 00 00 	cmpl   $0x0,0xd9ac
				    / clock_ratio
    51c2:	dd 45 d0             	fldl   -0x30(%ebp)
    51c5:	dc 35 e0 c1 00 00    	fdivl  0xc1e0
				    + last_radj_rtime;
    51cb:	df 2d a8 d9 00 00    	fildll 0xd9a8
    51d1:	79 06                	jns    51d9 <hwtimer_timer_reached+0xc0>
    51d3:	d8 05 bc 8a 00 00    	fadds  0x8abc
    51d9:	dd 5d d0             	fstpl  -0x30(%ebp)
    51dc:	dd 45 d0             	fldl   -0x30(%ebp)
    51df:	de c1                	faddp  %st,%st(1)
		u64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
    51e1:	d9 05 c4 8a 00 00    	flds   0x8ac4
    51e7:	d9 c9                	fxch   %st(1)
    51e9:	db e9                	fucomi %st(1),%st
    51eb:	73 21                	jae    520e <hwtimer_timer_reached+0xf5>
    51ed:	dd d9                	fstp   %st(1)
    51ef:	d9 7d ce             	fnstcw -0x32(%ebp)
    51f2:	66 8b 45 ce          	mov    -0x32(%ebp),%ax
    51f6:	80 cc 0c             	or     $0xc,%ah
    51f9:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
    51fd:	d9 6d cc             	fldcw  -0x34(%ebp)
    5200:	df 7d c0             	fistpll -0x40(%ebp)
    5203:	d9 6d ce             	fldcw  -0x32(%ebp)
    5206:	8b 75 c0             	mov    -0x40(%ebp),%esi
    5209:	8b 7d c4             	mov    -0x3c(%ebp),%edi
    520c:	eb 27                	jmp    5235 <hwtimer_timer_reached+0x11c>
    520e:	d9 7d ce             	fnstcw -0x32(%ebp)
    5211:	66 8b 45 ce          	mov    -0x32(%ebp),%ax
    5215:	de e1                	fsubp  %st,%st(1)
    5217:	80 cc 0c             	or     $0xc,%ah
    521a:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
    521e:	d9 6d cc             	fldcw  -0x34(%ebp)
    5221:	df 7d c0             	fistpll -0x40(%ebp)
    5224:	d9 6d ce             	fldcw  -0x32(%ebp)
    5227:	8b 7d c4             	mov    -0x3c(%ebp),%edi
    522a:	8b 75 c0             	mov    -0x40(%ebp),%esi
    522d:	8d 87 00 00 00 80    	lea    -0x80000000(%edi),%eax
    5233:	89 c7                	mov    %eax,%edi
		u64_t real_time = get_host_us_time();
    5235:	e8 93 fc ff ff       	call   4ecd <get_host_us_time>
		s64_t diff = expected_rt - real_time;
    523a:	29 c6                	sub    %eax,%esi
    523c:	19 d7                	sbb    %edx,%edi
		if (diff > 0) { /* we need to slow down */
    523e:	83 ff 00             	cmp    $0x0,%edi
    5241:	7c 66                	jl     52a9 <hwtimer_timer_reached+0x190>
    5243:	7f 05                	jg     524a <hwtimer_timer_reached+0x131>
    5245:	83 fe 00             	cmp    $0x0,%esi
    5248:	76 5f                	jbe    52a9 <hwtimer_timer_reached+0x190>
			requested_time.tv_sec  = diff / 1e6;
    524a:	89 75 b8             	mov    %esi,-0x48(%ebp)
    524d:	89 7d bc             	mov    %edi,-0x44(%ebp)
    5250:	d9 7d ce             	fnstcw -0x32(%ebp)
    5253:	df 6d b8             	fildll -0x48(%ebp)
    5256:	66 8b 45 ce          	mov    -0x32(%ebp),%ax
    525a:	80 cc 0c             	or     $0xc,%ah
    525d:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
    5261:	dd 5d d0             	fstpl  -0x30(%ebp)
    5264:	dd 45 d0             	fldl   -0x30(%ebp)
    5267:	d9 05 c0 8a 00 00    	flds   0x8ac0
    526d:	d9 c1                	fld    %st(1)
    526f:	d8 f1                	fdiv   %st(1),%st
    5271:	d9 6d cc             	fldcw  -0x34(%ebp)
    5274:	db 5d c8             	fistpl -0x38(%ebp)
    5277:	d9 6d ce             	fldcw  -0x32(%ebp)
    527a:	8b 45 c8             	mov    -0x38(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
    527d:	89 45 b8             	mov    %eax,-0x48(%ebp)
			requested_time.tv_sec  = diff / 1e6;
    5280:	89 45 e4             	mov    %eax,-0x1c(%ebp)
						 requested_time.tv_sec*1e6)*1e3;
    5283:	da 4d b8             	fimull -0x48(%ebp)
			nanosleep(&requested_time, &remaining);
    5286:	50                   	push   %eax
    5287:	50                   	push   %eax
    5288:	8d 45 ec             	lea    -0x14(%ebp),%eax
    528b:	50                   	push   %eax
    528c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    528f:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
    5290:	de e9                	fsubrp %st,%st(1)
						 requested_time.tv_sec*1e6)*1e3;
    5292:	d8 0d c8 8a 00 00    	fmuls  0x8ac8
			requested_time.tv_nsec = (diff -
    5298:	d9 6d cc             	fldcw  -0x34(%ebp)
    529b:	db 5d e8             	fistpl -0x18(%ebp)
    529e:	d9 6d ce             	fldcw  -0x32(%ebp)
			nanosleep(&requested_time, &remaining);
    52a1:	e8 fc ff ff ff       	call   52a2 <hwtimer_timer_reached+0x189>
    52a6:	83 c4 10             	add    $0x10,%esp
	hw_timer_tick_timer += tick_p;
    52a9:	a1 c0 d9 00 00       	mov    0xd9c0,%eax
    52ae:	01 05 d0 d9 00 00    	add    %eax,0xd9d0
    52b4:	8b 15 c4 d9 00 00    	mov    0xd9c4,%edx
    52ba:	11 15 d4 d9 00 00    	adc    %edx,0xd9d4
	hwtimer_update_timer();
    52c0:	e8 53 fa ff ff       	call   4d18 <hwtimer_update_timer>
	if (silent_ticks > 0) {
    52c5:	8b 15 bc d9 00 00    	mov    0xd9bc,%edx
    52cb:	a1 b8 d9 00 00       	mov    0xd9b8,%eax
    52d0:	83 fa 00             	cmp    $0x0,%edx
    52d3:	7c 1a                	jl     52ef <hwtimer_timer_reached+0x1d6>
    52d5:	7f 05                	jg     52dc <hwtimer_timer_reached+0x1c3>
    52d7:	83 f8 00             	cmp    $0x0,%eax
    52da:	76 13                	jbe    52ef <hwtimer_timer_reached+0x1d6>
		silent_ticks -= 1;
    52dc:	83 c0 ff             	add    $0xffffffff,%eax
    52df:	83 d2 ff             	adc    $0xffffffff,%edx
    52e2:	a3 b8 d9 00 00       	mov    %eax,0xd9b8
    52e7:	89 15 bc d9 00 00    	mov    %edx,0xd9bc
    52ed:	eb 0d                	jmp    52fc <hwtimer_timer_reached+0x1e3>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
    52ef:	83 ec 0c             	sub    $0xc,%esp
    52f2:	6a 00                	push   $0x0
    52f4:	e8 f9 03 00 00       	call   56f2 <hw_irq_ctrl_set_irq>
    52f9:	83 c4 10             	add    $0x10,%esp
}
    52fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    52ff:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    5306:	74 05                	je     530d <hwtimer_timer_reached+0x1f4>
    5308:	e8 fc ff ff ff       	call   5309 <hwtimer_timer_reached+0x1f0>
    530d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5310:	5e                   	pop    %esi
    5311:	5f                   	pop    %edi
    5312:	5d                   	pop    %ebp
    5313:	c3                   	ret    

00005314 <hwtimer_set_silent_ticks>:
{
    5314:	55                   	push   %ebp
    5315:	89 e5                	mov    %esp,%ebp
	silent_ticks = sys_ticks;
    5317:	8b 45 08             	mov    0x8(%ebp),%eax
    531a:	8b 55 0c             	mov    0xc(%ebp),%edx
}
    531d:	5d                   	pop    %ebp
	silent_ticks = sys_ticks;
    531e:	a3 b8 d9 00 00       	mov    %eax,0xd9b8
    5323:	89 15 bc d9 00 00    	mov    %edx,0xd9bc
}
    5329:	c3                   	ret    

0000532a <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
    532a:	55                   	push   %ebp
    532b:	89 e5                	mov    %esp,%ebp
    532d:	57                   	push   %edi
    532e:	56                   	push   %esi
    532f:	53                   	push   %ebx
    5330:	83 ec 0c             	sub    $0xc,%esp
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
    5333:	e8 3b 03 00 00       	call   5673 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
    5338:	85 c0                	test   %eax,%eax
    533a:	0f 85 ef 00 00 00    	jne    542f <posix_irq_handler+0x105>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.nested == 0) {
    5340:	a1 c0 d8 00 00       	mov    0xd8c0,%eax
    5345:	85 c0                	test   %eax,%eax
    5347:	75 0a                	jne    5353 <posix_irq_handler+0x29>
		may_swap = 0;
    5349:	c7 05 44 da 00 00 00 	movl   $0x0,0xda44
    5350:	00 00 00 
	}

	_kernel.nested++;
    5353:	40                   	inc    %eax
    5354:	a3 c0 d8 00 00       	mov    %eax,0xd8c0

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
    5359:	e8 87 02 00 00       	call   55e5 <hw_irq_ctrl_get_highest_prio_irq>
    535e:	83 f8 ff             	cmp    $0xffffffff,%eax
    5361:	89 c3                	mov    %eax,%ebx
    5363:	0f 84 91 00 00 00    	je     53fa <posix_irq_handler+0xd0>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    5369:	e8 4e 02 00 00       	call   55bc <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    536e:	83 ec 0c             	sub    $0xc,%esp
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
    5371:	89 c6                	mov    %eax,%esi
		int last_running_irq = currently_running_irq;
    5373:	8b 3d fc c1 00 00    	mov    0xc1fc,%edi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
    5379:	53                   	push   %ebx
    537a:	e8 58 02 00 00       	call   55d7 <hw_irq_ctrl_get_prio>
    537f:	0f b6 c0             	movzbl %al,%eax
    5382:	89 04 24             	mov    %eax,(%esp)
    5385:	e8 25 02 00 00       	call   55af <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
    538a:	89 1c 24             	mov    %ebx,(%esp)
    538d:	e8 23 03 00 00       	call   56b5 <hw_irq_ctrl_clear_irq>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    5392:	89 d8                	mov    %ebx,%eax
		hw_irq_ctrl_clear_irq(irq_nbr);
    5394:	83 c4 10             	add    $0x10,%esp

		currently_running_irq = irq_nbr;
    5397:	89 1d fc c1 00 00    	mov    %ebx,0xc1fc
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
    539d:	c1 e0 04             	shl    $0x4,%eax
    53a0:	05 20 d5 00 00       	add    $0xd520,%eax
    53a5:	8b 50 08             	mov    0x8(%eax),%edx
    53a8:	85 d2                	test   %edx,%edx
    53aa:	75 12                	jne    53be <posix_irq_handler+0x94>
		posix_print_error_and_exit("Received irq %i without a "
    53ac:	50                   	push   %eax
    53ad:	50                   	push   %eax
    53ae:	53                   	push   %ebx
    53af:	68 3c 96 00 00       	push   $0x963c
    53b4:	e8 2c 05 00 00       	call   58e5 <posix_print_error_and_exit>
    53b9:	83 c4 10             	add    $0x10,%esp
    53bc:	eb 25                	jmp    53e3 <posix_irq_handler+0xb9>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
    53be:	f6 40 04 01          	testb  $0x1,0x4(%eax)
    53c2:	74 0a                	je     53ce <posix_irq_handler+0xa4>
			*may_swap |= ((direct_irq_f_ptr)
    53c4:	ff d2                	call   *%edx
    53c6:	09 05 44 da 00 00    	or     %eax,0xda44
    53cc:	eb 15                	jmp    53e3 <posix_irq_handler+0xb9>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
    53ce:	83 ec 0c             	sub    $0xc,%esp
    53d1:	ff 70 0c             	pushl  0xc(%eax)
    53d4:	ff d2                	call   *%edx
    53d6:	83 c4 10             	add    $0x10,%esp
			*may_swap = 1;
    53d9:	c7 05 44 da 00 00 01 	movl   $0x1,0xda44
    53e0:	00 00 00 
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    53e3:	83 ec 0c             	sub    $0xc,%esp
		currently_running_irq = last_running_irq;
    53e6:	89 3d fc c1 00 00    	mov    %edi,0xc1fc
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
    53ec:	56                   	push   %esi
    53ed:	e8 bd 01 00 00       	call   55af <hw_irq_ctrl_set_cur_prio>
    53f2:	83 c4 10             	add    $0x10,%esp
    53f5:	e9 5f ff ff ff       	jmp    5359 <posix_irq_handler+0x2f>
	}

	_kernel.nested--;
    53fa:	ff 0d c0 d8 00 00    	decl   0xd8c0
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
    5400:	83 3d 44 da 00 00 00 	cmpl   $0x0,0xda44
    5407:	74 26                	je     542f <posix_irq_handler+0x105>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
    5409:	e8 ae 01 00 00       	call   55bc <hw_irq_ctrl_get_cur_prio>
    540e:	3d 00 01 00 00       	cmp    $0x100,%eax
    5413:	75 1a                	jne    542f <posix_irq_handler+0x105>
		&& (_kernel.ready_q.cache != _current)) {
    5415:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
    541a:	39 05 e0 d8 00 00    	cmp    %eax,0xd8e0
    5420:	74 0d                	je     542f <posix_irq_handler+0x105>
    5422:	83 ec 0c             	sub    $0xc,%esp
    5425:	6a 00                	push   $0x0
    5427:	e8 bc f2 ff ff       	call   46e8 <arch_swap>
    542c:	83 c4 10             	add    $0x10,%esp

		(void)z_swap_irqlock(irq_lock);
	}
}
    542f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5432:	5b                   	pop    %ebx
    5433:	5e                   	pop    %esi
    5434:	5f                   	pop    %edi
    5435:	5d                   	pop    %ebp
    5436:	c3                   	ret    

00005437 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
    5437:	55                   	push   %ebp
    5438:	89 e5                	mov    %esp,%ebp
    543a:	83 ec 08             	sub    $0x8,%esp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
    543d:	e8 a3 01 00 00       	call   55e5 <hw_irq_ctrl_get_highest_prio_irq>
    5442:	40                   	inc    %eax
    5443:	74 23                	je     5468 <posix_irq_handler_im_from_sw+0x31>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
    5445:	e8 c6 f4 ff ff       	call   4910 <posix_is_cpu_running>
    544a:	85 c0                	test   %eax,%eax
    544c:	75 14                	jne    5462 <posix_irq_handler_im_from_sw+0x2b>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
    544e:	50                   	push   %eax
    544f:	50                   	push   %eax
    5450:	68 d0 8a 00 00       	push   $0x8ad0
    5455:	68 6a 96 00 00       	push   $0x966a
    545a:	e8 86 04 00 00       	call   58e5 <posix_print_error_and_exit>
    545f:	83 c4 10             	add    $0x10,%esp
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
    5462:	c9                   	leave  
		posix_irq_handler();
    5463:	e9 c2 fe ff ff       	jmp    532a <posix_irq_handler>
}
    5468:	c9                   	leave  
    5469:	c3                   	ret    

0000546a <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
    546a:	55                   	push   %ebp
    546b:	89 e5                	mov    %esp,%ebp
    546d:	83 ec 14             	sub    $0x14,%esp
	return hw_irq_ctrl_change_lock(true);
    5470:	6a 01                	push   $0x1
    5472:	e8 08 02 00 00       	call   567f <hw_irq_ctrl_change_lock>
    5477:	83 c4 10             	add    $0x10,%esp
}
    547a:	c9                   	leave  
    547b:	c3                   	ret    

0000547c <posix_irq_unlock>:
 *
 * @return N/A
 *
 */
void posix_irq_unlock(unsigned int key)
{
    547c:	55                   	push   %ebp
    547d:	89 e5                	mov    %esp,%ebp
	hw_irq_ctrl_change_lock(key);
}
    547f:	5d                   	pop    %ebp
	hw_irq_ctrl_change_lock(key);
    5480:	e9 fa 01 00 00       	jmp    567f <hw_irq_ctrl_change_lock>

00005485 <posix_irq_full_unlock>:

void posix_irq_full_unlock(void)
{
    5485:	55                   	push   %ebp
    5486:	89 e5                	mov    %esp,%ebp
    5488:	83 ec 14             	sub    $0x14,%esp
	hw_irq_ctrl_change_lock(false);
    548b:	6a 00                	push   $0x0
    548d:	e8 ed 01 00 00       	call   567f <hw_irq_ctrl_change_lock>
    5492:	83 c4 10             	add    $0x10,%esp
}
    5495:	c9                   	leave  
    5496:	c3                   	ret    

00005497 <posix_irq_enable>:

void posix_irq_enable(unsigned int irq)
{
    5497:	55                   	push   %ebp
    5498:	89 e5                	mov    %esp,%ebp
	hw_irq_ctrl_enable_irq(irq);
}
    549a:	5d                   	pop    %ebp
	hw_irq_ctrl_enable_irq(irq);
    549b:	e9 a9 02 00 00       	jmp    5749 <hw_irq_ctrl_enable_irq>

000054a0 <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(void *),
		void *isr_param_p)
{
    54a0:	55                   	push   %ebp
    54a1:	89 e5                	mov    %esp,%ebp
    54a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_vector_table[irq_p].irq   = irq_p;
    54a6:	89 ca                	mov    %ecx,%edx
    54a8:	c1 e2 04             	shl    $0x4,%edx
    54ab:	8d 82 20 d5 00 00    	lea    0xd520(%edx),%eax
    54b1:	89 8a 20 d5 00 00    	mov    %ecx,0xd520(%edx)
	irq_vector_table[irq_p].func  = isr_p;
    54b7:	8b 55 10             	mov    0x10(%ebp),%edx
    54ba:	89 50 08             	mov    %edx,0x8(%eax)
	irq_vector_table[irq_p].param = isr_param_p;
    54bd:	8b 55 14             	mov    0x14(%ebp),%edx
    54c0:	89 50 0c             	mov    %edx,0xc(%eax)
	irq_vector_table[irq_p].flags = flags;
    54c3:	8b 55 0c             	mov    0xc(%ebp),%edx
    54c6:	89 50 04             	mov    %edx,0x4(%eax)
}
    54c9:	5d                   	pop    %ebp
    54ca:	c3                   	ret    

000054cb <posix_irq_priority_set>:
 * Lower values take priority over higher values.
 *
 * @return N/A
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
    54cb:	55                   	push   %ebp
    54cc:	89 e5                	mov    %esp,%ebp
	hw_irq_ctrl_prio_set(irq, prio);
}
    54ce:	5d                   	pop    %ebp
	hw_irq_ctrl_prio_set(irq, prio);
    54cf:	e9 f2 00 00 00       	jmp    55c6 <hw_irq_ctrl_prio_set>

000054d4 <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
    54d4:	80 3d a2 da 00 00 00 	cmpb   $0x0,0xdaa2
{
    54db:	55                   	push   %ebp
    54dc:	89 e5                	mov    %esp,%ebp
	if ((irqs_locked == false) || (lock_ignore)) {
    54de:	74 09                	je     54e9 <irq_raising_from_hw_now+0x15>
    54e0:	80 3d a1 da 00 00 00 	cmpb   $0x0,0xdaa1
    54e7:	74 0d                	je     54f6 <irq_raising_from_hw_now+0x22>
		lock_ignore = false;
		posix_interrupt_raised();
	}
}
    54e9:	5d                   	pop    %ebp
		lock_ignore = false;
    54ea:	c6 05 a1 da 00 00 00 	movb   $0x0,0xdaa1
		posix_interrupt_raised();
    54f1:	e9 2a f4 ff ff       	jmp    4920 <posix_interrupt_raised>
}
    54f6:	5d                   	pop    %ebp
    54f7:	c3                   	ret    

000054f8 <hw_irq_ctrl_irq_raise_prefix>:
	if (irq < N_IRQS) {
    54f8:	83 f8 1f             	cmp    $0x1f,%eax
{
    54fb:	89 c1                	mov    %eax,%ecx
	if (irq < N_IRQS) {
    54fd:	77 4d                	ja     554c <hw_irq_ctrl_irq_raise_prefix+0x54>
{
    54ff:	55                   	push   %ebp
		if (irq_mask & (1 << irq)) {
    5500:	ba 01 00 00 00       	mov    $0x1,%edx
    5505:	d3 e2                	shl    %cl,%edx
{
    5507:	89 e5                	mov    %esp,%ebp
    5509:	57                   	push   %edi
		irq_premask |= ((u64_t)1<<irq);
    550a:	89 c7                	mov    %eax,%edi
    550c:	c1 ef 05             	shr    $0x5,%edi
{
    550f:	56                   	push   %esi
		if (irq_mask & (1 << irq)) {
    5510:	89 d0                	mov    %edx,%eax
		irq_premask |= ((u64_t)1<<irq);
    5512:	83 e7 01             	and    $0x1,%edi
    5515:	89 fe                	mov    %edi,%esi
    5517:	d3 e7                	shl    %cl,%edi
    5519:	09 3d ec d9 00 00    	or     %edi,0xd9ec
    551f:	83 f6 01             	xor    $0x1,%esi
    5522:	d3 e6                	shl    %cl,%esi
		if (irq_mask & (1 << irq)) {
    5524:	89 d1                	mov    %edx,%ecx
    5526:	99                   	cltd   
    5527:	23 0d e0 d9 00 00    	and    0xd9e0,%ecx
    552d:	a1 e4 d9 00 00       	mov    0xd9e4,%eax
		irq_premask |= ((u64_t)1<<irq);
    5532:	09 35 e8 d9 00 00    	or     %esi,0xd9e8
		if (irq_mask & (1 << irq)) {
    5538:	21 d0                	and    %edx,%eax
    553a:	09 c8                	or     %ecx,%eax
    553c:	74 1d                	je     555b <hw_irq_ctrl_irq_raise_prefix+0x63>
			irq_status |= ((u64_t)1<<irq);
    553e:	09 35 f0 d9 00 00    	or     %esi,0xd9f0
    5544:	09 3d f4 d9 00 00    	or     %edi,0xd9f4
    554a:	eb 0f                	jmp    555b <hw_irq_ctrl_irq_raise_prefix+0x63>
	} else if (irq == PHONY_HARD_IRQ) {
    554c:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5551:	75 0c                	jne    555f <hw_irq_ctrl_irq_raise_prefix+0x67>
		lock_ignore = true;
    5553:	c6 05 a1 da 00 00 01 	movb   $0x1,0xdaa1
}
    555a:	c3                   	ret    
    555b:	5e                   	pop    %esi
    555c:	5f                   	pop    %edi
    555d:	5d                   	pop    %ebp
    555e:	c3                   	ret    
    555f:	c3                   	ret    

00005560 <hw_irq_ctrl_init>:
{
    5560:	55                   	push   %ebp
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
    5561:	c7 05 e0 d9 00 00 00 	movl   $0x0,0xd9e0
    5568:	00 00 00 
	for (int i = 0 ; i < N_IRQS; i++) {
    556b:	31 c0                	xor    %eax,%eax
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
    556d:	c7 05 e4 d9 00 00 00 	movl   $0x0,0xd9e4
    5574:	00 00 00 
	irq_premask = 0U;
    5577:	c7 05 e8 d9 00 00 00 	movl   $0x0,0xd9e8
    557e:	00 00 00 
{
    5581:	89 e5                	mov    %esp,%ebp
	irq_premask = 0U;
    5583:	c7 05 ec d9 00 00 00 	movl   $0x0,0xd9ec
    558a:	00 00 00 
	irqs_locked = false;
    558d:	c6 05 a2 da 00 00 00 	movb   $0x0,0xdaa2
	lock_ignore = false;
    5594:	c6 05 a1 da 00 00 00 	movb   $0x0,0xdaa1
		irq_prio[i] = 255U;
    559b:	c6 80 20 d7 00 00 ff 	movb   $0xff,0xd720(%eax)
	for (int i = 0 ; i < N_IRQS; i++) {
    55a2:	40                   	inc    %eax
    55a3:	83 f8 20             	cmp    $0x20,%eax
    55a6:	75 f3                	jne    559b <hw_irq_ctrl_init+0x3b>
}
    55a8:	5d                   	pop    %ebp
    55a9:	c3                   	ret    

000055aa <hw_irq_ctrl_cleanup>:
{
    55aa:	55                   	push   %ebp
    55ab:	89 e5                	mov    %esp,%ebp
}
    55ad:	5d                   	pop    %ebp
    55ae:	c3                   	ret    

000055af <hw_irq_ctrl_set_cur_prio>:
{
    55af:	55                   	push   %ebp
    55b0:	89 e5                	mov    %esp,%ebp
	currently_running_prio = new;
    55b2:	8b 45 08             	mov    0x8(%ebp),%eax
}
    55b5:	5d                   	pop    %ebp
	currently_running_prio = new;
    55b6:	a3 00 c2 00 00       	mov    %eax,0xc200
}
    55bb:	c3                   	ret    

000055bc <hw_irq_ctrl_get_cur_prio>:
{
    55bc:	55                   	push   %ebp
}
    55bd:	a1 00 c2 00 00       	mov    0xc200,%eax
{
    55c2:	89 e5                	mov    %esp,%ebp
}
    55c4:	5d                   	pop    %ebp
    55c5:	c3                   	ret    

000055c6 <hw_irq_ctrl_prio_set>:
{
    55c6:	55                   	push   %ebp
    55c7:	89 e5                	mov    %esp,%ebp
	irq_prio[irq] = prio;
    55c9:	8b 45 08             	mov    0x8(%ebp),%eax
    55cc:	8b 55 0c             	mov    0xc(%ebp),%edx
}
    55cf:	5d                   	pop    %ebp
	irq_prio[irq] = prio;
    55d0:	88 90 20 d7 00 00    	mov    %dl,0xd720(%eax)
}
    55d6:	c3                   	ret    

000055d7 <hw_irq_ctrl_get_prio>:
{
    55d7:	55                   	push   %ebp
    55d8:	89 e5                	mov    %esp,%ebp
	return irq_prio[irq];
    55da:	8b 45 08             	mov    0x8(%ebp),%eax
}
    55dd:	5d                   	pop    %ebp
	return irq_prio[irq];
    55de:	8a 80 20 d7 00 00    	mov    0xd720(%eax),%al
}
    55e4:	c3                   	ret    

000055e5 <hw_irq_ctrl_get_highest_prio_irq>:
	if (irqs_locked) {
    55e5:	80 3d a2 da 00 00 00 	cmpb   $0x0,0xdaa2
    55ec:	75 79                	jne    5667 <hw_irq_ctrl_get_highest_prio_irq+0x82>
{
    55ee:	55                   	push   %ebp
    55ef:	89 e5                	mov    %esp,%ebp
    55f1:	57                   	push   %edi
    55f2:	56                   	push   %esi
    55f3:	53                   	push   %ebx
	int winner_prio = 256;
    55f4:	bb 00 01 00 00       	mov    $0x100,%ebx
{
    55f9:	83 ec 14             	sub    $0x14,%esp
	return irq_status;
    55fc:	a1 f4 d9 00 00       	mov    0xd9f4,%eax
    5601:	8b 15 f0 d9 00 00    	mov    0xd9f0,%edx
    5607:	89 45 e8             	mov    %eax,-0x18(%ebp)
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    560a:	a1 00 c2 00 00       	mov    0xc200,%eax
    560f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int winner = -1;
    5612:	83 c8 ff             	or     $0xffffffff,%eax
	while (irq_status != 0U) {
    5615:	8b 7d e8             	mov    -0x18(%ebp),%edi
    5618:	09 d7                	or     %edx,%edi
    561a:	74 4f                	je     566b <hw_irq_ctrl_get_highest_prio_irq+0x86>
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(u32_t op)
{
	return __builtin_ffs(op);
    561c:	0f bc ca             	bsf    %edx,%ecx
		int irq_nbr = find_lsb_set(irq_status) - 1;
    561f:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		irq_status &= ~((u64_t) 1 << irq_nbr);
    5624:	be 01 00 00 00       	mov    $0x1,%esi
		int irq_nbr = find_lsb_set(irq_status) - 1;
    5629:	0f 44 cf             	cmove  %edi,%ecx
		irq_status &= ~((u64_t) 1 << irq_nbr);
    562c:	31 ff                	xor    %edi,%edi
    562e:	0f a5 f7             	shld   %cl,%esi,%edi
    5631:	d3 e6                	shl    %cl,%esi
    5633:	f6 c1 20             	test   $0x20,%cl
    5636:	74 04                	je     563c <hw_irq_ctrl_get_highest_prio_irq+0x57>
    5638:	89 f7                	mov    %esi,%edi
    563a:	31 f6                	xor    %esi,%esi
    563c:	89 75 e0             	mov    %esi,-0x20(%ebp)
    563f:	8b 75 e0             	mov    -0x20(%ebp),%esi
    5642:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    5645:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    5648:	f7 d6                	not    %esi
    564a:	21 f2                	and    %esi,%edx
		if ((winner_prio > (int)irq_prio[irq_nbr])
    564c:	0f b6 b1 20 d7 00 00 	movzbl 0xd720(%ecx),%esi
		irq_status &= ~((u64_t) 1 << irq_nbr);
    5653:	f7 d7                	not    %edi
    5655:	21 7d e8             	and    %edi,-0x18(%ebp)
		if ((winner_prio > (int)irq_prio[irq_nbr])
    5658:	39 de                	cmp    %ebx,%esi
    565a:	7d b9                	jge    5615 <hw_irq_ctrl_get_highest_prio_irq+0x30>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
    565c:	3b 75 ec             	cmp    -0x14(%ebp),%esi
    565f:	0f 4c de             	cmovl  %esi,%ebx
    5662:	0f 4c c1             	cmovl  %ecx,%eax
    5665:	eb ae                	jmp    5615 <hw_irq_ctrl_get_highest_prio_irq+0x30>
    5667:	83 c8 ff             	or     $0xffffffff,%eax
}
    566a:	c3                   	ret    
    566b:	83 c4 14             	add    $0x14,%esp
    566e:	5b                   	pop    %ebx
    566f:	5e                   	pop    %esi
    5670:	5f                   	pop    %edi
    5671:	5d                   	pop    %ebp
    5672:	c3                   	ret    

00005673 <hw_irq_ctrl_get_current_lock>:
{
    5673:	55                   	push   %ebp
	return irqs_locked;
    5674:	0f b6 05 a2 da 00 00 	movzbl 0xdaa2,%eax
{
    567b:	89 e5                	mov    %esp,%ebp
}
    567d:	5d                   	pop    %ebp
    567e:	c3                   	ret    

0000567f <hw_irq_ctrl_change_lock>:
{
    567f:	55                   	push   %ebp
    5680:	89 e5                	mov    %esp,%ebp
    5682:	53                   	push   %ebx
    5683:	51                   	push   %ecx
    5684:	8b 4d 08             	mov    0x8(%ebp),%ecx
	u32_t previous_lock = irqs_locked;
    5687:	0f b6 1d a2 da 00 00 	movzbl 0xdaa2,%ebx
	irqs_locked = new_lock;
    568e:	85 c9                	test   %ecx,%ecx
    5690:	0f 95 05 a2 da 00 00 	setne  0xdaa2
	if ((previous_lock == true) && (new_lock == false)) {
    5697:	75 16                	jne    56af <hw_irq_ctrl_change_lock+0x30>
    5699:	84 db                	test   %bl,%bl
    569b:	74 12                	je     56af <hw_irq_ctrl_change_lock+0x30>
		if (irq_status != 0U) {
    569d:	a1 f4 d9 00 00       	mov    0xd9f4,%eax
    56a2:	0b 05 f0 d9 00 00    	or     0xd9f0,%eax
    56a8:	74 05                	je     56af <hw_irq_ctrl_change_lock+0x30>
			posix_irq_handler_im_from_sw();
    56aa:	e8 88 fd ff ff       	call   5437 <posix_irq_handler_im_from_sw>
}
    56af:	89 d8                	mov    %ebx,%eax
    56b1:	5a                   	pop    %edx
    56b2:	5b                   	pop    %ebx
    56b3:	5d                   	pop    %ebp
    56b4:	c3                   	ret    

000056b5 <hw_irq_ctrl_clear_irq>:
{
    56b5:	55                   	push   %ebp
    56b6:	89 e5                	mov    %esp,%ebp
    56b8:	57                   	push   %edi
    56b9:	56                   	push   %esi
	irq_status  &= ~((u64_t)1<<irq);
    56ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
    56bd:	89 cf                	mov    %ecx,%edi
    56bf:	c1 ef 05             	shr    $0x5,%edi
    56c2:	83 e7 01             	and    $0x1,%edi
    56c5:	89 fe                	mov    %edi,%esi
    56c7:	d3 e7                	shl    %cl,%edi
    56c9:	83 f6 01             	xor    $0x1,%esi
    56cc:	89 f8                	mov    %edi,%eax
    56ce:	d3 e6                	shl    %cl,%esi
    56d0:	f7 d0                	not    %eax
    56d2:	21 05 f4 d9 00 00    	and    %eax,0xd9f4
    56d8:	89 f2                	mov    %esi,%edx
	irq_premask &= ~((u64_t)1<<irq);
    56da:	21 05 ec d9 00 00    	and    %eax,0xd9ec
	irq_status  &= ~((u64_t)1<<irq);
    56e0:	f7 d2                	not    %edx
    56e2:	21 15 f0 d9 00 00    	and    %edx,0xd9f0
}
    56e8:	5e                   	pop    %esi
	irq_premask &= ~((u64_t)1<<irq);
    56e9:	21 15 e8 d9 00 00    	and    %edx,0xd9e8
}
    56ef:	5f                   	pop    %edi
    56f0:	5d                   	pop    %ebp
    56f1:	c3                   	ret    

000056f2 <hw_irq_ctrl_set_irq>:
{
    56f2:	55                   	push   %ebp
    56f3:	89 e5                	mov    %esp,%ebp
    56f5:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
    56f8:	8b 45 08             	mov    0x8(%ebp),%eax
    56fb:	e8 f8 fd ff ff       	call   54f8 <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
    5700:	80 3d a2 da 00 00 00 	cmpb   $0x0,0xdaa2
    5707:	74 09                	je     5712 <hw_irq_ctrl_set_irq+0x20>
    5709:	80 3d a1 da 00 00 00 	cmpb   $0x0,0xdaa1
    5710:	74 16                	je     5728 <hw_irq_ctrl_set_irq+0x36>
		irq_ctrl_timer = hwm_get_time();
    5712:	e8 c5 f5 ff ff       	call   4cdc <hwm_get_time>
    5717:	a3 e8 c1 00 00       	mov    %eax,0xc1e8
    571c:	89 15 ec c1 00 00    	mov    %edx,0xc1ec
}
    5722:	c9                   	leave  
		hwm_find_next_timer();
    5723:	e9 69 f4 ff ff       	jmp    4b91 <hwm_find_next_timer>
}
    5728:	c9                   	leave  
    5729:	c3                   	ret    

0000572a <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
    572a:	55                   	push   %ebp
    572b:	89 e5                	mov    %esp,%ebp
    572d:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
    5730:	8b 45 08             	mov    0x8(%ebp),%eax
    5733:	e8 c0 fd ff ff       	call   54f8 <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
    5738:	80 3d a2 da 00 00 00 	cmpb   $0x0,0xdaa2
    573f:	75 06                	jne    5747 <hw_irq_ctrl_raise_im_from_sw+0x1d>
		posix_irq_handler_im_from_sw();
	}
}
    5741:	c9                   	leave  
		posix_irq_handler_im_from_sw();
    5742:	e9 f0 fc ff ff       	jmp    5437 <posix_irq_handler_im_from_sw>
}
    5747:	c9                   	leave  
    5748:	c3                   	ret    

00005749 <hw_irq_ctrl_enable_irq>:
{
    5749:	55                   	push   %ebp
	irq_mask |= ((u64_t)1<<irq);
    574a:	31 c0                	xor    %eax,%eax
    574c:	31 d2                	xor    %edx,%edx
{
    574e:	89 e5                	mov    %esp,%ebp
    5750:	56                   	push   %esi
    5751:	53                   	push   %ebx
    5752:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_mask |= ((u64_t)1<<irq);
    5755:	f6 c1 20             	test   $0x20,%cl
    5758:	0f 94 c0             	sete   %al
    575b:	0f 95 c2             	setne  %dl
    575e:	d3 e2                	shl    %cl,%edx
    5760:	d3 e0                	shl    %cl,%eax
    5762:	09 15 e4 d9 00 00    	or     %edx,0xd9e4
    5768:	09 05 e0 d9 00 00    	or     %eax,0xd9e0
	if (irq_premask & ((u64_t)1<<irq)) { /* if IRQ is pending */
    576e:	8b 15 ec d9 00 00    	mov    0xd9ec,%edx
    5774:	a1 e8 d9 00 00       	mov    0xd9e8,%eax
    5779:	0f ad d0             	shrd   %cl,%edx,%eax
    577c:	d3 ea                	shr    %cl,%edx
    577e:	f6 c1 20             	test   $0x20,%cl
    5781:	0f 45 c2             	cmovne %edx,%eax
    5784:	83 e0 01             	and    $0x1,%eax
    5787:	85 c0                	test   %eax,%eax
    5789:	74 08                	je     5793 <hw_irq_ctrl_enable_irq+0x4a>
}
    578b:	5b                   	pop    %ebx
    578c:	5e                   	pop    %esi
    578d:	5d                   	pop    %ebp
		hw_irq_ctrl_raise_im_from_sw(irq);
    578e:	e9 97 ff ff ff       	jmp    572a <hw_irq_ctrl_raise_im_from_sw>
}
    5793:	5b                   	pop    %ebx
    5794:	5e                   	pop    %esi
    5795:	5d                   	pop    %ebp
    5796:	c3                   	ret    

00005797 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
    5797:	55                   	push   %ebp
	irq_ctrl_timer = NEVER;
    5798:	c7 05 e8 c1 00 00 ff 	movl   $0xffffffff,0xc1e8
    579f:	ff ff ff 
    57a2:	c7 05 ec c1 00 00 ff 	movl   $0xffffffff,0xc1ec
    57a9:	ff ff ff 
{
    57ac:	89 e5                	mov    %esp,%ebp
	irq_raising_from_hw_now();
}
    57ae:	5d                   	pop    %ebp
	irq_raising_from_hw_now();
    57af:	e9 20 fd ff ff       	jmp    54d4 <irq_raising_from_hw_now>

000057b4 <posix_exit>:
#include <stdlib.h>
#include <sys/util.h>
#include "cmdline.h"

void posix_exit(int exit_code)
{
    57b4:	55                   	push   %ebp
    57b5:	89 e5                	mov    %esp,%ebp
    57b7:	83 ec 08             	sub    $0x8,%esp
    57ba:	8b 45 08             	mov    0x8(%ebp),%eax
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
    57bd:	39 05 48 da 00 00    	cmp    %eax,0xda48
    57c3:	0f 4d 05 48 da 00 00 	cmovge 0xda48,%eax
    57ca:	a3 48 da 00 00       	mov    %eax,0xda48
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
    57cf:	e8 60 f2 ff ff       	call   4a34 <posix_soc_clean_up>
	hwm_cleanup();
    57d4:	e8 2e f5 ff ff       	call   4d07 <hwm_cleanup>
	native_cleanup_cmd_line();
    57d9:	e8 39 08 00 00       	call   6017 <native_cleanup_cmd_line>
	exit(max_exit_code);
    57de:	83 ec 0c             	sub    $0xc,%esp
    57e1:	ff 35 48 da 00 00    	pushl  0xda48
    57e7:	e8 fc ff ff ff       	call   57e8 <posix_exit+0x34>

000057ec <main>:
/**
 * This is the actual main for the Linux process,
 * the Zephyr application main is renamed something else thru a define.
 */
int main(int argc, char *argv[])
{
    57ec:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    57f0:	83 e4 f0             	and    $0xfffffff0,%esp
    57f3:	ff 71 fc             	pushl  -0x4(%ecx)
    57f6:	55                   	push   %ebp
    57f7:	89 e5                	mov    %esp,%ebp
    57f9:	56                   	push   %esi
    57fa:	53                   	push   %ebx
    57fb:	51                   	push   %ecx
    57fc:	83 ec 18             	sub    $0x18,%esp
    57ff:	8b 71 04             	mov    0x4(%ecx),%esi
    5802:	8b 19                	mov    (%ecx),%ebx
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
    5804:	6a 00                	push   $0x0
    5806:	e8 00 f2 ff ff       	call   4a0b <run_native_tasks>
    580b:	58                   	pop    %eax
    580c:	5a                   	pop    %edx

	native_handle_cmd_line(argc, argv);
    580d:	56                   	push   %esi
    580e:	53                   	push   %ebx
    580f:	e8 db 08 00 00       	call   60ef <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
    5814:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    581b:	e8 eb f1 ff ff       	call   4a0b <run_native_tasks>
    5820:	83 c4 10             	add    $0x10,%esp

	hwm_init();
    5823:	e8 c4 f4 ff ff       	call   4cec <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
    5828:	83 ec 0c             	sub    $0xc,%esp
    582b:	6a 02                	push   $0x2
    582d:	e8 d9 f1 ff ff       	call   4a0b <run_native_tasks>
    5832:	83 c4 10             	add    $0x10,%esp

	posix_boot_cpu();
    5835:	e8 21 f1 ff ff       	call   495b <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
    583a:	83 ec 0c             	sub    $0xc,%esp
    583d:	6a 03                	push   $0x3
    583f:	e8 c7 f1 ff ff       	call   4a0b <run_native_tasks>
    5844:	83 c4 10             	add    $0x10,%esp

	hwm_main_loop();
    5847:	e8 98 f3 ff ff       	call   4be4 <hwm_main_loop>

	/* This line should be unreachable */
	return 1; /* LCOV_EXCL_LINE */
}
    584c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    584f:	b8 01 00 00 00       	mov    $0x1,%eax
    5854:	59                   	pop    %ecx
    5855:	5b                   	pop    %ebx
    5856:	5e                   	pop    %esi
    5857:	5d                   	pop    %ebp
    5858:	8d 61 fc             	lea    -0x4(%ecx),%esp
    585b:	c3                   	ret    

0000585c <trace_disable_color>:
 * Indexed 0:stdout, 1:stderr
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
    585c:	55                   	push   %ebp
	is_a_tty[0] = 0;
    585d:	c7 05 04 c2 00 00 00 	movl   $0x0,0xc204
    5864:	00 00 00 
	is_a_tty[1] = 0;
    5867:	c7 05 08 c2 00 00 00 	movl   $0x0,0xc208
    586e:	00 00 00 
{
    5871:	89 e5                	mov    %esp,%ebp
}
    5873:	5d                   	pop    %ebp
    5874:	c3                   	ret    

00005875 <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
    5875:	55                   	push   %ebp
	is_a_tty[0] = -1;
    5876:	c7 05 04 c2 00 00 ff 	movl   $0xffffffff,0xc204
    587d:	ff ff ff 
	is_a_tty[1] = -1;
    5880:	c7 05 08 c2 00 00 ff 	movl   $0xffffffff,0xc208
    5887:	ff ff ff 
{
    588a:	89 e5                	mov    %esp,%ebp

}
    588c:	5d                   	pop    %ebp
    588d:	c3                   	ret    

0000588e <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
    588e:	55                   	push   %ebp
	is_a_tty[0] = 1;
    588f:	c7 05 04 c2 00 00 01 	movl   $0x1,0xc204
    5896:	00 00 00 
	is_a_tty[1] = 1;
    5899:	c7 05 08 c2 00 00 01 	movl   $0x1,0xc208
    58a0:	00 00 00 
{
    58a3:	89 e5                	mov    %esp,%ebp
}
    58a5:	5d                   	pop    %ebp
    58a6:	c3                   	ret    

000058a7 <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
    58a7:	55                   	push   %ebp
    58a8:	89 e5                	mov    %esp,%ebp
    58aa:	83 ec 08             	sub    $0x8,%esp
	if (is_a_tty[0] == -1) {
    58ad:	83 3d 04 c2 00 00 ff 	cmpl   $0xffffffff,0xc204
    58b4:	75 12                	jne    58c8 <decide_about_color+0x21>
		is_a_tty[0] = isatty(STDOUT_FILENO);
    58b6:	83 ec 0c             	sub    $0xc,%esp
    58b9:	6a 01                	push   $0x1
    58bb:	e8 fc ff ff ff       	call   58bc <decide_about_color+0x15>
    58c0:	83 c4 10             	add    $0x10,%esp
    58c3:	a3 04 c2 00 00       	mov    %eax,0xc204
	}
	if (is_a_tty[1] == -1) {
    58c8:	83 3d 08 c2 00 00 ff 	cmpl   $0xffffffff,0xc208
    58cf:	75 12                	jne    58e3 <decide_about_color+0x3c>
		is_a_tty[1] = isatty(STDERR_FILENO);
    58d1:	83 ec 0c             	sub    $0xc,%esp
    58d4:	6a 02                	push   $0x2
    58d6:	e8 fc ff ff ff       	call   58d7 <decide_about_color+0x30>
    58db:	83 c4 10             	add    $0x10,%esp
    58de:	a3 08 c2 00 00       	mov    %eax,0xc208
	}
}
    58e3:	c9                   	leave  
    58e4:	c3                   	ret    

000058e5 <posix_print_error_and_exit>:
{
    58e5:	55                   	push   %ebp
    58e6:	89 e5                	mov    %esp,%ebp
    58e8:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
    58eb:	8d 45 0c             	lea    0xc(%ebp),%eax

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, _G_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
    58ee:	50                   	push   %eax
    58ef:	ff 75 08             	pushl  0x8(%ebp)
    58f2:	6a 01                	push   $0x1
    58f4:	ff 35 00 00 00 00    	pushl  0x0
    58fa:	e8 fc ff ff ff       	call   58fb <posix_print_error_and_exit+0x16>
	posix_exit(1);
    58ff:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    5906:	e8 a9 fe ff ff       	call   57b4 <posix_exit>
    590b:	83 c4 10             	add    $0x10,%esp
}
    590e:	c9                   	leave  
    590f:	c3                   	ret    

00005910 <posix_print_warning>:
{
    5910:	55                   	push   %ebp
    5911:	89 e5                	mov    %esp,%ebp
    5913:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
    5916:	8d 45 0c             	lea    0xc(%ebp),%eax
    5919:	50                   	push   %eax
    591a:	ff 75 08             	pushl  0x8(%ebp)
    591d:	6a 01                	push   $0x1
    591f:	ff 35 00 00 00 00    	pushl  0x0
    5925:	e8 fc ff ff ff       	call   5926 <posix_print_warning+0x16>
    592a:	83 c4 10             	add    $0x10,%esp
}
    592d:	c9                   	leave  
    592e:	c3                   	ret    

0000592f <posix_print_trace>:
{
    592f:	55                   	push   %ebp
    5930:	89 e5                	mov    %esp,%ebp
    5932:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
    5935:	8d 45 0c             	lea    0xc(%ebp),%eax
    5938:	50                   	push   %eax
    5939:	ff 75 08             	pushl  0x8(%ebp)
    593c:	6a 01                	push   $0x1
    593e:	ff 35 00 00 00 00    	pushl  0x0
    5944:	e8 fc ff ff ff       	call   5945 <posix_print_trace+0x16>
    5949:	83 c4 10             	add    $0x10,%esp
}
    594c:	c9                   	leave  
    594d:	c3                   	ret    

0000594e <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
    594e:	55                   	push   %ebp
    594f:	89 e5                	mov    %esp,%ebp
    5951:	83 ec 14             	sub    $0x14,%esp
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
    5954:	68 20 c1 00 00       	push   $0xc120
    5959:	e8 de 06 00 00       	call   603c <native_add_command_line_opts>
    595e:	83 c4 10             	add    $0x10,%esp
}
    5961:	c9                   	leave  
    5962:	c3                   	ret    

00005963 <cmd_gen_switch_syntax.part.0.constprop.1>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
    5963:	55                   	push   %ebp
    5964:	89 e5                	mov    %esp,%ebp
    5966:	57                   	push   %edi
    5967:	56                   	push   %esi
    5968:	53                   	push   %ebx
    5969:	89 d7                	mov    %edx,%edi
    596b:	89 c3                	mov    %eax,%ebx
    596d:	be 46 00 00 00       	mov    $0x46,%esi
    5972:	83 ec 1c             	sub    $0x1c,%esp

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
    5975:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
    5979:	75 09                	jne    5984 <cmd_gen_switch_syntax.part.0.constprop.1+0x21>
		*buf++ = '[';
    597b:	c6 00 5b             	movb   $0x5b,(%eax)
    597e:	43                   	inc    %ebx
		size--;
    597f:	be 45 00 00 00       	mov    $0x45,%esi
	}

	if (args_s_el->is_switch == true) {
    5984:	80 7f 02 00          	cmpb   $0x0,0x2(%edi)
    5988:	8b 47 04             	mov    0x4(%edi),%eax
    598b:	74 0a                	je     5997 <cmd_gen_switch_syntax.part.0.constprop.1+0x34>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
    598d:	52                   	push   %edx
    598e:	52                   	push   %edx
    598f:	50                   	push   %eax
    5990:	68 57 97 00 00       	push   $0x9757
    5995:	eb 1b                	jmp    59b2 <cmd_gen_switch_syntax.part.0.constprop.1+0x4f>
		ret = snprintf(buf, size, "-%s", args_s_el->option);
	} else {
		if (args_s_el->type != 'l') {
    5997:	80 7f 0c 6c          	cmpb   $0x6c,0xc(%edi)
    599b:	8b 57 08             	mov    0x8(%edi),%edx
    599e:	74 0a                	je     59aa <cmd_gen_switch_syntax.part.0.constprop.1+0x47>
    59a0:	51                   	push   %ecx
    59a1:	52                   	push   %edx
    59a2:	50                   	push   %eax
    59a3:	68 5b 97 00 00       	push   $0x975b
    59a8:	eb 08                	jmp    59b2 <cmd_gen_switch_syntax.part.0.constprop.1+0x4f>
    59aa:	51                   	push   %ecx
    59ab:	52                   	push   %edx
    59ac:	50                   	push   %eax
    59ad:	68 64 97 00 00       	push   $0x9764
    59b2:	6a ff                	push   $0xffffffff
    59b4:	6a 01                	push   $0x1
    59b6:	56                   	push   %esi
    59b7:	53                   	push   %ebx
    59b8:	e8 fc ff ff ff       	call   59b9 <cmd_gen_switch_syntax.part.0.constprop.1+0x56>
    59bd:	83 c4 20             	add    $0x20,%esp
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
    59c0:	85 c0                	test   %eax,%eax
    59c2:	79 1e                	jns    59e2 <cmd_gen_switch_syntax.part.0.constprop.1+0x7f>
		posix_print_error_and_exit("Unexpected error in %s %i\n",
    59c4:	51                   	push   %ecx
    59c5:	68 07 01 00 00       	push   $0x107
    59ca:	68 70 97 00 00       	push   $0x9770
    59cf:	68 bd 97 00 00       	push   $0x97bd
    59d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    59d7:	e8 09 ff ff ff       	call   58e5 <posix_print_error_and_exit>
    59dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    59df:	83 c4 10             	add    $0x10,%esp
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
    59e2:	29 c6                	sub    %eax,%esi
    59e4:	78 20                	js     5a06 <cmd_gen_switch_syntax.part.0.constprop.1+0xa3>
		 * If we run out of space we can just stop,
		 * this is not critical
		 */
		return;
	}
	buf += ret;
    59e6:	01 c3                	add    %eax,%ebx
	size -= ret;

	if (args_s_el->is_mandatory == false) {
    59e8:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
    59ec:	75 08                	jne    59f6 <cmd_gen_switch_syntax.part.0.constprop.1+0x93>
    59ee:	52                   	push   %edx
    59ef:	68 d8 97 00 00       	push   $0x97d8
    59f4:	eb 06                	jmp    59fc <cmd_gen_switch_syntax.part.0.constprop.1+0x99>
    59f6:	50                   	push   %eax
    59f7:	68 d9 97 00 00       	push   $0x97d9
    59fc:	56                   	push   %esi
    59fd:	53                   	push   %ebx
    59fe:	e8 fc ff ff ff       	call   59ff <cmd_gen_switch_syntax.part.0.constprop.1+0x9c>
    5a03:	83 c4 10             	add    $0x10,%esp
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
    5a06:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5a09:	5b                   	pop    %ebx
    5a0a:	5e                   	pop    %esi
    5a0b:	5f                   	pop    %edi
    5a0c:	5d                   	pop    %ebp
    5a0d:	c3                   	ret    

00005a0e <cmd_is_option>:
{
    5a0e:	55                   	push   %ebp
	size_t to_match_len = strlen(option);
    5a0f:	83 c9 ff             	or     $0xffffffff,%ecx
    5a12:	31 c0                	xor    %eax,%eax
{
    5a14:	89 e5                	mov    %esp,%ebp
    5a16:	57                   	push   %edi
    5a17:	56                   	push   %esi
    5a18:	53                   	push   %ebx
    5a19:	83 ec 1c             	sub    $0x1c,%esp
    5a1c:	8b 75 0c             	mov    0xc(%ebp),%esi
    5a1f:	8b 55 08             	mov    0x8(%ebp),%edx
    5a22:	8b 5d 10             	mov    0x10(%ebp),%ebx
	size_t to_match_len = strlen(option);
    5a25:	89 f7                	mov    %esi,%edi
    5a27:	f2 ae                	repnz scas %es:(%edi),%al
    5a29:	f7 d1                	not    %ecx
    5a2b:	8d 79 ff             	lea    -0x1(%ecx),%edi
	int of = 0;
    5a2e:	31 c9                	xor    %ecx,%ecx
    5a30:	80 3a 2d             	cmpb   $0x2d,(%edx)
    5a33:	0f 94 c1             	sete   %cl
	if (arg[of] == '-') {
    5a36:	80 3c 0a 2d          	cmpb   $0x2d,(%edx,%ecx,1)
    5a3a:	75 01                	jne    5a3d <cmd_is_option+0x2f>
		of++;
    5a3c:	41                   	inc    %ecx
	if (!with_value) {
    5a3d:	85 db                	test   %ebx,%ebx
    5a3f:	75 1d                	jne    5a5e <cmd_is_option+0x50>
		if (strcmp(&arg[of], option) != 0) {
    5a41:	01 ca                	add    %ecx,%edx
    5a43:	50                   	push   %eax
    5a44:	50                   	push   %eax
    5a45:	56                   	push   %esi
    5a46:	52                   	push   %edx
    5a47:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    5a4a:	e8 fc ff ff ff       	call   5a4b <cmd_is_option+0x3d>
    5a4f:	83 c4 10             	add    $0x10,%esp
    5a52:	85 c0                	test   %eax,%eax
    5a54:	75 4a                	jne    5aa0 <cmd_is_option+0x92>
			return of + to_match_len;
    5a56:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    5a59:	8d 1c 0f             	lea    (%edi,%ecx,1),%ebx
    5a5c:	eb 42                	jmp    5aa0 <cmd_is_option+0x92>
    5a5e:	89 cb                	mov    %ecx,%ebx
    5a60:	29 ce                	sub    %ecx,%esi
	while (!(arg[of] == 0 && *option == 0)) {
    5a62:	8a 04 1a             	mov    (%edx,%ebx,1),%al
    5a65:	8a 0c 1e             	mov    (%esi,%ebx,1),%cl
    5a68:	84 c0                	test   %al,%al
    5a6a:	74 16                	je     5a82 <cmd_is_option+0x74>
		if (*option == 0) {
    5a6c:	84 c9                	test   %cl,%cl
    5a6e:	75 0b                	jne    5a7b <cmd_is_option+0x6d>
			if ((arg[of] == ':') || (arg[of] == '=')) {
    5a70:	3c 3a                	cmp    $0x3a,%al
    5a72:	74 04                	je     5a78 <cmd_is_option+0x6a>
    5a74:	3c 3d                	cmp    $0x3d,%al
    5a76:	75 26                	jne    5a9e <cmd_is_option+0x90>
				of++;
    5a78:	43                   	inc    %ebx
				break;
    5a79:	eb 0b                	jmp    5a86 <cmd_is_option+0x78>
		if (arg[of] != *option) {
    5a7b:	38 c8                	cmp    %cl,%al
    5a7d:	75 1f                	jne    5a9e <cmd_is_option+0x90>
		of++;
    5a7f:	43                   	inc    %ebx
    5a80:	eb e0                	jmp    5a62 <cmd_is_option+0x54>
	while (!(arg[of] == 0 && *option == 0)) {
    5a82:	84 c9                	test   %cl,%cl
    5a84:	75 18                	jne    5a9e <cmd_is_option+0x90>
	if (arg[of] == 0) { /* we need a value to follow */
    5a86:	80 3c 1a 00          	cmpb   $0x0,(%edx,%ebx,1)
    5a8a:	75 14                	jne    5aa0 <cmd_is_option+0x92>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
    5a8c:	50                   	push   %eax
    5a8d:	50                   	push   %eax
    5a8e:	52                   	push   %edx
    5a8f:	68 db 97 00 00       	push   $0x97db
    5a94:	e8 4c fe ff ff       	call   58e5 <posix_print_error_and_exit>
    5a99:	83 c4 10             	add    $0x10,%esp
    5a9c:	eb 02                	jmp    5aa0 <cmd_is_option+0x92>
			return 0;
    5a9e:	31 db                	xor    %ebx,%ebx
}
    5aa0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5aa3:	89 d8                	mov    %ebx,%eax
    5aa5:	5b                   	pop    %ebx
    5aa6:	5e                   	pop    %esi
    5aa7:	5f                   	pop    %edi
    5aa8:	5d                   	pop    %ebp
    5aa9:	c3                   	ret    

00005aaa <cmd_is_help_option>:
{
    5aaa:	55                   	push   %ebp
    5aab:	89 e5                	mov    %esp,%ebp
    5aad:	56                   	push   %esi
    5aae:	53                   	push   %ebx
    5aaf:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (arg[0] == '-') {
    5ab2:	80 3b 2d             	cmpb   $0x2d,(%ebx)
    5ab5:	75 01                	jne    5ab8 <cmd_is_help_option+0xe>
		arg++;
    5ab7:	43                   	inc    %ebx
	if (arg[0] == '-') {
    5ab8:	80 3b 2d             	cmpb   $0x2d,(%ebx)
    5abb:	75 01                	jne    5abe <cmd_is_help_option+0x14>
		arg++;
    5abd:	43                   	inc    %ebx
	if ((strcasecmp(arg, "?") == 0) ||
    5abe:	51                   	push   %ecx
    5abf:	51                   	push   %ecx
		return 1;
    5ac0:	be 01 00 00 00       	mov    $0x1,%esi
	if ((strcasecmp(arg, "?") == 0) ||
    5ac5:	68 35 98 00 00       	push   $0x9835
    5aca:	53                   	push   %ebx
    5acb:	e8 fc ff ff ff       	call   5acc <cmd_is_help_option+0x22>
    5ad0:	83 c4 10             	add    $0x10,%esp
    5ad3:	85 c0                	test   %eax,%eax
    5ad5:	74 2e                	je     5b05 <cmd_is_help_option+0x5b>
	    (strcasecmp(arg, "h") == 0) ||
    5ad7:	52                   	push   %edx
    5ad8:	52                   	push   %edx
    5ad9:	68 0e 9e 00 00       	push   $0x9e0e
    5ade:	53                   	push   %ebx
    5adf:	e8 fc ff ff ff       	call   5ae0 <cmd_is_help_option+0x36>
    5ae4:	83 c4 10             	add    $0x10,%esp
	if ((strcasecmp(arg, "?") == 0) ||
    5ae7:	85 c0                	test   %eax,%eax
    5ae9:	74 1a                	je     5b05 <cmd_is_help_option+0x5b>
	    (strcasecmp(arg, "help") == 0)) {
    5aeb:	50                   	push   %eax
    5aec:	50                   	push   %eax
    5aed:	68 d3 98 00 00       	push   $0x98d3
    5af2:	53                   	push   %ebx
    5af3:	e8 fc ff ff ff       	call   5af4 <cmd_is_help_option+0x4a>
    5af8:	83 c4 10             	add    $0x10,%esp
	    (strcasecmp(arg, "h") == 0) ||
    5afb:	85 c0                	test   %eax,%eax
    5afd:	0f 94 c0             	sete   %al
    5b00:	0f b6 c0             	movzbl %al,%eax
    5b03:	89 c6                	mov    %eax,%esi
}
    5b05:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5b08:	89 f0                	mov    %esi,%eax
    5b0a:	5b                   	pop    %ebx
    5b0b:	5e                   	pop    %esi
    5b0c:	5d                   	pop    %ebp
    5b0d:	c3                   	ret    

00005b0e <cmd_read_option_value>:
{
    5b0e:	55                   	push   %ebp
    5b0f:	89 e5                	mov    %esp,%ebp
    5b11:	57                   	push   %edi
    5b12:	56                   	push   %esi
    5b13:	53                   	push   %ebx
    5b14:	83 ec 1c             	sub    $0x1c,%esp
    5b17:	8b 45 10             	mov    0x10(%ebp),%eax
    5b1a:	8b 5d 08             	mov    0x8(%ebp),%ebx
    5b1d:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
    5b24:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    5b27:	31 d2                	xor    %edx,%edx
    5b29:	8b 7d 0c             	mov    0xc(%ebp),%edi
    5b2c:	8b 75 14             	mov    0x14(%ebp),%esi
	switch (type) {
    5b2f:	3c 64                	cmp    $0x64,%al
	char *endptr = NULL;
    5b31:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	switch (type) {
    5b38:	0f 84 1b 01 00 00    	je     5c59 <cmd_read_option_value+0x14b>
    5b3e:	7f 26                	jg     5b66 <cmd_read_option_value+0x58>
    5b40:	3c 55                	cmp    $0x55,%al
    5b42:	0f 84 f1 00 00 00    	je     5c39 <cmd_read_option_value+0x12b>
    5b48:	3c 62                	cmp    $0x62,%al
    5b4a:	74 44                	je     5b90 <cmd_read_option_value+0x82>
    5b4c:	3c 49                	cmp    $0x49,%al
    5b4e:	0f 85 18 01 00 00    	jne    5c6c <cmd_read_option_value+0x15e>
		*(s64_t *)dest = strtoll(str, &endptr, 0);
    5b54:	50                   	push   %eax
    5b55:	8d 45 e0             	lea    -0x20(%ebp),%eax
    5b58:	6a 00                	push   $0x0
    5b5a:	50                   	push   %eax
    5b5b:	53                   	push   %ebx
    5b5c:	e8 fc ff ff ff       	call   5b5d <cmd_read_option_value+0x4f>
    5b61:	e9 e9 00 00 00       	jmp    5c4f <cmd_read_option_value+0x141>
	switch (type) {
    5b66:	3c 73                	cmp    $0x73,%al
    5b68:	0f 84 a7 00 00 00    	je     5c15 <cmd_read_option_value+0x107>
    5b6e:	3c 75                	cmp    $0x75,%al
    5b70:	0f 84 b4 00 00 00    	je     5c2a <cmd_read_option_value+0x11c>
    5b76:	3c 69                	cmp    $0x69,%al
    5b78:	0f 85 ee 00 00 00    	jne    5c6c <cmd_read_option_value+0x15e>
		*(s32_t *)dest = strtol(str, &endptr, 0);
    5b7e:	50                   	push   %eax
    5b7f:	8d 45 e0             	lea    -0x20(%ebp),%eax
    5b82:	6a 00                	push   $0x0
    5b84:	50                   	push   %eax
    5b85:	53                   	push   %ebx
    5b86:	e8 fc ff ff ff       	call   5b87 <cmd_read_option_value+0x79>
    5b8b:	e9 b8 00 00 00       	jmp    5c48 <cmd_read_option_value+0x13a>
		if (strcasecmp(str, "false") == 0) {
    5b90:	50                   	push   %eax
    5b91:	50                   	push   %eax
    5b92:	68 37 98 00 00       	push   $0x9837
    5b97:	53                   	push   %ebx
    5b98:	e8 fc ff ff ff       	call   5b99 <cmd_read_option_value+0x8b>
    5b9d:	83 c4 10             	add    $0x10,%esp
    5ba0:	85 c0                	test   %eax,%eax
    5ba2:	75 08                	jne    5bac <cmd_read_option_value+0x9e>
			*(bool *)dest = false;
    5ba4:	c6 07 00             	movb   $0x0,(%edi)
			endptr = (char *)str + 5;
    5ba7:	8d 43 05             	lea    0x5(%ebx),%eax
    5baa:	eb 1a                	jmp    5bc6 <cmd_read_option_value+0xb8>
		} else if (strcmp(str, "0") == 0) {
    5bac:	51                   	push   %ecx
    5bad:	51                   	push   %ecx
    5bae:	68 94 9e 00 00       	push   $0x9e94
    5bb3:	53                   	push   %ebx
    5bb4:	e8 fc ff ff ff       	call   5bb5 <cmd_read_option_value+0xa7>
    5bb9:	83 c4 10             	add    $0x10,%esp
    5bbc:	85 c0                	test   %eax,%eax
    5bbe:	75 0e                	jne    5bce <cmd_read_option_value+0xc0>
			*(bool *)dest = false;
    5bc0:	c6 07 00             	movb   $0x0,(%edi)
			endptr = (char *)str + 1;
    5bc3:	8d 43 01             	lea    0x1(%ebx),%eax
    5bc6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5bc9:	e9 b1 00 00 00       	jmp    5c7f <cmd_read_option_value+0x171>
		} else if (strcasecmp(str, "true") == 0) {
    5bce:	52                   	push   %edx
    5bcf:	52                   	push   %edx
    5bd0:	68 3d 98 00 00       	push   $0x983d
    5bd5:	53                   	push   %ebx
    5bd6:	e8 fc ff ff ff       	call   5bd7 <cmd_read_option_value+0xc9>
    5bdb:	83 c4 10             	add    $0x10,%esp
    5bde:	85 c0                	test   %eax,%eax
    5be0:	75 08                	jne    5bea <cmd_read_option_value+0xdc>
			*(bool *)dest = true;
    5be2:	c6 07 01             	movb   $0x1,(%edi)
			endptr = (char *)str + 4;
    5be5:	8d 43 04             	lea    0x4(%ebx),%eax
    5be8:	eb dc                	jmp    5bc6 <cmd_read_option_value+0xb8>
		} else if (strcmp(str, "1") == 0) {
    5bea:	50                   	push   %eax
    5beb:	50                   	push   %eax
    5bec:	68 4b 9e 00 00       	push   $0x9e4b
    5bf1:	53                   	push   %ebx
    5bf2:	e8 fc ff ff ff       	call   5bf3 <cmd_read_option_value+0xe5>
    5bf7:	83 c4 10             	add    $0x10,%esp
    5bfa:	85 c0                	test   %eax,%eax
    5bfc:	74 12                	je     5c10 <cmd_read_option_value+0x102>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
    5bfe:	50                   	push   %eax
    5bff:	53                   	push   %ebx
    5c00:	56                   	push   %esi
    5c01:	68 42 98 00 00       	push   $0x9842
    5c06:	e8 da fc ff ff       	call   58e5 <posix_print_error_and_exit>
    5c0b:	83 c4 10             	add    $0x10,%esp
    5c0e:	eb 7f                	jmp    5c8f <cmd_read_option_value+0x181>
			*(bool *)dest = true;
    5c10:	c6 07 01             	movb   $0x1,(%edi)
    5c13:	eb ae                	jmp    5bc3 <cmd_read_option_value+0xb5>
		*(char **)dest = (char *)str;
    5c15:	89 1f                	mov    %ebx,(%edi)
		endptr = (char *)str + strlen(str);
    5c17:	31 c0                	xor    %eax,%eax
    5c19:	83 c9 ff             	or     $0xffffffff,%ecx
    5c1c:	89 df                	mov    %ebx,%edi
    5c1e:	f2 ae                	repnz scas %es:(%edi),%al
    5c20:	89 ca                	mov    %ecx,%edx
    5c22:	f7 d2                	not    %edx
    5c24:	8d 44 13 ff          	lea    -0x1(%ebx,%edx,1),%eax
    5c28:	eb 9c                	jmp    5bc6 <cmd_read_option_value+0xb8>
		*(u32_t *)dest = strtoul(str, &endptr, 0);
    5c2a:	50                   	push   %eax
    5c2b:	8d 45 e0             	lea    -0x20(%ebp),%eax
    5c2e:	6a 00                	push   $0x0
    5c30:	50                   	push   %eax
    5c31:	53                   	push   %ebx
    5c32:	e8 fc ff ff ff       	call   5c33 <cmd_read_option_value+0x125>
    5c37:	eb 0f                	jmp    5c48 <cmd_read_option_value+0x13a>
		*(u64_t *)dest = strtoull(str, &endptr, 0);
    5c39:	50                   	push   %eax
    5c3a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    5c3d:	6a 00                	push   $0x0
    5c3f:	50                   	push   %eax
    5c40:	53                   	push   %ebx
    5c41:	e8 fc ff ff ff       	call   5c42 <cmd_read_option_value+0x134>
    5c46:	eb 07                	jmp    5c4f <cmd_read_option_value+0x141>
		*(s32_t *)dest = strtol(str, &endptr, 0);
    5c48:	83 c4 10             	add    $0x10,%esp
    5c4b:	89 07                	mov    %eax,(%edi)
    5c4d:	eb 30                	jmp    5c7f <cmd_read_option_value+0x171>
		*(s64_t *)dest = strtoll(str, &endptr, 0);
    5c4f:	83 c4 10             	add    $0x10,%esp
    5c52:	89 07                	mov    %eax,(%edi)
    5c54:	89 57 04             	mov    %edx,0x4(%edi)
    5c57:	eb 26                	jmp    5c7f <cmd_read_option_value+0x171>
		*(double *)dest = strtod(str, &endptr);
    5c59:	8d 45 e0             	lea    -0x20(%ebp),%eax
    5c5c:	51                   	push   %ecx
    5c5d:	51                   	push   %ecx
    5c5e:	50                   	push   %eax
    5c5f:	53                   	push   %ebx
    5c60:	e8 fc ff ff ff       	call   5c61 <cmd_read_option_value+0x153>
    5c65:	83 c4 10             	add    $0x10,%esp
    5c68:	dd 1f                	fstpl  (%edi)
    5c6a:	eb 13                	jmp    5c7f <cmd_read_option_value+0x171>
	switch (type) {
    5c6c:	0f be c0             	movsbl %al,%eax
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
    5c6f:	52                   	push   %edx
    5c70:	52                   	push   %edx
    5c71:	50                   	push   %eax
    5c72:	68 84 98 00 00       	push   $0x9884
    5c77:	e8 69 fc ff ff       	call   58e5 <posix_print_error_and_exit>
    5c7c:	83 c4 10             	add    $0x10,%esp
	if (!error && endptr && *endptr != 0) {
    5c7f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5c82:	85 c0                	test   %eax,%eax
    5c84:	74 09                	je     5c8f <cmd_read_option_value+0x181>
    5c86:	80 38 00             	cmpb   $0x0,(%eax)
    5c89:	0f 85 6f ff ff ff    	jne    5bfe <cmd_read_option_value+0xf0>
}
    5c8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c92:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    5c99:	74 05                	je     5ca0 <cmd_read_option_value+0x192>
    5c9b:	e8 fc ff ff ff       	call   5c9c <cmd_read_option_value+0x18e>
    5ca0:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5ca3:	5b                   	pop    %ebx
    5ca4:	5e                   	pop    %esi
    5ca5:	5f                   	pop    %edi
    5ca6:	5d                   	pop    %ebp
    5ca7:	c3                   	ret    

00005ca8 <cmd_args_set_defaults>:
{
    5ca8:	55                   	push   %ebp
    5ca9:	89 e5                	mov    %esp,%ebp
    5cab:	53                   	push   %ebx
    5cac:	51                   	push   %ecx
    5cad:	8b 45 08             	mov    0x8(%ebp),%eax
    5cb0:	8d 58 04             	lea    0x4(%eax),%ebx
	while (args_struct[count].option != NULL) {
    5cb3:	83 3b 00             	cmpl   $0x0,(%ebx)
    5cb6:	0f 84 8e 00 00 00    	je     5d4a <cmd_args_set_defaults+0xa2>
		if (args_struct[count].dest == NULL) {
    5cbc:	8b 53 0c             	mov    0xc(%ebx),%edx
    5cbf:	85 d2                	test   %edx,%edx
    5cc1:	74 7f                	je     5d42 <cmd_args_set_defaults+0x9a>
		switch (args_struct[count].type) {
    5cc3:	0f be 43 08          	movsbl 0x8(%ebx),%eax
    5cc7:	3c 62                	cmp    $0x62,%al
    5cc9:	74 34                	je     5cff <cmd_args_set_defaults+0x57>
    5ccb:	7f 0e                	jg     5cdb <cmd_args_set_defaults+0x33>
    5ccd:	3c 49                	cmp    $0x49,%al
    5ccf:	74 52                	je     5d23 <cmd_args_set_defaults+0x7b>
    5cd1:	3c 55                	cmp    $0x55,%al
    5cd3:	74 37                	je     5d0c <cmd_args_set_defaults+0x64>
    5cd5:	84 c0                	test   %al,%al
    5cd7:	75 59                	jne    5d32 <cmd_args_set_defaults+0x8a>
    5cd9:	eb 67                	jmp    5d42 <cmd_args_set_defaults+0x9a>
    5cdb:	3c 69                	cmp    $0x69,%al
    5cdd:	74 3c                	je     5d1b <cmd_args_set_defaults+0x73>
    5cdf:	7f 0e                	jg     5cef <cmd_args_set_defaults+0x47>
    5ce1:	3c 64                	cmp    $0x64,%al
    5ce3:	75 4d                	jne    5d32 <cmd_args_set_defaults+0x8a>
			*(double *)args_struct[count].dest = NAN;
    5ce5:	d9 05 f0 8a 00 00    	flds   0x8af0
    5ceb:	dd 1a                	fstpl  (%edx)
			break;
    5ced:	eb 53                	jmp    5d42 <cmd_args_set_defaults+0x9a>
		switch (args_struct[count].type) {
    5cef:	3c 73                	cmp    $0x73,%al
    5cf1:	74 11                	je     5d04 <cmd_args_set_defaults+0x5c>
    5cf3:	3c 75                	cmp    $0x75,%al
    5cf5:	75 3b                	jne    5d32 <cmd_args_set_defaults+0x8a>
			*(u32_t *)args_struct[count].dest = UINT32_MAX;
    5cf7:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
			break;
    5cfd:	eb 43                	jmp    5d42 <cmd_args_set_defaults+0x9a>
			*(bool *)args_struct[count].dest = false;
    5cff:	c6 02 00             	movb   $0x0,(%edx)
			break;
    5d02:	eb 3e                	jmp    5d42 <cmd_args_set_defaults+0x9a>
			*(char **)args_struct[count].dest = NULL;
    5d04:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			break;
    5d0a:	eb 36                	jmp    5d42 <cmd_args_set_defaults+0x9a>
			*(u64_t *)args_struct[count].dest = UINT64_MAX;
    5d0c:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
    5d12:	c7 42 04 ff ff ff ff 	movl   $0xffffffff,0x4(%edx)
			break;
    5d19:	eb 27                	jmp    5d42 <cmd_args_set_defaults+0x9a>
			*(s32_t *)args_struct[count].dest = INT32_MAX;
    5d1b:	c7 02 ff ff ff 7f    	movl   $0x7fffffff,(%edx)
			break;
    5d21:	eb 1f                	jmp    5d42 <cmd_args_set_defaults+0x9a>
			*(s64_t *)args_struct[count].dest = INT64_MAX;
    5d23:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
    5d29:	c7 42 04 ff ff ff 7f 	movl   $0x7fffffff,0x4(%edx)
			break;
    5d30:	eb 10                	jmp    5d42 <cmd_args_set_defaults+0x9a>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
    5d32:	52                   	push   %edx
    5d33:	52                   	push   %edx
    5d34:	50                   	push   %eax
    5d35:	68 84 98 00 00       	push   $0x9884
    5d3a:	e8 a6 fb ff ff       	call   58e5 <posix_print_error_and_exit>
    5d3f:	83 c4 10             	add    $0x10,%esp
    5d42:	83 c3 1c             	add    $0x1c,%ebx
    5d45:	e9 69 ff ff ff       	jmp    5cb3 <cmd_args_set_defaults+0xb>
}
    5d4a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5d4d:	c9                   	leave  
    5d4e:	c3                   	ret    

00005d4f <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
    5d4f:	55                   	push   %ebp
    5d50:	89 e5                	mov    %esp,%ebp
    5d52:	57                   	push   %edi
    5d53:	56                   	push   %esi
    5d54:	53                   	push   %ebx
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
    5d55:	be 19 00 00 00       	mov    $0x19,%esi
{
    5d5a:	83 ec 5c             	sub    $0x5c,%esp
    5d5d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    5d60:	68 a9 98 00 00       	push   $0x98a9
    5d65:	68 c2 98 00 00       	push   $0x98c2
    5d6a:	6a 01                	push   $0x1
    5d6c:	ff 35 00 00 00 00    	pushl  0x0
    5d72:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    5d78:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    5d7b:	31 c0                	xor    %eax,%eax
    5d7d:	e8 fc ff ff ff       	call   5d7e <cmd_print_switches_help+0x2f>
    5d82:	83 c4 10             	add    $0x10,%esp

	fprintf(stdout, "%s ", _HELP_SWITCH);

	while (args_struct[count].option != NULL) {
    5d85:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
    5d89:	74 69                	je     5df4 <cmd_print_switches_help+0xa5>
    5d8b:	8d 45 9e             	lea    -0x62(%ebp),%eax
    5d8e:	89 da                	mov    %ebx,%edx
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
    5d90:	8d 7d 9e             	lea    -0x62(%ebp),%edi
    5d93:	e8 cb fb ff ff       	call   5963 <cmd_gen_switch_syntax.part.0.constprop.1>
    5d98:	31 c0                	xor    %eax,%eax
    5d9a:	83 c9 ff             	or     $0xffffffff,%ecx
    5d9d:	f2 ae                	repnz scas %es:(%edi),%al
    5d9f:	89 ca                	mov    %ecx,%edx
    5da1:	f7 d2                	not    %edx
    5da3:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
    5da7:	83 f8 64             	cmp    $0x64,%eax
    5daa:	76 18                	jbe    5dc4 <cmd_print_switches_help+0x75>
    5dac:	52                   	push   %edx
    5dad:	68 23 9e 00 00       	push   $0x9e23
			fprintf(stdout, "\n");
			printed_in_line = 0;
    5db2:	31 f6                	xor    %esi,%esi
    5db4:	6a 01                	push   $0x1
    5db6:	ff 35 00 00 00 00    	pushl  0x0
    5dbc:	e8 fc ff ff ff       	call   5dbd <cmd_print_switches_help+0x6e>
    5dc1:	83 c4 10             	add    $0x10,%esp
    5dc4:	8d 45 9e             	lea    -0x62(%ebp),%eax
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
    5dc7:	8d 7d 9e             	lea    -0x62(%ebp),%edi
    5dca:	83 c3 1c             	add    $0x1c,%ebx
    5dcd:	50                   	push   %eax
    5dce:	68 58 97 00 00       	push   $0x9758
    5dd3:	6a 01                	push   $0x1
    5dd5:	ff 35 00 00 00 00    	pushl  0x0
    5ddb:	e8 fc ff ff ff       	call   5ddc <cmd_print_switches_help+0x8d>
    5de0:	31 c0                	xor    %eax,%eax
    5de2:	83 c9 ff             	or     $0xffffffff,%ecx
    5de5:	83 c4 10             	add    $0x10,%esp
    5de8:	f2 ae                	repnz scas %es:(%edi),%al
    5dea:	89 c8                	mov    %ecx,%eax
    5dec:	f7 d0                	not    %eax
    5dee:	8d 74 06 ff          	lea    -0x1(%esi,%eax,1),%esi
    5df2:	eb 91                	jmp    5d85 <cmd_print_switches_help+0x36>
    5df4:	50                   	push   %eax
    5df5:	68 23 9e 00 00       	push   $0x9e23
    5dfa:	6a 01                	push   $0x1
    5dfc:	ff 35 00 00 00 00    	pushl  0x0
    5e02:	e8 fc ff ff ff       	call   5e03 <cmd_print_switches_help+0xb4>
    5e07:	83 c4 10             	add    $0x10,%esp
		count++;
	}

	fprintf(stdout, "\n");
}
    5e0a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5e0d:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    5e14:	74 05                	je     5e1b <cmd_print_switches_help+0xcc>
    5e16:	e8 fc ff ff ff       	call   5e17 <cmd_print_switches_help+0xc8>
    5e1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5e1e:	5b                   	pop    %ebx
    5e1f:	5e                   	pop    %esi
    5e20:	5f                   	pop    %edi
    5e21:	5d                   	pop    %ebp
    5e22:	c3                   	ret    

00005e23 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
    5e23:	55                   	push   %ebp
    5e24:	89 e5                	mov    %esp,%ebp
    5e26:	57                   	push   %edi
    5e27:	56                   	push   %esi
    5e28:	53                   	push   %ebx
    5e29:	83 ec 78             	sub    $0x78,%esp
    5e2c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    5e2f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    5e35:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    5e38:	31 c0                	xor    %eax,%eax
	int ret;
	int count = 0;
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
    5e3a:	53                   	push   %ebx
    5e3b:	e8 0f ff ff ff       	call   5d4f <cmd_print_switches_help>
    5e40:	5a                   	pop    %edx
    5e41:	59                   	pop    %ecx
    5e42:	68 c6 98 00 00       	push   $0x98c6
    5e47:	68 a9 98 00 00       	push   $0x98a9
    5e4c:	6a 1d                	push   $0x1d
    5e4e:	68 d8 98 00 00       	push   $0x98d8
    5e53:	6a 01                	push   $0x1
    5e55:	ff 35 00 00 00 00    	pushl  0x0
    5e5b:	e8 fc ff ff ff       	call   5e5c <cmd_print_long_help+0x39>
    5e60:	83 c4 20             	add    $0x20,%esp

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
    5e63:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
    5e67:	0f 84 ab 00 00 00    	je     5f18 <cmd_print_long_help+0xf5>
    5e6d:	8d 75 9e             	lea    -0x62(%ebp),%esi
    5e70:	89 da                	mov    %ebx,%edx
    5e72:	89 f0                	mov    %esi,%eax
    5e74:	e8 ea fa ff ff       	call   5963 <cmd_gen_switch_syntax.part.0.constprop.1>
    5e79:	83 ec 0c             	sub    $0xc,%esp
    5e7c:	56                   	push   %esi
    5e7d:	6a 1d                	push   $0x1d
    5e7f:	68 e3 98 00 00       	push   $0x98e3
    5e84:	6a 01                	push   $0x1
    5e86:	ff 35 00 00 00 00    	pushl  0x0
    5e8c:	e8 fc ff ff ff       	call   5e8d <cmd_print_long_help+0x6a>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
    5e91:	8b 73 18             	mov    0x18(%ebx),%esi
    5e94:	89 c2                	mov    %eax,%edx
		total_to_print = strlen(toprint);
    5e96:	83 c9 ff             	or     $0xffffffff,%ecx
    5e99:	31 c0                	xor    %eax,%eax
    5e9b:	83 c4 14             	add    $0x14,%esp
    5e9e:	89 f7                	mov    %esi,%edi
    5ea0:	f2 ae                	repnz scas %es:(%edi),%al
    5ea2:	56                   	push   %esi
    5ea3:	f7 d1                	not    %ecx
    5ea5:	8d 41 ff             	lea    -0x1(%ecx),%eax
    5ea8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		ret = fprintf(stdout, "%.*s\n",
    5eab:	b8 64 00 00 00       	mov    $0x64,%eax
    5eb0:	29 d0                	sub    %edx,%eax
    5eb2:	50                   	push   %eax
    5eb3:	68 ea 98 00 00       	push   $0x98ea
    5eb8:	6a 01                	push   $0x1
    5eba:	ff 35 00 00 00 00    	pushl  0x0
    5ec0:	e8 fc ff ff ff       	call   5ec1 <cmd_print_long_help+0x9e>
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
    5ec5:	8d 78 ff             	lea    -0x1(%eax),%edi
    5ec8:	83 c4 20             	add    $0x20,%esp

		while (printed_right < total_to_print) {
    5ecb:	3b 7d 94             	cmp    -0x6c(%ebp),%edi
    5ece:	7d 40                	jge    5f10 <cmd_print_long_help+0xed>
    5ed0:	83 ec 0c             	sub    $0xc,%esp
    5ed3:	68 24 9e 00 00       	push   $0x9e24
    5ed8:	6a 1e                	push   $0x1e
    5eda:	68 f0 98 00 00       	push   $0x98f0
    5edf:	6a 01                	push   $0x1
    5ee1:	ff 35 00 00 00 00    	pushl  0x0
    5ee7:	e8 fc ff ff ff       	call   5ee8 <cmd_print_long_help+0xc5>
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
    5eec:	8d 04 3e             	lea    (%esi,%edi,1),%eax
    5eef:	83 c4 14             	add    $0x14,%esp
    5ef2:	50                   	push   %eax
    5ef3:	6a 46                	push   $0x46
    5ef5:	68 ea 98 00 00       	push   $0x98ea
    5efa:	6a 01                	push   $0x1
    5efc:	ff 35 00 00 00 00    	pushl  0x0
    5f02:	e8 fc ff ff ff       	call   5f03 <cmd_print_long_help+0xe0>
    5f07:	83 c4 20             	add    $0x20,%esp
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
    5f0a:	8d 7c 07 ff          	lea    -0x1(%edi,%eax,1),%edi
    5f0e:	eb bb                	jmp    5ecb <cmd_print_long_help+0xa8>
    5f10:	83 c3 1c             	add    $0x1c,%ebx
    5f13:	e9 4b ff ff ff       	jmp    5e63 <cmd_print_long_help+0x40>
    5f18:	50                   	push   %eax
    5f19:	68 23 9e 00 00       	push   $0x9e23
    5f1e:	6a 01                	push   $0x1
    5f20:	ff 35 00 00 00 00    	pushl  0x0
    5f26:	e8 fc ff ff ff       	call   5f27 <cmd_print_long_help+0x104>
    5f2b:	83 c4 0c             	add    $0xc,%esp
    5f2e:	68 f4 98 00 00       	push   $0x98f4
    5f33:	6a 01                	push   $0x1
    5f35:	ff 35 00 00 00 00    	pushl  0x0
    5f3b:	e8 fc ff ff ff       	call   5f3c <cmd_print_long_help+0x119>
    5f40:	83 c4 10             	add    $0x10,%esp
		count++;
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
    5f43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5f46:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    5f4d:	74 05                	je     5f54 <cmd_print_long_help+0x131>
    5f4f:	e8 fc ff ff ff       	call   5f50 <cmd_print_long_help+0x12d>
    5f54:	8d 65 f4             	lea    -0xc(%ebp),%esp
    5f57:	5b                   	pop    %ebx
    5f58:	5e                   	pop    %esi
    5f59:	5f                   	pop    %edi
    5f5a:	5d                   	pop    %ebp
    5f5b:	c3                   	ret    

00005f5c <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
    5f5c:	55                   	push   %ebp
    5f5d:	89 e5                	mov    %esp,%ebp
    5f5f:	57                   	push   %edi
    5f60:	56                   	push   %esi
    5f61:	53                   	push   %ebx
    5f62:	83 ec 18             	sub    $0x18,%esp
    5f65:	8b 75 08             	mov    0x8(%ebp),%esi
    5f68:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
    5f6b:	56                   	push   %esi
    5f6c:	e8 39 fb ff ff       	call   5aaa <cmd_is_help_option>
    5f71:	83 c4 10             	add    $0x10,%esp
    5f74:	85 c0                	test   %eax,%eax
    5f76:	74 22                	je     5f9a <cmd_parse_one_arg+0x3e>
		cmd_print_long_help(args_struct);
    5f78:	83 ec 0c             	sub    $0xc,%esp
    5f7b:	53                   	push   %ebx
    5f7c:	e8 a2 fe ff ff       	call   5e23 <cmd_print_long_help>
		posix_exit(0);
    5f81:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    5f88:	e8 27 f8 ff ff       	call   57b4 <posix_exit>
    5f8d:	83 c4 10             	add    $0x10,%esp
    5f90:	eb 08                	jmp    5f9a <cmd_parse_one_arg+0x3e>
	}

	while (args_struct[count].option != NULL) {
		if (args_struct[count].manual) {
    5f92:	80 3b 00             	cmpb   $0x0,(%ebx)
    5f95:	74 0c                	je     5fa3 <cmd_parse_one_arg+0x47>
    5f97:	83 c3 1c             	add    $0x1c,%ebx
	while (args_struct[count].option != NULL) {
    5f9a:	8b 53 04             	mov    0x4(%ebx),%edx
    5f9d:	85 d2                	test   %edx,%edx
    5f9f:	75 f1                	jne    5f92 <cmd_parse_one_arg+0x36>
    5fa1:	eb 6a                	jmp    600d <cmd_parse_one_arg+0xb1>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
    5fa3:	51                   	push   %ecx
				    !args_struct[count].is_switch);
    5fa4:	8a 43 02             	mov    0x2(%ebx),%al
    5fa7:	83 f0 01             	xor    $0x1,%eax
		ret = cmd_is_option(argv, args_struct[count].option,
    5faa:	0f b6 c0             	movzbl %al,%eax
    5fad:	50                   	push   %eax
    5fae:	52                   	push   %edx
    5faf:	56                   	push   %esi
    5fb0:	e8 59 fa ff ff       	call   5a0e <cmd_is_option>
    5fb5:	83 c4 10             	add    $0x10,%esp
		if (ret) {
    5fb8:	85 c0                	test   %eax,%eax
		ret = cmd_is_option(argv, args_struct[count].option,
    5fba:	89 c7                	mov    %eax,%edi
		if (ret) {
    5fbc:	74 d9                	je     5f97 <cmd_parse_one_arg+0x3b>
	if (arg_element->dest != NULL) {
    5fbe:	8b 43 10             	mov    0x10(%ebx),%eax
    5fc1:	85 c0                	test   %eax,%eax
    5fc3:	74 34                	je     5ff9 <cmd_parse_one_arg+0x9d>
		if (arg_element->is_switch) {
    5fc5:	80 7b 02 00          	cmpb   $0x0,0x2(%ebx)
    5fc9:	0f be 53 0c          	movsbl 0xc(%ebx),%edx
    5fcd:	74 19                	je     5fe8 <cmd_parse_one_arg+0x8c>
			if (arg_element->type == 'b') {
    5fcf:	80 fa 62             	cmp    $0x62,%dl
    5fd2:	75 05                	jne    5fd9 <cmd_parse_one_arg+0x7d>
				*(bool *)arg_element->dest = true;
    5fd4:	c6 00 01             	movb   $0x1,(%eax)
    5fd7:	eb 20                	jmp    5ff9 <cmd_parse_one_arg+0x9d>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
    5fd9:	83 ec 0c             	sub    $0xc,%esp
    5fdc:	68 44 99 00 00       	push   $0x9944
    5fe1:	e8 ff f8 ff ff       	call   58e5 <posix_print_error_and_exit>
    5fe6:	eb 0e                	jmp    5ff6 <cmd_parse_one_arg+0x9a>
			cmd_read_option_value(&argv[offset],
    5fe8:	ff 73 04             	pushl  0x4(%ebx)
    5feb:	52                   	push   %edx
    5fec:	50                   	push   %eax
    5fed:	8d 04 3e             	lea    (%esi,%edi,1),%eax
    5ff0:	50                   	push   %eax
    5ff1:	e8 18 fb ff ff       	call   5b0e <cmd_read_option_value>
    5ff6:	83 c4 10             	add    $0x10,%esp
	if (arg_element->call_when_found) {
    5ff9:	8b 43 14             	mov    0x14(%ebx),%eax
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
    5ffc:	b2 01                	mov    $0x1,%dl
	if (arg_element->call_when_found) {
    5ffe:	85 c0                	test   %eax,%eax
    6000:	74 0b                	je     600d <cmd_parse_one_arg+0xb1>
		arg_element->call_when_found(argv, offset);
    6002:	52                   	push   %edx
    6003:	52                   	push   %edx
    6004:	57                   	push   %edi
    6005:	56                   	push   %esi
    6006:	ff d0                	call   *%eax
    6008:	83 c4 10             	add    $0x10,%esp
			return true;
    600b:	b2 01                	mov    $0x1,%dl
		}
		count++;
	}
	return false;
}
    600d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6010:	88 d0                	mov    %dl,%al
    6012:	5b                   	pop    %ebx
    6013:	5e                   	pop    %esi
    6014:	5f                   	pop    %edi
    6015:	5d                   	pop    %ebp
    6016:	c3                   	ret    

00006017 <native_cleanup_cmd_line>:
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
    6017:	a1 54 da 00 00       	mov    0xda54,%eax
    601c:	85 c0                	test   %eax,%eax
    601e:	74 1b                	je     603b <native_cleanup_cmd_line+0x24>
{
    6020:	55                   	push   %ebp
    6021:	89 e5                	mov    %esp,%ebp
    6023:	83 ec 14             	sub    $0x14,%esp
		free(args_struct);
    6026:	50                   	push   %eax
    6027:	e8 fc ff ff ff       	call   6028 <native_cleanup_cmd_line+0x11>
    602c:	83 c4 10             	add    $0x10,%esp
		args_struct = NULL;
    602f:	c7 05 54 da 00 00 00 	movl   $0x0,0xda54
    6036:	00 00 00 
	}
}
    6039:	c9                   	leave  
    603a:	c3                   	ret    
    603b:	c3                   	ret    

0000603c <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
    603c:	55                   	push   %ebp
    603d:	89 e5                	mov    %esp,%ebp
    603f:	57                   	push   %edi
    6040:	56                   	push   %esi
    6041:	53                   	push   %ebx
	int count = 0;
    6042:	31 db                	xor    %ebx,%ebx
{
    6044:	83 ec 1c             	sub    $0x1c,%esp
    6047:	8b 75 08             	mov    0x8(%ebp),%esi

	while (args[count].option != NULL) {
    604a:	6b c3 1c             	imul   $0x1c,%ebx,%eax
    604d:	8d 7b 01             	lea    0x1(%ebx),%edi
    6050:	83 7c 06 04 00       	cmpl   $0x0,0x4(%esi,%eax,1)
    6055:	74 04                	je     605b <native_add_command_line_opts+0x1f>
    6057:	89 fb                	mov    %edi,%ebx
    6059:	eb ef                	jmp    604a <native_add_command_line_opts+0xe>
		count++;
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
    605b:	8b 15 50 da 00 00    	mov    0xda50,%edx
    6061:	a1 4c da 00 00       	mov    0xda4c,%eax
    6066:	01 fa                	add    %edi,%edx
    6068:	39 c2                	cmp    %eax,%edx
    606a:	7c 48                	jl     60b4 <native_add_command_line_opts+0x78>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
    606c:	83 ff 14             	cmp    $0x14,%edi
    606f:	ba 14 00 00 00       	mov    $0x14,%edx
    6074:	0f 4d d7             	cmovge %edi,%edx
    6077:	01 c2                	add    %eax,%edx
		struct args_struct_t *new_args_struct = realloc(args_struct,
    6079:	50                   	push   %eax
    607a:	50                   	push   %eax
    607b:	6b c2 1c             	imul   $0x1c,%edx,%eax
    607e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    6081:	50                   	push   %eax
    6082:	ff 35 54 da 00 00    	pushl  0xda54
    6088:	e8 fc ff ff ff       	call   6089 <native_add_command_line_opts+0x4d>
				      sizeof(struct args_struct_t));
		args_aval += growby;
    608d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		struct args_struct_t *new_args_struct = realloc(args_struct,
    6090:	83 c4 10             	add    $0x10,%esp
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
    6093:	85 c0                	test   %eax,%eax
		args_aval += growby;
    6095:	89 15 4c da 00 00    	mov    %edx,0xda4c
		if (new_args_struct == NULL) {
    609b:	75 12                	jne    60af <native_add_command_line_opts+0x73>
			posix_print_error_and_exit("Could not allocate memory");
    609d:	83 ec 0c             	sub    $0xc,%esp
    60a0:	68 8f 99 00 00       	push   $0x998f
    60a5:	e8 3b f8 ff ff       	call   58e5 <posix_print_error_and_exit>
    60aa:	83 c4 10             	add    $0x10,%esp
    60ad:	eb 05                	jmp    60b4 <native_add_command_line_opts+0x78>
		} else {
			args_struct = new_args_struct;
    60af:	a3 54 da 00 00       	mov    %eax,0xda54
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
    60b4:	8b 15 50 da 00 00    	mov    0xda50,%edx
    60ba:	6b cf 1c             	imul   $0x1c,%edi,%ecx
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
    60bd:	01 d3                	add    %edx,%ebx
	memcpy(&args_struct[used_args], args,
    60bf:	6b c2 1c             	imul   $0x1c,%edx,%eax
    60c2:	03 05 54 da 00 00    	add    0xda54,%eax
	used_args += count - 1;
    60c8:	89 1d 50 da 00 00    	mov    %ebx,0xda50
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
    60ce:	89 c7                	mov    %eax,%edi
    60d0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
    60d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
    60d5:	5b                   	pop    %ebx
    60d6:	5e                   	pop    %esi
    60d7:	5f                   	pop    %edi
    60d8:	5d                   	pop    %ebp
    60d9:	c3                   	ret    

000060da <native_add_testargs_option>:

void native_add_testargs_option(void)
{
    60da:	55                   	push   %ebp
    60db:	89 e5                	mov    %esp,%ebp
    60dd:	83 ec 14             	sub    $0x14,%esp
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
    60e0:	68 a0 c1 00 00       	push   $0xc1a0
    60e5:	e8 52 ff ff ff       	call   603c <native_add_command_line_opts>
    60ea:	83 c4 10             	add    $0x10,%esp
}
    60ed:	c9                   	leave  
    60ee:	c3                   	ret    

000060ef <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
    60ef:	55                   	push   %ebp
    60f0:	89 e5                	mov    %esp,%ebp
    60f2:	57                   	push   %edi
    60f3:	56                   	push   %esi
    60f4:	53                   	push   %ebx
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
    60f5:	bb 01 00 00 00       	mov    $0x1,%ebx
{
    60fa:	83 ec 0c             	sub    $0xc,%esp
    60fd:	8b 75 0c             	mov    0xc(%ebp),%esi
	native_add_tracing_options();
    6100:	e8 49 f8 ff ff       	call   594e <native_add_tracing_options>
	native_add_testargs_option();
    6105:	e8 d0 ff ff ff       	call   60da <native_add_testargs_option>
	s_argc = argc;
    610a:	8b 45 08             	mov    0x8(%ebp),%eax
	cmd_args_set_defaults(args_struct);
    610d:	83 ec 0c             	sub    $0xc,%esp
    6110:	ff 35 54 da 00 00    	pushl  0xda54
	s_argv = argv;
    6116:	89 35 5c da 00 00    	mov    %esi,0xda5c
	s_argc = argc;
    611c:	a3 64 da 00 00       	mov    %eax,0xda64
	cmd_args_set_defaults(args_struct);
    6121:	e8 82 fb ff ff       	call   5ca8 <cmd_args_set_defaults>
    6126:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
    6129:	3b 5d 08             	cmp    0x8(%ebp),%ebx
    612c:	7d 6d                	jge    619b <native_handle_cmd_line+0xac>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
    612e:	57                   	push   %edi
    612f:	6a 00                	push   $0x0
    6131:	8d 7b 01             	lea    0x1(%ebx),%edi
    6134:	68 a9 99 00 00       	push   $0x99a9
    6139:	ff 34 9e             	pushl  (%esi,%ebx,4)
    613c:	e8 cd f8 ff ff       	call   5a0e <cmd_is_option>
    6141:	83 c4 10             	add    $0x10,%esp
    6144:	85 c0                	test   %eax,%eax
    6146:	74 18                	je     6160 <native_handle_cmd_line+0x71>
			test_argc = argc - i - 1;
    6148:	8b 45 08             	mov    0x8(%ebp),%eax
    614b:	29 d8                	sub    %ebx,%eax
    614d:	89 c3                	mov    %eax,%ebx
			test_argv = &argv[i+1];
    614f:	8d 04 be             	lea    (%esi,%edi,4),%eax
			test_argc = argc - i - 1;
    6152:	4b                   	dec    %ebx
    6153:	89 1d 60 da 00 00    	mov    %ebx,0xda60
			test_argv = &argv[i+1];
    6159:	a3 58 da 00 00       	mov    %eax,0xda58
			break;
    615e:	eb 3b                	jmp    619b <native_handle_cmd_line+0xac>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
    6160:	51                   	push   %ecx
    6161:	51                   	push   %ecx
    6162:	ff 35 54 da 00 00    	pushl  0xda54
    6168:	ff 34 9e             	pushl  (%esi,%ebx,4)
    616b:	e8 ec fd ff ff       	call   5f5c <cmd_parse_one_arg>
    6170:	83 c4 10             	add    $0x10,%esp
    6173:	84 c0                	test   %al,%al
    6175:	75 20                	jne    6197 <native_handle_cmd_line+0xa8>
			cmd_print_switches_help(args_struct);
    6177:	83 ec 0c             	sub    $0xc,%esp
    617a:	ff 35 54 da 00 00    	pushl  0xda54
    6180:	e8 ca fb ff ff       	call   5d4f <cmd_print_switches_help>
    6185:	58                   	pop    %eax
    6186:	5a                   	pop    %edx
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
    6187:	ff 34 9e             	pushl  (%esi,%ebx,4)
    618a:	68 b2 99 00 00       	push   $0x99b2
    618f:	e8 51 f7 ff ff       	call   58e5 <posix_print_error_and_exit>
    6194:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
    6197:	89 fb                	mov    %edi,%ebx
    6199:	eb 8e                	jmp    6129 <native_handle_cmd_line+0x3a>
			print_invalid_opt_error(argv[i]);
		}
	}
}
    619b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    619e:	5b                   	pop    %ebx
    619f:	5e                   	pop    %esi
    61a0:	5f                   	pop    %edi
    61a1:	5d                   	pop    %ebp
    61a2:	c3                   	ret    

000061a3 <fixed_data_unref>:

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
}

static void fixed_data_unref(struct net_buf *buf, u8_t *data)
{
    61a3:	55                   	push   %ebp
    61a4:	89 e5                	mov    %esp,%ebp
	/* Nothing needed for fixed-size data pools */
}
    61a6:	5d                   	pop    %ebp
    61a7:	c3                   	ret    

000061a8 <net_buf_id>:
{
    61a8:	55                   	push   %ebp
    61a9:	89 e5                	mov    %esp,%ebp
    61ab:	8b 45 08             	mov    0x8(%ebp),%eax
}
    61ae:	5d                   	pop    %ebp
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    61af:	0f b6 50 06          	movzbl 0x6(%eax),%edx
	return buf - pool->__bufs;
    61b3:	6b d2 24             	imul   $0x24,%edx,%edx
    61b6:	2b 82 3c d4 00 00    	sub    0xd43c(%edx),%eax
    61bc:	c1 f8 03             	sar    $0x3,%eax
    61bf:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
}
    61c5:	c3                   	ret    

000061c6 <fixed_data_alloc>:
{
    61c6:	55                   	push   %ebp
    61c7:	89 e5                	mov    %esp,%ebp
    61c9:	53                   	push   %ebx
    61ca:	8b 5d 08             	mov    0x8(%ebp),%ebx
    61cd:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
    61d0:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
    61d4:	6b c0 24             	imul   $0x24,%eax,%eax
    61d7:	8b 80 38 d4 00 00    	mov    0xd438(%eax),%eax
    61dd:	8b 48 04             	mov    0x4(%eax),%ecx
	*size = MIN(fixed->data_size, *size);
    61e0:	8b 01                	mov    (%ecx),%eax
    61e2:	39 02                	cmp    %eax,(%edx)
    61e4:	0f 46 02             	cmovbe (%edx),%eax
    61e7:	89 02                	mov    %eax,(%edx)
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    61e9:	53                   	push   %ebx
    61ea:	e8 b9 ff ff ff       	call   61a8 <net_buf_id>
    61ef:	0f af 01             	imul   (%ecx),%eax
    61f2:	5a                   	pop    %edx
}
    61f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
    61f6:	03 41 04             	add    0x4(%ecx),%eax
}
    61f9:	c9                   	leave  
    61fa:	c3                   	ret    

000061fb <test_cb>:
	k_sem_init(&test_end_signal, 0, 1);
	k_object_access_all_grant(&test_end_signal);
}

static void test_cb(void *a, void *dummy2, void *dummy)
{
    61fb:	55                   	push   %ebp
    61fc:	89 e5                	mov    %esp,%ebp
    61fe:	53                   	push   %ebx
    61ff:	50                   	push   %eax
    6200:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct unit_test *test = (struct unit_test *)a;

	ARG_UNUSED(dummy2);
	ARG_UNUSED(dummy);

	test_result = 1;
    6203:	c7 05 78 da 00 00 01 	movl   $0x1,0xda78
    620a:	00 00 00 
	phase = TEST_PHASE_SETUP;
    620d:	c7 05 0c c2 00 00 00 	movl   $0x0,0xc20c
    6214:	00 00 00 
	test->setup();
    6217:	ff 53 08             	call   *0x8(%ebx)
	phase = TEST_PHASE_TEST;
    621a:	c7 05 0c c2 00 00 01 	movl   $0x1,0xc20c
    6221:	00 00 00 
	test->test();
    6224:	ff 53 04             	call   *0x4(%ebx)
	run_test_functions(test);
	test_result = 0;
    6227:	c7 05 78 da 00 00 00 	movl   $0x0,0xda78
    622e:	00 00 00 
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    6231:	c7 45 08 68 da 00 00 	movl   $0xda68,0x8(%ebp)

	k_sem_give(&test_end_signal);
}
    6238:	5a                   	pop    %edx
    6239:	5b                   	pop    %ebx
    623a:	5d                   	pop    %ebp
    623b:	e9 e4 1a 00 00       	jmp    7d24 <z_impl_k_sem_give>

00006240 <z_ztest_run_test_suite>:
}

#endif /* !KERNEL */

void z_ztest_run_test_suite(const char *name, struct unit_test *suite)
{
    6240:	55                   	push   %ebp
    6241:	89 e5                	mov    %esp,%ebp
    6243:	57                   	push   %edi
    6244:	56                   	push   %esi
    6245:	53                   	push   %ebx
    6246:	83 ec 1c             	sub    $0x1c,%esp
	int fail = 0;

	if (test_status < 0) {
    6249:	83 3d 7c da 00 00 00 	cmpl   $0x0,0xda7c
{
    6250:	8b 7d 08             	mov    0x8(%ebp),%edi
    6253:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	if (test_status < 0) {
    6256:	0f 88 2a 01 00 00    	js     6386 <z_ztest_run_test_suite+0x146>
	return z_impl_k_sem_init(sem, initial_count, limit);
    625c:	51                   	push   %ecx
    625d:	6a 01                	push   $0x1
    625f:	6a 00                	push   $0x0
    6261:	68 68 da 00 00       	push   $0xda68
    6266:	e8 8f 1a 00 00       	call   7cfa <z_impl_k_sem_init>
    626b:	5e                   	pop    %esi
    626c:	58                   	pop    %eax
		return;
	}

	init_testing();

	PRINT("Running test suite %s\n", name);
    626d:	57                   	push   %edi
    626e:	68 76 9a 00 00       	push   $0x9a76
	int fail = 0;
    6273:	31 f6                	xor    %esi,%esi
	PRINT("Running test suite %s\n", name);
    6275:	e8 15 dd ff ff       	call   3f8f <printk>
	PRINT_LINE;
    627a:	c7 04 24 8d 9a 00 00 	movl   $0x9a8d,(%esp)
    6281:	e8 09 dd ff ff       	call   3f8f <printk>
    6286:	83 c4 10             	add    $0x10,%esp
	while (suite->test) {
    6289:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
    628d:	0f 84 c5 00 00 00    	je     6358 <z_ztest_run_test_suite+0x118>
	TC_START(test->name);
    6293:	50                   	push   %eax
    6294:	50                   	push   %eax
    6295:	ff 33                	pushl  (%ebx)
    6297:	68 d2 9a 00 00       	push   $0x9ad2
    629c:	e8 ee dc ff ff       	call   3f8f <printk>
    62a1:	58                   	pop    %eax
			test->thread_options | K_INHERIT_PERMS,
    62a2:	8b 43 10             	mov    0x10(%ebx),%eax
	TC_START(test->name);
    62a5:	5a                   	pop    %edx
			test->thread_options | K_INHERIT_PERMS,
    62a6:	83 c8 08             	or     $0x8,%eax
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    62a9:	6a 00                	push   $0x0
    62ab:	50                   	push   %eax
    62ac:	6a ff                	push   $0xffffffff
    62ae:	6a 00                	push   $0x0
    62b0:	6a 00                	push   $0x0
    62b2:	53                   	push   %ebx
    62b3:	68 fb 61 00 00       	push   $0x61fb
    62b8:	68 00 04 00 00       	push   $0x400
    62bd:	68 80 c8 00 00       	push   $0xc880
    62c2:	68 40 d7 00 00       	push   $0xd740
    62c7:	e8 b5 1d 00 00       	call   8081 <z_impl_k_thread_create>
    62cc:	83 c4 28             	add    $0x28,%esp
	return z_impl_k_sem_take(sem, timeout);
    62cf:	6a ff                	push   $0xffffffff
    62d1:	68 68 da 00 00       	push   $0xda68
    62d6:	e8 fc 1a 00 00       	call   7dd7 <z_impl_k_sem_take>
    62db:	83 c4 10             	add    $0x10,%esp
	phase = TEST_PHASE_TEARDOWN;
    62de:	c7 05 0c c2 00 00 02 	movl   $0x2,0xc20c
    62e5:	00 00 00 
	test->teardown();
    62e8:	ff 53 0c             	call   *0xc(%ebx)
	int ret = TC_PASS;
    62eb:	31 c0                	xor    %eax,%eax
    62ed:	83 3d 78 da 00 00 ff 	cmpl   $0xffffffff,0xda78
	phase = TEST_PHASE_FRAMEWORK;
    62f4:	c7 05 0c c2 00 00 03 	movl   $0x3,0xc20c
    62fb:	00 00 00 
	int ret = TC_PASS;
    62fe:	0f 94 c0             	sete   %al
    6301:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	z_impl_k_thread_abort(thread);
    6304:	83 ec 0c             	sub    $0xc,%esp
    6307:	68 40 d7 00 00       	push   $0xd740
    630c:	e8 ec e2 ff ff       	call   45fd <z_impl_k_thread_abort>
    6311:	83 c4 10             	add    $0x10,%esp
	if (test_result == -2) {
    6314:	83 3d 78 da 00 00 fe 	cmpl   $0xfffffffe,0xda78
    631b:	75 0a                	jne    6327 <z_ztest_run_test_suite+0xe7>
		Z_TC_END_RESULT(TC_SKIP, test->name);
    631d:	50                   	push   %eax
    631e:	ff 33                	pushl  (%ebx)
    6320:	68 e6 9a 00 00       	push   $0x9ae6
    6325:	eb 0d                	jmp    6334 <z_ztest_run_test_suite+0xf4>
		Z_TC_END_RESULT(ret, test->name);
    6327:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    632a:	51                   	push   %ecx
    632b:	ff 33                	pushl  (%ebx)
    632d:	ff 34 85 10 8b 00 00 	pushl  0x8b10(,%eax,4)
    6334:	68 eb 9a 00 00       	push   $0x9aeb
		fail += run_test(suite);
		suite++;
    6339:	83 c3 14             	add    $0x14,%ebx
		Z_TC_END_RESULT(ret, test->name);
    633c:	e8 4e dc ff ff       	call   3f8f <printk>
    6341:	c7 04 24 8d 9a 00 00 	movl   $0x9a8d,(%esp)
    6348:	e8 42 dc ff ff       	call   3f8f <printk>
    634d:	83 c4 10             	add    $0x10,%esp
		fail += run_test(suite);
    6350:	03 75 e4             	add    -0x1c(%ebp),%esi
    6353:	e9 31 ff ff ff       	jmp    6289 <z_ztest_run_test_suite+0x49>

		if (fail && FAIL_FAST) {
			break;
		}
	}
	if (fail) {
    6358:	85 f6                	test   %esi,%esi
    635a:	74 0a                	je     6366 <z_ztest_run_test_suite+0x126>
		TC_PRINT("Test suite %s failed.\n", name);
    635c:	52                   	push   %edx
    635d:	52                   	push   %edx
    635e:	57                   	push   %edi
    635f:	68 f4 9a 00 00       	push   $0x9af4
    6364:	eb 08                	jmp    636e <z_ztest_run_test_suite+0x12e>
	} else {
		TC_PRINT("Test suite %s succeeded\n", name);
    6366:	50                   	push   %eax
    6367:	50                   	push   %eax
    6368:	57                   	push   %edi
    6369:	68 0b 9b 00 00       	push   $0x9b0b
    636e:	e8 1c dc ff ff       	call   3f8f <printk>
	}

	test_status = (test_status || fail) ? 1 : 0;
    6373:	31 c0                	xor    %eax,%eax
		TC_PRINT("Test suite %s succeeded\n", name);
    6375:	83 c4 10             	add    $0x10,%esp
	test_status = (test_status || fail) ? 1 : 0;
    6378:	0b 35 7c da 00 00    	or     0xda7c,%esi
    637e:	0f 95 c0             	setne  %al
    6381:	a3 7c da 00 00       	mov    %eax,0xda7c
}
    6386:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6389:	5b                   	pop    %ebx
    638a:	5e                   	pop    %esi
    638b:	5f                   	pop    %edi
    638c:	5d                   	pop    %ebp
    638d:	c3                   	ret    

0000638e <end_report>:

void end_report(void)
{
    638e:	55                   	push   %ebp
    638f:	89 e5                	mov    %esp,%ebp
    6391:	83 ec 08             	sub    $0x8,%esp
	if (test_status) {
    6394:	83 3d 7c da 00 00 00 	cmpl   $0x0,0xda7c
    639b:	74 27                	je     63c4 <end_report+0x36>
		TC_END_REPORT(TC_FAIL);
    639d:	83 ec 0c             	sub    $0xc,%esp
    63a0:	68 8d 9a 00 00       	push   $0x9a8d
    63a5:	e8 e5 db ff ff       	call   3f8f <printk>
    63aa:	59                   	pop    %ecx
    63ab:	58                   	pop    %eax
    63ac:	68 24 9b 00 00       	push   $0x9b24
    63b1:	68 2b 9b 00 00       	push   $0x9b2b
    63b6:	e8 d4 db ff ff       	call   3f8f <printk>
    63bb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    63c2:	eb 25                	jmp    63e9 <end_report+0x5b>
	} else {
		TC_END_REPORT(TC_PASS);
    63c4:	83 ec 0c             	sub    $0xc,%esp
    63c7:	68 8d 9a 00 00       	push   $0x9a8d
    63cc:	e8 be db ff ff       	call   3f8f <printk>
    63d1:	58                   	pop    %eax
    63d2:	5a                   	pop    %edx
    63d3:	68 41 9b 00 00       	push   $0x9b41
    63d8:	68 2b 9b 00 00       	push   $0x9b2b
    63dd:	e8 ad db ff ff       	call   3f8f <printk>
    63e2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    63e9:	e8 c6 f3 ff ff       	call   57b4 <posix_exit>
    63ee:	83 c4 10             	add    $0x10,%esp
	}
}
    63f1:	c9                   	leave  
    63f2:	c3                   	ret    

000063f3 <zephyr_app_main>:

	return test_status;
}
#else
void main(void)
{
    63f3:	55                   	push   %ebp
    63f4:	89 e5                	mov    %esp,%ebp
    63f6:	83 ec 08             	sub    $0x8,%esp
	k_mem_domain_init(&ztest_mem_domain, ARRAY_SIZE(parts), parts);
	k_mem_domain_add_thread(&ztest_mem_domain, k_current_get());
#endif /* CONFIG_USERSPACE */

	z_init_mock();
	test_main();
    63f9:	e8 e3 d2 ff ff       	call   36e1 <test_main>
		} else {
			PRINT("Failed after %u attempts\n", state.boots);
			state.boots = 0;
		}
	}
}
    63fe:	c9                   	leave  
	end_report();
    63ff:	e9 8a ff ff ff       	jmp    638e <end_report>

00006404 <_mbedtls_init>:
#else
#define init_heap(...)
#endif /* CONFIG_MBEDTLS_ENABLE_HEAP && MBEDTLS_MEMORY_BUFFER_ALLOC_C */

static int _mbedtls_init(struct device *device)
{
    6404:	55                   	push   %ebp
	ARG_UNUSED(device);

	init_heap();

	return 0;
}
    6405:	31 c0                	xor    %eax,%eax
{
    6407:	89 e5                	mov    %esp,%ebp
}
    6409:	5d                   	pop    %ebp
    640a:	c3                   	ret    

0000640b <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    640b:	55                   	push   %ebp
    640c:	89 e5                	mov    %esp,%ebp
    640e:	83 ec 10             	sub    $0x10,%esp
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
    6411:	6a 45                	push   $0x45
    6413:	68 56 9b 00 00       	push   $0x9b56
    6418:	e8 72 db ff ff       	call   3f8f <printk>
    641d:	58                   	pop    %eax
	arch_system_halt(reason);
    641e:	ff 75 08             	pushl  0x8(%ebp)
    6421:	e8 d0 dd ff ff       	call   41f6 <arch_system_halt>

00006426 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    6426:	55                   	push   %ebp
    6427:	89 e5                	mov    %esp,%ebp
    6429:	57                   	push   %edi
    642a:	56                   	push   %esi
    642b:	53                   	push   %ebx
    642c:	83 ec 1c             	sub    $0x1c,%esp
    642f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    6432:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
    6435:	e8 30 f0 ff ff       	call   546a <posix_irq_lock>
    643a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return z_impl_k_current_get();
    643d:	e8 ae 18 00 00       	call   7cf0 <z_impl_k_current_get>
    6442:	83 fb 04             	cmp    $0x4,%ebx
    6445:	89 c6                	mov    %eax,%esi
    6447:	b8 6a 9b 00 00       	mov    $0x9b6a,%eax
    644c:	77 07                	ja     6455 <z_fatal_error+0x2f>
    644e:	8b 04 9d 1c 8b 00 00 	mov    0x8b1c(,%ebx,4),%eax
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    6455:	83 ec 0c             	sub    $0xc,%esp
    6458:	6a 00                	push   $0x0
    645a:	50                   	push   %eax
    645b:	53                   	push   %ebx
    645c:	6a 45                	push   $0x45
    645e:	68 80 9b 00 00       	push   $0x9b80
    6463:	e8 27 db ff ff       	call   3f8f <printk>
    6468:	83 c4 14             	add    $0x14,%esp
	const char *thread_name = k_thread_name_get(thread);
    646b:	56                   	push   %esi
    646c:	e8 63 1b 00 00       	call   7fd4 <k_thread_name_get>
    6471:	83 c4 10             	add    $0x10,%esp
	if (thread_name == NULL || thread_name[0] == '\0') {
    6474:	85 c0                	test   %eax,%eax
    6476:	74 05                	je     647d <z_fatal_error+0x57>
    6478:	80 38 00             	cmpb   $0x0,(%eax)
    647b:	75 05                	jne    6482 <z_fatal_error+0x5c>
		thread_name = "unknown";
    647d:	b8 78 9b 00 00       	mov    $0x9b78,%eax
	if (arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    6482:	50                   	push   %eax
    6483:	56                   	push   %esi
    6484:	6a 45                	push   $0x45
    6486:	68 ad 9b 00 00       	push   $0x9bad
    648b:	e8 ff da ff ff       	call   3f8f <printk>
    6490:	58                   	pop    %eax
    6491:	5a                   	pop    %edx
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
    6492:	57                   	push   %edi
    6493:	53                   	push   %ebx
    6494:	e8 72 ff ff ff       	call   640b <k_sys_fatal_error_handler>
    6499:	59                   	pop    %ecx
	posix_irq_unlock(key);
    649a:	ff 75 e4             	pushl  -0x1c(%ebp)
    649d:	e8 da ef ff ff       	call   547c <posix_irq_unlock>
    64a2:	83 c4 10             	add    $0x10,%esp
	z_impl_k_thread_abort(thread);
    64a5:	89 75 08             	mov    %esi,0x8(%ebp)
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
    64a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
    64ab:	5b                   	pop    %ebx
    64ac:	5e                   	pop    %esi
    64ad:	5f                   	pop    %edi
    64ae:	5d                   	pop    %ebp
    64af:	e9 49 e1 ff ff       	jmp    45fd <z_impl_k_thread_abort>

000064b4 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
    64b4:	55                   	push   %ebp
    64b5:	89 e5                	mov    %esp,%ebp
    64b7:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
    64ba:	e8 ab ef ff ff       	call   546a <posix_irq_lock>
	s32_t ticks = z_get_next_timeout_expiry();
    64bf:	e8 8e 21 00 00       	call   8652 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    64c4:	83 f8 02             	cmp    $0x2,%eax
    64c7:	7f 05                	jg     64ce <idle+0x1a>
    64c9:	b8 01 00 00 00       	mov    $0x1,%eax
    64ce:	52                   	push   %edx
    64cf:	52                   	push   %edx
    64d0:	6a 01                	push   $0x1
    64d2:	50                   	push   %eax
    64d3:	e8 4a 22 00 00       	call   8722 <z_set_timeout_expiry>
    64d8:	83 c4 10             	add    $0x10,%esp
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    64db:	e8 05 dd ff ff       	call   41e5 <arch_cpu_idle>
    64e0:	eb d8                	jmp    64ba <idle+0x6>

000064e2 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    64e2:	55                   	push   %ebp
    64e3:	89 e5                	mov    %esp,%ebp
    64e5:	83 ec 14             	sub    $0x14,%esp
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
    64e8:	c6 05 a3 da 00 00 01 	movb   $0x1,0xdaa3

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
    64ef:	6a 02                	push   $0x2
    64f1:	e8 55 25 00 00       	call   8a4b <z_sys_device_do_config_level>
    64f6:	83 c4 0c             	add    $0xc,%esp
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    64f9:	68 24 9e 00 00       	push   $0x9e24
    64fe:	68 14 9c 00 00       	push   $0x9c14
    6503:	68 30 9c 00 00       	push   $0x9c30
    6508:	e8 82 da ff ff       	call   3f8f <printk>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
    650d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
    6514:	e8 32 25 00 00       	call   8a4b <z_sys_device_do_config_level>
    6519:	83 c4 10             	add    $0x10,%esp
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
    651c:	e8 0f 1c 00 00       	call   8130 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    6521:	e8 cd fe ff ff       	call   63f3 <zephyr_app_main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    6526:	80 25 4c d8 00 00 fe 	andb   $0xfe,0xd84c

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    652d:	c9                   	leave  
    652e:	c3                   	ret    

0000652f <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    652f:	55                   	push   %ebp

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
    6530:	b9 1a 00 00 00       	mov    $0x1a,%ecx
{
    6535:	89 e5                	mov    %esp,%ebp
    6537:	57                   	push   %edi
	struct k_thread dummy_thread = {
    6538:	8d 7d 8c             	lea    -0x74(%ebp),%edi
{
    653b:	83 c4 80             	add    $0xffffff80,%esp
    653e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    6544:	89 45 f4             	mov    %eax,-0xc(%ebp)
    6547:	31 c0                	xor    %eax,%eax
	struct k_thread dummy_thread = {
    6549:	f3 ab                	rep stos %eax,%es:(%edi)
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current_cpu->current = &dummy_thread;
    654b:	8d 45 8c             	lea    -0x74(%ebp),%eax
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    654e:	6a 00                	push   $0x0
	struct k_thread dummy_thread = {
    6550:	c6 45 99 01          	movb   $0x1,-0x67(%ebp)
	_current_cpu->current = &dummy_thread;
    6554:	a3 c8 d8 00 00       	mov    %eax,0xd8c8
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    6559:	e8 ed 24 00 00       	call   8a4b <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    655e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    6565:	e8 e1 24 00 00       	call   8a4b <z_sys_device_do_config_level>
    656a:	83 c4 10             	add    $0x10,%esp
	z_sched_init();
    656d:	e8 7e 15 00 00       	call   7af0 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
    6572:	50                   	push   %eax
    6573:	50                   	push   %eax
    6574:	68 57 9c 00 00       	push   $0x9c57
    6579:	6a 01                	push   $0x1
    657b:	6a 00                	push   $0x0
    657d:	6a 00                	push   $0x0
    657f:	6a 00                	push   $0x0
    6581:	6a 00                	push   $0x0
    6583:	68 e2 64 00 00       	push   $0x64e2
    6588:	68 00 02 00 00       	push   $0x200
    658d:	68 80 cd 00 00       	push   $0xcd80
    6592:	68 40 d8 00 00       	push   $0xd840
	_kernel.ready_q.cache = &z_main_thread;
    6597:	c7 05 e0 d8 00 00 40 	movl   $0xd840,0xd8e0
    659e:	d8 00 00 
	z_setup_new_thread(&z_main_thread, z_main_stack,
    65a1:	e8 75 1a 00 00       	call   801b <z_setup_new_thread>
    65a6:	83 c4 24             	add    $0x24,%esp
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    65a9:	80 25 4d d8 00 00 fb 	andb   $0xfb,0xd84d
	z_ready_thread(&z_main_thread);
    65b0:	68 40 d8 00 00       	push   $0xd840
    65b5:	e8 45 0b 00 00       	call   70ff <z_ready_thread>
    65ba:	5a                   	pop    %edx
    65bb:	59                   	pop    %ecx
	z_setup_new_thread(thread, stack,
    65bc:	68 5c 9c 00 00       	push   $0x9c5c
    65c1:	6a 01                	push   $0x1
    65c3:	6a 0f                	push   $0xf
    65c5:	6a 00                	push   $0x0
    65c7:	6a 00                	push   $0x0
    65c9:	6a 00                	push   $0x0
    65cb:	68 b4 64 00 00       	push   $0x64b4
    65d0:	68 00 01 00 00       	push   $0x100
    65d5:	68 80 cc 00 00       	push   $0xcc80
    65da:	68 c0 d7 00 00       	push   $0xd7c0
    65df:	e8 37 1a 00 00       	call   801b <z_setup_new_thread>
    65e4:	83 c4 30             	add    $0x30,%esp
    65e7:	80 25 cd d7 00 00 fb 	andb   $0xfb,0xd7cd
	_kernel.cpus[0].idle_thread = &z_idle_thread;
    65ee:	c7 05 cc d8 00 00 c0 	movl   $0xd7c0,0xd8cc
    65f5:	d7 00 00 
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
    65f8:	68 e2 64 00 00       	push   $0x64e2
    65fd:	68 00 02 00 00       	push   $0x200
    6602:	68 80 cd 00 00       	push   $0xcd80
    6607:	68 40 d8 00 00       	push   $0xd840
	list->head = (sys_dnode_t *)list;
    660c:	c7 05 d8 d8 00 00 d8 	movl   $0xd8d8,0xd8d8
    6613:	d8 00 00 
	list->tail = (sys_dnode_t *)list;
    6616:	c7 05 dc d8 00 00 d8 	movl   $0xd8d8,0xd8dc
    661d:	d8 00 00 
    6620:	e8 13 e1 ff ff       	call   4738 <arch_switch_to_main_thread>
    6625:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    6628:	68 a7 01 00 00       	push   $0x1a7
    662d:	68 61 9c 00 00       	push   $0x9c61
    6632:	68 70 8c 00 00       	push   $0x8c70
    6637:	e8 a9 f2 ff ff       	call   58e5 <posix_print_error_and_exit>
    663c:	83 c4 10             	add    $0x10,%esp

0000663f <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
    663f:	55                   	push   %ebp
    6640:	89 e5                	mov    %esp,%ebp
    6642:	53                   	push   %ebx
    6643:	51                   	push   %ecx
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    6644:	bb 08 d4 00 00       	mov    $0xd408,%ebx
    6649:	81 fb 08 d4 00 00    	cmp    $0xd408,%ebx
    664f:	76 33                	jbe    6684 <init_static_pools+0x45>
    6651:	6a 28                	push   $0x28
    6653:	68 94 9c 00 00       	push   $0x9c94
    6658:	68 c7 9c 00 00       	push   $0x9cc7
    665d:	68 e6 8b 00 00       	push   $0x8be6
    6662:	e8 28 d9 ff ff       	call   3f8f <printk>
    6667:	c7 04 24 e1 9c 00 00 	movl   $0x9ce1,(%esp)
    666e:	e8 1c d9 ff ff       	call   3f8f <printk>
    6673:	58                   	pop    %eax
    6674:	5a                   	pop    %edx
    6675:	6a 28                	push   $0x28
    6677:	68 94 9c 00 00       	push   $0x9c94
    667c:	e8 a2 d9 ff ff       	call   4023 <assert_post_action>
    6681:	83 c4 10             	add    $0x10,%esp
    6684:	81 fb 08 d4 00 00    	cmp    $0xd408,%ebx
    668a:	73 1a                	jae    66a6 <init_static_pools+0x67>
	z_sys_mem_pool_base_init(&p->base);
    668c:	83 ec 0c             	sub    $0xc,%esp
    668f:	8d 43 14             	lea    0x14(%ebx),%eax
    6692:	53                   	push   %ebx
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
    6693:	83 c3 1c             	add    $0x1c,%ebx
	list->head = (sys_dnode_t *)list;
    6696:	89 43 f8             	mov    %eax,-0x8(%ebx)
	list->tail = (sys_dnode_t *)list;
    6699:	89 43 fc             	mov    %eax,-0x4(%ebx)
	z_sys_mem_pool_base_init(&p->base);
    669c:	e8 9f d0 ff ff       	call   3740 <z_sys_mem_pool_base_init>
    66a1:	83 c4 10             	add    $0x10,%esp
    66a4:	eb a3                	jmp    6649 <init_static_pools+0xa>
		k_mem_pool_init(p);
	}

	return 0;
}
    66a6:	31 c0                	xor    %eax,%eax
    66a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    66ab:	c9                   	leave  
    66ac:	c3                   	ret    

000066ad <k_mem_pool_free_id>:

	return -EAGAIN;
}

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
    66ad:	55                   	push   %ebp
    66ae:	89 e5                	mov    %esp,%ebp
    66b0:	56                   	push   %esi
    66b1:	53                   	push   %ebx
    66b2:	8b 45 08             	mov    0x8(%ebp),%eax
    66b5:	0f b6 18             	movzbl (%eax),%ebx
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
    66b8:	52                   	push   %edx
    66b9:	8b 10                	mov    (%eax),%edx
    66bb:	c1 ea 0c             	shr    $0xc,%edx
    66be:	52                   	push   %edx
    66bf:	8a 40 01             	mov    0x1(%eax),%al
    66c2:	6b db 1c             	imul   $0x1c,%ebx,%ebx
    66c5:	83 e0 0f             	and    $0xf,%eax
    66c8:	50                   	push   %eax
    66c9:	8d 83 08 d4 00 00    	lea    0xd408(%ebx),%eax
    66cf:	50                   	push   %eax
    66d0:	e8 25 d1 ff ff       	call   37fa <z_sys_mem_pool_block_free>
    66d5:	83 c4 10             	add    $0x10,%esp
    66d8:	e8 8d ed ff ff       	call   546a <posix_irq_lock>
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    66dd:	83 ec 0c             	sub    $0xc,%esp
    66e0:	89 c6                	mov    %eax,%esi
    66e2:	68 80 da 00 00       	push   $0xda80
    66e7:	e8 67 1b 00 00       	call   8253 <z_spin_lock_valid>
    66ec:	83 c4 10             	add    $0x10,%esp
    66ef:	84 c0                	test   %al,%al
    66f1:	75 38                	jne    672b <k_mem_pool_free_id+0x7e>
    66f3:	6a 4a                	push   $0x4a
    66f5:	68 00 9d 00 00       	push   $0x9d00
    66fa:	68 35 9d 00 00       	push   $0x9d35
    66ff:	68 e6 8b 00 00       	push   $0x8be6
    6704:	e8 86 d8 ff ff       	call   3f8f <printk>
    6709:	58                   	pop    %eax
    670a:	5a                   	pop    %edx
    670b:	68 80 da 00 00       	push   $0xda80
    6710:	68 4a 9d 00 00       	push   $0x9d4a
    6715:	e8 75 d8 ff ff       	call   3f8f <printk>
    671a:	59                   	pop    %ecx
    671b:	58                   	pop    %eax
    671c:	6a 4a                	push   $0x4a
    671e:	68 00 9d 00 00       	push   $0x9d00
    6723:	e8 fb d8 ff ff       	call   4023 <assert_post_action>
    6728:	83 c4 10             	add    $0x10,%esp
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
    672b:	83 ec 0c             	sub    $0xc,%esp
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
    672e:	81 c3 1c d4 00 00    	add    $0xd41c,%ebx
    6734:	68 80 da 00 00       	push   $0xda80
    6739:	e8 57 1b 00 00       	call   8295 <z_spin_lock_set_owner>
    673e:	89 1c 24             	mov    %ebx,(%esp)
    6741:	e8 74 13 00 00       	call   7aba <z_unpend_all>
    6746:	83 c4 10             	add    $0x10,%esp

	if (need_sched != 0) {
    6749:	85 c0                	test   %eax,%eax
    674b:	74 17                	je     6764 <k_mem_pool_free_id+0xb7>
		z_reschedule(&lock, key);
    674d:	50                   	push   %eax
    674e:	50                   	push   %eax
    674f:	56                   	push   %esi
    6750:	68 80 da 00 00       	push   $0xda80
    6755:	e8 8e 03 00 00       	call   6ae8 <z_reschedule>
    675a:	83 c4 10             	add    $0x10,%esp
	} else {
		k_spin_unlock(&lock, key);
	}
}
    675d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6760:	5b                   	pop    %ebx
    6761:	5e                   	pop    %esi
    6762:	5d                   	pop    %ebp
    6763:	c3                   	ret    
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    6764:	83 ec 0c             	sub    $0xc,%esp
    6767:	68 80 da 00 00       	push   $0xda80
    676c:	e8 01 1b 00 00       	call   8272 <z_spin_unlock_valid>
    6771:	83 c4 10             	add    $0x10,%esp
    6774:	84 c0                	test   %al,%al
    6776:	75 38                	jne    67b0 <k_mem_pool_free_id+0x103>
    6778:	6a 5d                	push   $0x5d
    677a:	68 00 9d 00 00       	push   $0x9d00
    677f:	68 62 9d 00 00       	push   $0x9d62
    6784:	68 e6 8b 00 00       	push   $0x8be6
    6789:	e8 01 d8 ff ff       	call   3f8f <printk>
    678e:	58                   	pop    %eax
    678f:	5a                   	pop    %edx
    6790:	68 80 da 00 00       	push   $0xda80
    6795:	68 79 9d 00 00       	push   $0x9d79
    679a:	e8 f0 d7 ff ff       	call   3f8f <printk>
    679f:	59                   	pop    %ecx
    67a0:	5b                   	pop    %ebx
    67a1:	6a 5d                	push   $0x5d
    67a3:	68 00 9d 00 00       	push   $0x9d00
    67a8:	e8 76 d8 ff ff       	call   4023 <assert_post_action>
    67ad:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    67b0:	89 75 08             	mov    %esi,0x8(%ebp)
    67b3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    67b6:	5b                   	pop    %ebx
    67b7:	5e                   	pop    %esi
    67b8:	5d                   	pop    %ebp
    67b9:	e9 be ec ff ff       	jmp    547c <posix_irq_unlock>

000067be <k_free>:
	/* return address of the user area part of the block to the caller */
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
}

void k_free(void *ptr)
{
    67be:	55                   	push   %ebp
    67bf:	89 e5                	mov    %esp,%ebp
    67c1:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ptr != NULL) {
    67c4:	85 c0                	test   %eax,%eax
    67c6:	74 0c                	je     67d4 <k_free+0x16>
		/* point to hidden block descriptor at start of block */
		ptr = (char *)ptr - WB_UP(sizeof(struct k_mem_block_id));
    67c8:	83 e8 04             	sub    $0x4,%eax

		/* return block to the heap memory pool */
		k_mem_pool_free_id(ptr);
    67cb:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
    67ce:	5d                   	pop    %ebp
		k_mem_pool_free_id(ptr);
    67cf:	e9 d9 fe ff ff       	jmp    66ad <k_mem_pool_free_id>
}
    67d4:	5d                   	pop    %ebp
    67d5:	c3                   	ret    

000067d6 <z_queue_node_peek>:
	sys_sfnode_t node;
	void *data;
};

void *z_queue_node_peek(sys_sfnode_t *node, bool needs_free)
{
    67d6:	55                   	push   %ebp
    67d7:	89 e5                	mov    %esp,%ebp
    67d9:	53                   	push   %ebx
    67da:	50                   	push   %eax
    67db:	8b 45 08             	mov    0x8(%ebp),%eax
    67de:	8b 55 0c             	mov    0xc(%ebp),%edx
	void *ret;

	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
    67e1:	85 c0                	test   %eax,%eax
    67e3:	74 1a                	je     67ff <z_queue_node_peek+0x29>
    67e5:	f6 00 03             	testb  $0x3,(%eax)
    67e8:	74 15                	je     67ff <z_queue_node_peek+0x29>
		 */
		struct alloc_node *anode;

		anode = CONTAINER_OF(node, struct alloc_node, node);
		ret = anode->data;
		if (needs_free) {
    67ea:	84 d2                	test   %dl,%dl
		ret = anode->data;
    67ec:	8b 58 04             	mov    0x4(%eax),%ebx
		if (needs_free) {
    67ef:	74 0c                	je     67fd <z_queue_node_peek+0x27>
			k_free(anode);
    67f1:	83 ec 0c             	sub    $0xc,%esp
    67f4:	50                   	push   %eax
    67f5:	e8 c4 ff ff ff       	call   67be <k_free>
    67fa:	83 c4 10             	add    $0x10,%esp
		if (needs_free) {
    67fd:	89 d8                	mov    %ebx,%eax
		 */
		ret = (void *)node;
	}

	return ret;
}
    67ff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6802:	c9                   	leave  
    6803:	c3                   	ret    

00006804 <z_impl_k_queue_init>:
SYS_INIT(init_queue_module, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

#endif /* CONFIG_OBJECT_TRACING */

void z_impl_k_queue_init(struct k_queue *queue)
{
    6804:	55                   	push   %ebp
    6805:	89 e5                	mov    %esp,%ebp
    6807:	8b 45 08             	mov    0x8(%ebp),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    680a:	8d 50 0c             	lea    0xc(%eax),%edx
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_sflist_init(sys_sflist_t *list)
{
	list->head = NULL;
    680d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	list->tail = NULL;
    6813:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	sys_sflist_init(&queue->data_q);
	queue->lock = (struct k_spinlock) {};
    681a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	list->head = (sys_dnode_t *)list;
    6821:	89 50 0c             	mov    %edx,0xc(%eax)
	list->tail = (sys_dnode_t *)list;
    6824:	89 50 10             	mov    %edx,0x10(%eax)
	sys_dlist_init(&queue->poll_events);
#endif

	SYS_TRACING_OBJ_INIT(k_queue, queue);
	z_object_init(queue);
}
    6827:	5d                   	pop    %ebp
    6828:	c3                   	ret    

00006829 <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, s32_t timeout)
{
    6829:	55                   	push   %ebp
    682a:	89 e5                	mov    %esp,%ebp
    682c:	57                   	push   %edi
    682d:	56                   	push   %esi
    682e:	53                   	push   %ebx
    682f:	83 ec 0c             	sub    $0xc,%esp
    6832:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
    6835:	e8 30 ec ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    683a:	83 ec 0c             	sub    $0xc,%esp
    683d:	89 c7                	mov    %eax,%edi
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
    683f:	8d 5e 08             	lea    0x8(%esi),%ebx
    6842:	53                   	push   %ebx
    6843:	e8 0b 1a 00 00       	call   8253 <z_spin_lock_valid>
    6848:	83 c4 10             	add    $0x10,%esp
    684b:	84 c0                	test   %al,%al
    684d:	75 34                	jne    6883 <z_impl_k_queue_get+0x5a>
    684f:	6a 4a                	push   $0x4a
    6851:	68 00 9d 00 00       	push   $0x9d00
    6856:	68 35 9d 00 00       	push   $0x9d35
    685b:	68 e6 8b 00 00       	push   $0x8be6
    6860:	e8 2a d7 ff ff       	call   3f8f <printk>
    6865:	58                   	pop    %eax
    6866:	5a                   	pop    %edx
    6867:	53                   	push   %ebx
    6868:	68 4a 9d 00 00       	push   $0x9d4a
    686d:	e8 1d d7 ff ff       	call   3f8f <printk>
    6872:	59                   	pop    %ecx
    6873:	58                   	pop    %eax
    6874:	6a 4a                	push   $0x4a
    6876:	68 00 9d 00 00       	push   $0x9d00
    687b:	e8 a3 d7 ff ff       	call   4023 <assert_post_action>
    6880:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    6883:	83 ec 0c             	sub    $0xc,%esp
    6886:	53                   	push   %ebx
    6887:	e8 09 1a 00 00       	call   8295 <z_spin_lock_set_owner>
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
    688c:	8b 06                	mov    (%esi),%eax
    688e:	83 c4 10             	add    $0x10,%esp
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
    6891:	85 c0                	test   %eax,%eax
    6893:	74 6c                	je     6901 <z_impl_k_queue_get+0xd8>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
    6895:	8b 10                	mov    (%eax),%edx
    6897:	83 e2 fc             	and    $0xfffffffc,%edx
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    689a:	3b 46 04             	cmp    0x4(%esi),%eax
	list->head = node;
    689d:	89 16                	mov    %edx,(%esi)
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
    689f:	75 03                	jne    68a4 <z_impl_k_queue_get+0x7b>
	list->tail = node;
    68a1:	89 56 04             	mov    %edx,0x4(%esi)
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
    68a4:	56                   	push   %esi
    68a5:	56                   	push   %esi
    68a6:	6a 01                	push   $0x1
    68a8:	50                   	push   %eax
    68a9:	e8 28 ff ff ff       	call   67d6 <z_queue_node_peek>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    68ae:	89 1c 24             	mov    %ebx,(%esp)
    68b1:	89 c6                	mov    %eax,%esi
    68b3:	e8 ba 19 00 00       	call   8272 <z_spin_unlock_valid>
    68b8:	83 c4 10             	add    $0x10,%esp
    68bb:	84 c0                	test   %al,%al
    68bd:	75 34                	jne    68f3 <z_impl_k_queue_get+0xca>
    68bf:	6a 5d                	push   $0x5d
    68c1:	68 00 9d 00 00       	push   $0x9d00
    68c6:	68 62 9d 00 00       	push   $0x9d62
    68cb:	68 e6 8b 00 00       	push   $0x8be6
    68d0:	e8 ba d6 ff ff       	call   3f8f <printk>
    68d5:	58                   	pop    %eax
    68d6:	5a                   	pop    %edx
    68d7:	53                   	push   %ebx
    68d8:	68 79 9d 00 00       	push   $0x9d79
    68dd:	e8 ad d6 ff ff       	call   3f8f <printk>
    68e2:	59                   	pop    %ecx
    68e3:	5b                   	pop    %ebx
    68e4:	6a 5d                	push   $0x5d
    68e6:	68 00 9d 00 00       	push   $0x9d00
    68eb:	e8 33 d7 ff ff       	call   4023 <assert_post_action>
    68f0:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    68f3:	83 ec 0c             	sub    $0xc,%esp
    68f6:	57                   	push   %edi
    68f7:	e8 80 eb ff ff       	call   547c <posix_irq_unlock>
    68fc:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&queue->lock, key);
		return data;
    68ff:	eb 79                	jmp    697a <z_impl_k_queue_get+0x151>
	}

	if (timeout == K_NO_WAIT) {
    6901:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    6905:	75 54                	jne    695b <z_impl_k_queue_get+0x132>
    6907:	83 ec 0c             	sub    $0xc,%esp
    690a:	53                   	push   %ebx
    690b:	e8 62 19 00 00       	call   8272 <z_spin_unlock_valid>
    6910:	83 c4 10             	add    $0x10,%esp
    6913:	84 c0                	test   %al,%al
    6915:	75 34                	jne    694b <z_impl_k_queue_get+0x122>
    6917:	6a 5d                	push   $0x5d
    6919:	68 00 9d 00 00       	push   $0x9d00
    691e:	68 62 9d 00 00       	push   $0x9d62
    6923:	68 e6 8b 00 00       	push   $0x8be6
    6928:	e8 62 d6 ff ff       	call   3f8f <printk>
    692d:	58                   	pop    %eax
    692e:	5a                   	pop    %edx
    692f:	53                   	push   %ebx
    6930:	68 79 9d 00 00       	push   $0x9d79
    6935:	e8 55 d6 ff ff       	call   3f8f <printk>
    693a:	59                   	pop    %ecx
    693b:	5b                   	pop    %ebx
    693c:	6a 5d                	push   $0x5d
    693e:	68 00 9d 00 00       	push   $0x9d00
    6943:	e8 db d6 ff ff       	call   4023 <assert_post_action>
    6948:	83 c4 10             	add    $0x10,%esp
    694b:	83 ec 0c             	sub    $0xc,%esp
		k_spin_unlock(&queue->lock, key);
		return NULL;
    694e:	31 f6                	xor    %esi,%esi
    6950:	57                   	push   %edi
    6951:	e8 26 eb ff ff       	call   547c <posix_irq_unlock>
    6956:	83 c4 10             	add    $0x10,%esp
    6959:	eb 1f                	jmp    697a <z_impl_k_queue_get+0x151>
	k_spin_unlock(&queue->lock, key);

	return k_queue_poll(queue, timeout);

#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
    695b:	83 c6 0c             	add    $0xc,%esi
    695e:	ff 75 0c             	pushl  0xc(%ebp)
    6961:	56                   	push   %esi
    6962:	57                   	push   %edi

	return (ret != 0) ? NULL : _current->base.swap_data;
    6963:	31 f6                	xor    %esi,%esi
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
    6965:	53                   	push   %ebx
    6966:	e8 29 0f 00 00       	call   7894 <z_pend_curr>
    696b:	83 c4 10             	add    $0x10,%esp
	return (ret != 0) ? NULL : _current->base.swap_data;
    696e:	85 c0                	test   %eax,%eax
    6970:	75 08                	jne    697a <z_impl_k_queue_get+0x151>
    6972:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
    6977:	8b 70 14             	mov    0x14(%eax),%esi
#endif /* CONFIG_POLL */
}
    697a:	8d 65 f4             	lea    -0xc(%ebp),%esp
    697d:	89 f0                	mov    %esi,%eax
    697f:	5b                   	pop    %ebx
    6980:	5e                   	pop    %esi
    6981:	5f                   	pop    %edi
    6982:	5d                   	pop    %ebp
    6983:	c3                   	ret    

00006984 <pended_on.isra.18>:
	if (thread == _current) {
		z_reschedule_unlocked();
	}
}

static _wait_q_t *pended_on(struct k_thread *thread)
    6984:	55                   	push   %ebp
    6985:	89 e5                	mov    %esp,%ebp
    6987:	53                   	push   %ebx
    6988:	51                   	push   %ecx
{
	__ASSERT_NO_MSG(thread->base.pended_on);
    6989:	83 38 00             	cmpl   $0x0,(%eax)
static _wait_q_t *pended_on(struct k_thread *thread)
    698c:	89 c3                	mov    %eax,%ebx
	__ASSERT_NO_MSG(thread->base.pended_on);
    698e:	75 2d                	jne    69bd <pended_on.isra.18+0x39>
    6990:	68 bd 01 00 00       	push   $0x1bd
    6995:	68 8e 9d 00 00       	push   $0x9d8e
    699a:	68 bf 9d 00 00       	push   $0x9dbf
    699f:	68 e6 8b 00 00       	push   $0x8be6
    69a4:	e8 e6 d5 ff ff       	call   3f8f <printk>
    69a9:	58                   	pop    %eax
    69aa:	5a                   	pop    %edx
    69ab:	68 bd 01 00 00       	push   $0x1bd
    69b0:	68 8e 9d 00 00       	push   $0x9d8e
    69b5:	e8 69 d6 ff ff       	call   4023 <assert_post_action>
    69ba:	83 c4 10             	add    $0x10,%esp

	return thread->base.pended_on;
    69bd:	8b 03                	mov    (%ebx),%eax
}
    69bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    69c2:	c9                   	leave  
    69c3:	c3                   	ret    

000069c4 <z_reset_time_slice>:
	if (slice_time != 0) {
    69c4:	83 3d 88 da 00 00 00 	cmpl   $0x0,0xda88
    69cb:	74 27                	je     69f4 <z_reset_time_slice+0x30>
{
    69cd:	55                   	push   %ebp
    69ce:	89 e5                	mov    %esp,%ebp
    69d0:	83 ec 08             	sub    $0x8,%esp
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    69d3:	e8 de d7 ff ff       	call   41b6 <z_clock_elapsed>
    69d8:	8b 15 88 da 00 00    	mov    0xda88,%edx
		z_set_timeout_expiry(slice_time, false);
    69de:	51                   	push   %ecx
    69df:	51                   	push   %ecx
    69e0:	6a 00                	push   $0x0
    69e2:	52                   	push   %edx
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    69e3:	01 d0                	add    %edx,%eax
    69e5:	a3 d0 d8 00 00       	mov    %eax,0xd8d0
		z_set_timeout_expiry(slice_time, false);
    69ea:	e8 33 1d 00 00       	call   8722 <z_set_timeout_expiry>
    69ef:	83 c4 10             	add    $0x10,%esp
}
    69f2:	c9                   	leave  
    69f3:	c3                   	ret    
    69f4:	c3                   	ret    

000069f5 <k_sched_time_slice_set>:
{
    69f5:	55                   	push   %ebp
    69f6:	89 e5                	mov    %esp,%ebp
    69f8:	57                   	push   %edi
    69f9:	56                   	push   %esi
    69fa:	53                   	push   %ebx
    69fb:	83 ec 0c             	sub    $0xc,%esp
    69fe:	8b 7d 08             	mov    0x8(%ebp),%edi
    6a01:	8b 75 0c             	mov    0xc(%ebp),%esi
	return posix_irq_lock();
    6a04:	e8 61 ea ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    6a09:	83 ec 0c             	sub    $0xc,%esp
    6a0c:	89 c3                	mov    %eax,%ebx
    6a0e:	68 8c da 00 00       	push   $0xda8c
    6a13:	e8 3b 18 00 00       	call   8253 <z_spin_lock_valid>
    6a18:	83 c4 10             	add    $0x10,%esp
    6a1b:	84 c0                	test   %al,%al
    6a1d:	75 38                	jne    6a57 <k_sched_time_slice_set+0x62>
    6a1f:	6a 4a                	push   $0x4a
    6a21:	68 00 9d 00 00       	push   $0x9d00
    6a26:	68 35 9d 00 00       	push   $0x9d35
    6a2b:	68 e6 8b 00 00       	push   $0x8be6
    6a30:	e8 5a d5 ff ff       	call   3f8f <printk>
    6a35:	58                   	pop    %eax
    6a36:	5a                   	pop    %edx
    6a37:	68 8c da 00 00       	push   $0xda8c
    6a3c:	68 4a 9d 00 00       	push   $0x9d4a
    6a41:	e8 49 d5 ff ff       	call   3f8f <printk>
    6a46:	59                   	pop    %ecx
    6a47:	58                   	pop    %eax
    6a48:	6a 4a                	push   $0x4a
    6a4a:	68 00 9d 00 00       	push   $0x9d00
    6a4f:	e8 cf d5 ff ff       	call   4023 <assert_post_action>
    6a54:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    6a57:	83 ec 0c             	sub    $0xc,%esp
    6a5a:	68 8c da 00 00       	push   $0xda8c
    6a5f:	e8 31 18 00 00       	call   8295 <z_spin_lock_set_owner>
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
		if (result32) {
			return ((u32_t)t) / (from_hz / to_hz);
    6a64:	8d 47 09             	lea    0x9(%edi),%eax
    6a67:	b9 0a 00 00 00       	mov    $0xa,%ecx
    6a6c:	31 d2                	xor    %edx,%edx
    6a6e:	83 c4 10             	add    $0x10,%esp
		_current_cpu->slice_ticks = 0;
    6a71:	c7 05 d0 d8 00 00 00 	movl   $0x0,0xd8d0
    6a78:	00 00 00 
		slice_max_prio = prio;
    6a7b:	89 35 84 da 00 00    	mov    %esi,0xda84
    6a81:	f7 f1                	div    %ecx
		slice_time = k_ms_to_ticks_ceil32(slice);
    6a83:	a3 88 da 00 00       	mov    %eax,0xda88
		z_reset_time_slice();
    6a88:	e8 37 ff ff ff       	call   69c4 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    6a8d:	83 ec 0c             	sub    $0xc,%esp
    6a90:	68 8c da 00 00       	push   $0xda8c
    6a95:	e8 d8 17 00 00       	call   8272 <z_spin_unlock_valid>
    6a9a:	83 c4 10             	add    $0x10,%esp
    6a9d:	84 c0                	test   %al,%al
    6a9f:	75 38                	jne    6ad9 <k_sched_time_slice_set+0xe4>
    6aa1:	6a 5d                	push   $0x5d
    6aa3:	68 00 9d 00 00       	push   $0x9d00
    6aa8:	68 62 9d 00 00       	push   $0x9d62
    6aad:	68 e6 8b 00 00       	push   $0x8be6
    6ab2:	e8 d8 d4 ff ff       	call   3f8f <printk>
    6ab7:	58                   	pop    %eax
    6ab8:	5a                   	pop    %edx
    6ab9:	68 8c da 00 00       	push   $0xda8c
    6abe:	68 79 9d 00 00       	push   $0x9d79
    6ac3:	e8 c7 d4 ff ff       	call   3f8f <printk>
    6ac8:	59                   	pop    %ecx
    6ac9:	5e                   	pop    %esi
    6aca:	6a 5d                	push   $0x5d
    6acc:	68 00 9d 00 00       	push   $0x9d00
    6ad1:	e8 4d d5 ff ff       	call   4023 <assert_post_action>
    6ad6:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    6ad9:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    6adc:	8d 65 f4             	lea    -0xc(%ebp),%esp
    6adf:	5b                   	pop    %ebx
    6ae0:	5e                   	pop    %esi
    6ae1:	5f                   	pop    %edi
    6ae2:	5d                   	pop    %ebp
    6ae3:	e9 94 e9 ff ff       	jmp    547c <posix_irq_unlock>

00006ae8 <z_reschedule>:

	return arch_irq_unlocked(key) && !arch_is_in_isr();
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    6ae8:	55                   	push   %ebp
    6ae9:	89 e5                	mov    %esp,%ebp
    6aeb:	56                   	push   %esi
    6aec:	53                   	push   %ebx
    6aed:	8b 75 0c             	mov    0xc(%ebp),%esi
    6af0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    6af3:	85 f6                	test   %esi,%esi
    6af5:	75 5f                	jne    6b56 <z_reschedule+0x6e>
    6af7:	83 3d c0 d8 00 00 00 	cmpl   $0x0,0xd8c0
    6afe:	75 56                	jne    6b56 <z_reschedule+0x6e>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    6b00:	83 ec 0c             	sub    $0xc,%esp
    6b03:	53                   	push   %ebx
    6b04:	e8 69 17 00 00       	call   8272 <z_spin_unlock_valid>
    6b09:	83 c4 10             	add    $0x10,%esp
    6b0c:	84 c0                	test   %al,%al
    6b0e:	75 34                	jne    6b44 <z_reschedule+0x5c>
    6b10:	6a 74                	push   $0x74
    6b12:	68 00 9d 00 00       	push   $0x9d00
    6b17:	68 62 9d 00 00       	push   $0x9d62
    6b1c:	68 e6 8b 00 00       	push   $0x8be6
    6b21:	e8 69 d4 ff ff       	call   3f8f <printk>
    6b26:	5e                   	pop    %esi
    6b27:	58                   	pop    %eax
    6b28:	53                   	push   %ebx
    6b29:	68 79 9d 00 00       	push   $0x9d79
    6b2e:	e8 5c d4 ff ff       	call   3f8f <printk>
    6b33:	58                   	pop    %eax
    6b34:	5a                   	pop    %edx
    6b35:	6a 74                	push   $0x74
    6b37:	68 00 9d 00 00       	push   $0x9d00
    6b3c:	e8 e2 d4 ff ff       	call   4023 <assert_post_action>
    6b41:	83 c4 10             	add    $0x10,%esp
    6b44:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
	if (resched(key.key)) {
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
    6b4b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6b4e:	5b                   	pop    %ebx
    6b4f:	5e                   	pop    %esi
    6b50:	5d                   	pop    %ebp
    6b51:	e9 92 db ff ff       	jmp    46e8 <arch_swap>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    6b56:	83 ec 0c             	sub    $0xc,%esp
    6b59:	53                   	push   %ebx
    6b5a:	e8 13 17 00 00       	call   8272 <z_spin_unlock_valid>
    6b5f:	83 c4 10             	add    $0x10,%esp
    6b62:	84 c0                	test   %al,%al
    6b64:	75 34                	jne    6b9a <z_reschedule+0xb2>
    6b66:	6a 5d                	push   $0x5d
    6b68:	68 00 9d 00 00       	push   $0x9d00
    6b6d:	68 62 9d 00 00       	push   $0x9d62
    6b72:	68 e6 8b 00 00       	push   $0x8be6
    6b77:	e8 13 d4 ff ff       	call   3f8f <printk>
    6b7c:	58                   	pop    %eax
    6b7d:	5a                   	pop    %edx
    6b7e:	53                   	push   %ebx
    6b7f:	68 79 9d 00 00       	push   $0x9d79
    6b84:	e8 06 d4 ff ff       	call   3f8f <printk>
    6b89:	59                   	pop    %ecx
    6b8a:	5b                   	pop    %ebx
    6b8b:	6a 5d                	push   $0x5d
    6b8d:	68 00 9d 00 00       	push   $0x9d00
    6b92:	e8 8c d4 ff ff       	call   4023 <assert_post_action>
    6b97:	83 c4 10             	add    $0x10,%esp
    6b9a:	89 75 08             	mov    %esi,0x8(%ebp)
    6b9d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6ba0:	5b                   	pop    %ebx
    6ba1:	5e                   	pop    %esi
    6ba2:	5d                   	pop    %ebp
    6ba3:	e9 d4 e8 ff ff       	jmp    547c <posix_irq_unlock>

00006ba8 <z_reschedule_irqlock>:

void z_reschedule_irqlock(u32_t key)
{
    6ba8:	55                   	push   %ebp
    6ba9:	89 e5                	mov    %esp,%ebp
    6bab:	8b 45 08             	mov    0x8(%ebp),%eax
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    6bae:	85 c0                	test   %eax,%eax
    6bb0:	75 0f                	jne    6bc1 <z_reschedule_irqlock+0x19>
    6bb2:	83 3d c0 d8 00 00 00 	cmpl   $0x0,0xd8c0
    6bb9:	75 06                	jne    6bc1 <z_reschedule_irqlock+0x19>
	if (resched(key)) {
		z_swap_irqlock(key);
	} else {
		irq_unlock(key);
	}
}
    6bbb:	5d                   	pop    %ebp
    6bbc:	e9 27 db ff ff       	jmp    46e8 <arch_swap>
    6bc1:	89 45 08             	mov    %eax,0x8(%ebp)
    6bc4:	5d                   	pop    %ebp
    6bc5:	e9 b2 e8 ff ff       	jmp    547c <posix_irq_unlock>

00006bca <z_reschedule_unlocked>:
{
    6bca:	55                   	push   %ebp
    6bcb:	89 e5                	mov    %esp,%ebp
    6bcd:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
    6bd0:	e8 95 e8 ff ff       	call   546a <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
    6bd5:	83 ec 0c             	sub    $0xc,%esp
    6bd8:	50                   	push   %eax
    6bd9:	e8 ca ff ff ff       	call   6ba8 <z_reschedule_irqlock>
    6bde:	83 c4 10             	add    $0x10,%esp
}
    6be1:	c9                   	leave  
    6be2:	c3                   	ret    

00006be3 <k_sched_lock>:

void k_sched_lock(void)
{
    6be3:	55                   	push   %ebp
    6be4:	89 e5                	mov    %esp,%ebp
    6be6:	53                   	push   %ebx
    6be7:	50                   	push   %eax
    6be8:	e8 7d e8 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    6bed:	83 ec 0c             	sub    $0xc,%esp
    6bf0:	89 c3                	mov    %eax,%ebx
    6bf2:	68 8c da 00 00       	push   $0xda8c
    6bf7:	e8 57 16 00 00       	call   8253 <z_spin_lock_valid>
    6bfc:	83 c4 10             	add    $0x10,%esp
    6bff:	84 c0                	test   %al,%al
    6c01:	75 38                	jne    6c3b <k_sched_lock+0x58>
    6c03:	6a 4a                	push   $0x4a
    6c05:	68 00 9d 00 00       	push   $0x9d00
    6c0a:	68 35 9d 00 00       	push   $0x9d35
    6c0f:	68 e6 8b 00 00       	push   $0x8be6
    6c14:	e8 76 d3 ff ff       	call   3f8f <printk>
    6c19:	58                   	pop    %eax
    6c1a:	5a                   	pop    %edx
    6c1b:	68 8c da 00 00       	push   $0xda8c
    6c20:	68 4a 9d 00 00       	push   $0x9d4a
    6c25:	e8 65 d3 ff ff       	call   3f8f <printk>
    6c2a:	59                   	pop    %ecx
    6c2b:	58                   	pop    %eax
    6c2c:	6a 4a                	push   $0x4a
    6c2e:	68 00 9d 00 00       	push   $0x9d00
    6c33:	e8 eb d3 ff ff       	call   4023 <assert_post_action>
    6c38:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    6c3b:	83 ec 0c             	sub    $0xc,%esp
    6c3e:	68 8c da 00 00       	push   $0xda8c
    6c43:	e8 4d 16 00 00       	call   8295 <z_spin_lock_set_owner>
    6c48:	83 c4 10             	add    $0x10,%esp
}

static inline void z_sched_lock(void)
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
    6c4b:	83 3d c0 d8 00 00 00 	cmpl   $0x0,0xd8c0
    6c52:	74 39                	je     6c8d <k_sched_lock+0xaa>
    6c54:	68 06 01 00 00       	push   $0x106
    6c59:	68 d6 9d 00 00       	push   $0x9dd6
    6c5e:	68 10 9e 00 00       	push   $0x9e10
    6c63:	68 e6 8b 00 00       	push   $0x8be6
    6c68:	e8 22 d3 ff ff       	call   3f8f <printk>
    6c6d:	c7 04 24 22 9e 00 00 	movl   $0x9e22,(%esp)
    6c74:	e8 16 d3 ff ff       	call   3f8f <printk>
    6c79:	59                   	pop    %ecx
    6c7a:	58                   	pop    %eax
    6c7b:	68 06 01 00 00       	push   $0x106
    6c80:	68 d6 9d 00 00       	push   $0x9dd6
    6c85:	e8 99 d3 ff ff       	call   4023 <assert_post_action>
    6c8a:	83 c4 10             	add    $0x10,%esp
	__ASSERT(_current->base.sched_locked != 1, "");
    6c8d:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
    6c92:	80 78 0f 01          	cmpb   $0x1,0xf(%eax)
    6c96:	75 39                	jne    6cd1 <k_sched_lock+0xee>
    6c98:	68 07 01 00 00       	push   $0x107
    6c9d:	68 d6 9d 00 00       	push   $0x9dd6
    6ca2:	68 25 9e 00 00       	push   $0x9e25
    6ca7:	68 e6 8b 00 00       	push   $0x8be6
    6cac:	e8 de d2 ff ff       	call   3f8f <printk>
    6cb1:	c7 04 24 22 9e 00 00 	movl   $0x9e22,(%esp)
    6cb8:	e8 d2 d2 ff ff       	call   3f8f <printk>
    6cbd:	58                   	pop    %eax
    6cbe:	5a                   	pop    %edx
    6cbf:	68 07 01 00 00       	push   $0x107
    6cc4:	68 d6 9d 00 00       	push   $0x9dd6
    6cc9:	e8 55 d3 ff ff       	call   4023 <assert_post_action>
    6cce:	83 c4 10             	add    $0x10,%esp

	--_current->base.sched_locked;
    6cd1:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
    6cd6:	fe 48 0f             	decb   0xf(%eax)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    6cd9:	83 ec 0c             	sub    $0xc,%esp
    6cdc:	68 8c da 00 00       	push   $0xda8c
    6ce1:	e8 8c 15 00 00       	call   8272 <z_spin_unlock_valid>
    6ce6:	83 c4 10             	add    $0x10,%esp
    6ce9:	84 c0                	test   %al,%al
    6ceb:	75 38                	jne    6d25 <k_sched_lock+0x142>
    6ced:	6a 5d                	push   $0x5d
    6cef:	68 00 9d 00 00       	push   $0x9d00
    6cf4:	68 62 9d 00 00       	push   $0x9d62
    6cf9:	68 e6 8b 00 00       	push   $0x8be6
    6cfe:	e8 8c d2 ff ff       	call   3f8f <printk>
    6d03:	58                   	pop    %eax
    6d04:	5a                   	pop    %edx
    6d05:	68 8c da 00 00       	push   $0xda8c
    6d0a:	68 79 9d 00 00       	push   $0x9d79
    6d0f:	e8 7b d2 ff ff       	call   3f8f <printk>
    6d14:	59                   	pop    %ecx
    6d15:	58                   	pop    %eax
    6d16:	6a 5d                	push   $0x5d
    6d18:	68 00 9d 00 00       	push   $0x9d00
    6d1d:	e8 01 d3 ff ff       	call   4023 <assert_post_action>
    6d22:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    6d25:	83 ec 0c             	sub    $0xc,%esp
    6d28:	53                   	push   %ebx
    6d29:	e8 4e e7 ff ff       	call   547c <posix_irq_unlock>
    6d2e:	83 c4 10             	add    $0x10,%esp
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    6d31:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6d34:	c9                   	leave  
    6d35:	c3                   	ret    

00006d36 <z_priq_dumb_remove>:

	sys_dlist_append(pq, &thread->base.qnode_dlist);
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
    6d36:	55                   	push   %ebp
    6d37:	89 e5                	mov    %esp,%ebp
    6d39:	53                   	push   %ebx
    6d3a:	51                   	push   %ecx
    6d3b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	    z_is_thread_prevented_from_running(thread)) {
		return;
	}
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    6d3e:	81 fb c0 d7 00 00    	cmp    $0xd7c0,%ebx
    6d44:	75 2d                	jne    6d73 <z_priq_dumb_remove+0x3d>
    6d46:	68 32 03 00 00       	push   $0x332
    6d4b:	68 8e 9d 00 00       	push   $0x9d8e
    6d50:	68 4d 9e 00 00       	push   $0x9e4d
    6d55:	68 e6 8b 00 00       	push   $0x8be6
    6d5a:	e8 30 d2 ff ff       	call   3f8f <printk>
    6d5f:	58                   	pop    %eax
    6d60:	5a                   	pop    %edx
    6d61:	68 32 03 00 00       	push   $0x332
    6d66:	68 8e 9d 00 00       	push   $0x9d8e
    6d6b:	e8 b3 d2 ff ff       	call   4023 <assert_post_action>
    6d70:	83 c4 10             	add    $0x10,%esp
	node->prev->next = node->next;
    6d73:	8b 13                	mov    (%ebx),%edx
    6d75:	8b 43 04             	mov    0x4(%ebx),%eax
    6d78:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
    6d7a:	8b 13                	mov    (%ebx),%edx
    6d7c:	89 42 04             	mov    %eax,0x4(%edx)
	node->next = NULL;
    6d7f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	node->prev = NULL;
    6d85:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    6d8c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6d8f:	c9                   	leave  
    6d90:	c3                   	ret    

00006d91 <z_unpend_thread>:
{
    6d91:	55                   	push   %ebp
    6d92:	89 e5                	mov    %esp,%ebp
    6d94:	56                   	push   %esi
    6d95:	53                   	push   %ebx
    6d96:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
    6d99:	e8 cc e6 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    6d9e:	83 ec 0c             	sub    $0xc,%esp
    6da1:	89 c6                	mov    %eax,%esi
    6da3:	68 8c da 00 00       	push   $0xda8c
    6da8:	e8 a6 14 00 00       	call   8253 <z_spin_lock_valid>
    6dad:	83 c4 10             	add    $0x10,%esp
    6db0:	84 c0                	test   %al,%al
    6db2:	75 38                	jne    6dec <z_unpend_thread+0x5b>
    6db4:	6a 4a                	push   $0x4a
    6db6:	68 00 9d 00 00       	push   $0x9d00
    6dbb:	68 35 9d 00 00       	push   $0x9d35
    6dc0:	68 e6 8b 00 00       	push   $0x8be6
    6dc5:	e8 c5 d1 ff ff       	call   3f8f <printk>
    6dca:	59                   	pop    %ecx
    6dcb:	58                   	pop    %eax
    6dcc:	68 8c da 00 00       	push   $0xda8c
    6dd1:	68 4a 9d 00 00       	push   $0x9d4a
    6dd6:	e8 b4 d1 ff ff       	call   3f8f <printk>
    6ddb:	58                   	pop    %eax
    6ddc:	5a                   	pop    %edx
    6ddd:	6a 4a                	push   $0x4a
    6ddf:	68 00 9d 00 00       	push   $0x9d00
    6de4:	e8 3a d2 ff ff       	call   4023 <assert_post_action>
    6de9:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    6dec:	83 ec 0c             	sub    $0xc,%esp
    6def:	68 8c da 00 00       	push   $0xda8c
    6df4:	e8 9c 14 00 00       	call   8295 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    6df9:	8d 43 08             	lea    0x8(%ebx),%eax
    6dfc:	83 c4 10             	add    $0x10,%esp
    6dff:	e8 80 fb ff ff       	call   6984 <pended_on.isra.18>
    6e04:	52                   	push   %edx
    6e05:	52                   	push   %edx
    6e06:	53                   	push   %ebx
    6e07:	50                   	push   %eax
    6e08:	e8 29 ff ff ff       	call   6d36 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    6e0d:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
		thread->base.pended_on = NULL;
    6e11:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    6e18:	c7 04 24 8c da 00 00 	movl   $0xda8c,(%esp)
    6e1f:	e8 4e 14 00 00       	call   8272 <z_spin_unlock_valid>
    6e24:	83 c4 10             	add    $0x10,%esp
    6e27:	84 c0                	test   %al,%al
    6e29:	75 38                	jne    6e63 <z_unpend_thread+0xd2>
    6e2b:	6a 5d                	push   $0x5d
    6e2d:	68 00 9d 00 00       	push   $0x9d00
    6e32:	68 62 9d 00 00       	push   $0x9d62
    6e37:	68 e6 8b 00 00       	push   $0x8be6
    6e3c:	e8 4e d1 ff ff       	call   3f8f <printk>
    6e41:	58                   	pop    %eax
    6e42:	5a                   	pop    %edx
    6e43:	68 8c da 00 00       	push   $0xda8c
    6e48:	68 79 9d 00 00       	push   $0x9d79
    6e4d:	e8 3d d1 ff ff       	call   3f8f <printk>
    6e52:	59                   	pop    %ecx
    6e53:	58                   	pop    %eax
    6e54:	6a 5d                	push   $0x5d
    6e56:	68 00 9d 00 00       	push   $0x9d00
    6e5b:	e8 c3 d1 ff ff       	call   4023 <assert_post_action>
    6e60:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    6e63:	83 ec 0c             	sub    $0xc,%esp
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    6e66:	83 c3 18             	add    $0x18,%ebx
    6e69:	56                   	push   %esi
    6e6a:	e8 0d e6 ff ff       	call   547c <posix_irq_unlock>
    6e6f:	89 5d 08             	mov    %ebx,0x8(%ebp)
    6e72:	83 c4 10             	add    $0x10,%esp
}
    6e75:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6e78:	5b                   	pop    %ebx
    6e79:	5e                   	pop    %esi
    6e7a:	5d                   	pop    %ebp
    6e7b:	e9 ee 16 00 00       	jmp    856e <z_abort_timeout>

00006e80 <z_priq_dumb_best>:

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
    6e80:	55                   	push   %ebp
    6e81:	89 e5                	mov    %esp,%ebp
    6e83:	8b 55 08             	mov    0x8(%ebp),%edx
	return list->head == list;
    6e86:	8b 02                	mov    (%edx),%eax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
    6e88:	85 c0                	test   %eax,%eax
    6e8a:	74 04                	je     6e90 <z_priq_dumb_best+0x10>
    6e8c:	39 c2                	cmp    %eax,%edx
    6e8e:	75 02                	jne    6e92 <z_priq_dumb_best+0x12>
	struct k_thread *thread = NULL;
    6e90:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    6e92:	5d                   	pop    %ebp
    6e93:	c3                   	ret    

00006e94 <update_cache>:
{
    6e94:	55                   	push   %ebp
    6e95:	89 c1                	mov    %eax,%ecx
    6e97:	89 e5                	mov    %esp,%ebp
    6e99:	53                   	push   %ebx
    6e9a:	52                   	push   %edx
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
    6e9b:	68 e4 d8 00 00       	push   $0xd8e4
    6ea0:	e8 db ff ff ff       	call   6e80 <z_priq_dumb_best>
	if (_current->base.thread_state & _THREAD_ABORTING) {
    6ea5:	8b 15 c8 d8 00 00    	mov    0xd8c8,%edx
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
    6eab:	5b                   	pop    %ebx
    6eac:	89 c3                	mov    %eax,%ebx
	if (_current->base.thread_state & _THREAD_ABORTING) {
    6eae:	8a 42 0d             	mov    0xd(%edx),%al
    6eb1:	a8 20                	test   $0x20,%al
    6eb3:	74 06                	je     6ebb <update_cache+0x27>
		_current->base.thread_state |= _THREAD_DEAD;
    6eb5:	83 c8 08             	or     $0x8,%eax
    6eb8:	88 42 0d             	mov    %al,0xd(%edx)
	return thread ? thread : _current_cpu->idle_thread;
    6ebb:	85 db                	test   %ebx,%ebx
    6ebd:	75 06                	jne    6ec5 <update_cache+0x31>
    6ebf:	8b 1d cc d8 00 00    	mov    0xd8cc,%ebx
	if (preempt_ok != 0) {
    6ec5:	85 c9                	test   %ecx,%ecx
    6ec7:	75 15                	jne    6ede <update_cache+0x4a>
	if (z_is_thread_prevented_from_running(_current)) {
    6ec9:	f6 42 0d 1f          	testb  $0x1f,0xd(%edx)
    6ecd:	75 0f                	jne    6ede <update_cache+0x4a>
	if (is_preempt(_current) || is_metairq(thread)) {
    6ecf:	66 83 7a 0e 7f       	cmpw   $0x7f,0xe(%edx)
    6ed4:	76 08                	jbe    6ede <update_cache+0x4a>
		_kernel.ready_q.cache = _current;
    6ed6:	89 15 e0 d8 00 00    	mov    %edx,0xd8e0
    6edc:	eb 0f                	jmp    6eed <update_cache+0x59>
		if (thread != _current) {
    6ede:	39 da                	cmp    %ebx,%edx
    6ee0:	74 05                	je     6ee7 <update_cache+0x53>
			z_reset_time_slice();
    6ee2:	e8 dd fa ff ff       	call   69c4 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    6ee7:	89 1d e0 d8 00 00    	mov    %ebx,0xd8e0
}
    6eed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6ef0:	c9                   	leave  
    6ef1:	c3                   	ret    

00006ef2 <k_sched_unlock>:
{
    6ef2:	55                   	push   %ebp
    6ef3:	89 e5                	mov    %esp,%ebp
    6ef5:	53                   	push   %ebx
    6ef6:	50                   	push   %eax
	return posix_irq_lock();
    6ef7:	e8 6e e5 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    6efc:	83 ec 0c             	sub    $0xc,%esp
    6eff:	89 c3                	mov    %eax,%ebx
    6f01:	68 8c da 00 00       	push   $0xda8c
    6f06:	e8 48 13 00 00       	call   8253 <z_spin_lock_valid>
    6f0b:	83 c4 10             	add    $0x10,%esp
    6f0e:	84 c0                	test   %al,%al
    6f10:	75 38                	jne    6f4a <k_sched_unlock+0x58>
    6f12:	6a 4a                	push   $0x4a
    6f14:	68 00 9d 00 00       	push   $0x9d00
    6f19:	68 35 9d 00 00       	push   $0x9d35
    6f1e:	68 e6 8b 00 00       	push   $0x8be6
    6f23:	e8 67 d0 ff ff       	call   3f8f <printk>
    6f28:	58                   	pop    %eax
    6f29:	5a                   	pop    %edx
    6f2a:	68 8c da 00 00       	push   $0xda8c
    6f2f:	68 4a 9d 00 00       	push   $0x9d4a
    6f34:	e8 56 d0 ff ff       	call   3f8f <printk>
    6f39:	59                   	pop    %ecx
    6f3a:	58                   	pop    %eax
    6f3b:	6a 4a                	push   $0x4a
    6f3d:	68 00 9d 00 00       	push   $0x9d00
    6f42:	e8 dc d0 ff ff       	call   4023 <assert_post_action>
    6f47:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    6f4a:	83 ec 0c             	sub    $0xc,%esp
    6f4d:	68 8c da 00 00       	push   $0xda8c
    6f52:	e8 3e 13 00 00       	call   8295 <z_spin_lock_set_owner>
		__ASSERT(_current->base.sched_locked != 0, "");
    6f57:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
    6f5c:	83 c4 10             	add    $0x10,%esp
    6f5f:	80 78 0f 00          	cmpb   $0x0,0xf(%eax)
    6f63:	75 39                	jne    6f9e <k_sched_unlock+0xac>
    6f65:	68 d1 02 00 00       	push   $0x2d1
    6f6a:	68 8e 9d 00 00       	push   $0x9d8e
    6f6f:	68 6e 9e 00 00       	push   $0x9e6e
    6f74:	68 e6 8b 00 00       	push   $0x8be6
    6f79:	e8 11 d0 ff ff       	call   3f8f <printk>
    6f7e:	c7 04 24 22 9e 00 00 	movl   $0x9e22,(%esp)
    6f85:	e8 05 d0 ff ff       	call   3f8f <printk>
    6f8a:	59                   	pop    %ecx
    6f8b:	58                   	pop    %eax
    6f8c:	68 d1 02 00 00       	push   $0x2d1
    6f91:	68 8e 9d 00 00       	push   $0x9d8e
    6f96:	e8 88 d0 ff ff       	call   4023 <assert_post_action>
    6f9b:	83 c4 10             	add    $0x10,%esp
		__ASSERT(!arch_is_in_isr(), "");
    6f9e:	83 3d c0 d8 00 00 00 	cmpl   $0x0,0xd8c0
    6fa5:	74 39                	je     6fe0 <k_sched_unlock+0xee>
    6fa7:	68 d2 02 00 00       	push   $0x2d2
    6fac:	68 8e 9d 00 00       	push   $0x9d8e
    6fb1:	68 10 9e 00 00       	push   $0x9e10
    6fb6:	68 e6 8b 00 00       	push   $0x8be6
    6fbb:	e8 cf cf ff ff       	call   3f8f <printk>
    6fc0:	c7 04 24 22 9e 00 00 	movl   $0x9e22,(%esp)
    6fc7:	e8 c3 cf ff ff       	call   3f8f <printk>
    6fcc:	58                   	pop    %eax
    6fcd:	5a                   	pop    %edx
    6fce:	68 d2 02 00 00       	push   $0x2d2
    6fd3:	68 8e 9d 00 00       	push   $0x9d8e
    6fd8:	e8 46 d0 ff ff       	call   4023 <assert_post_action>
    6fdd:	83 c4 10             	add    $0x10,%esp
		++_current->base.sched_locked;
    6fe0:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
    6fe5:	fe 40 0f             	incb   0xf(%eax)
		update_cache(0);
    6fe8:	31 c0                	xor    %eax,%eax
    6fea:	e8 a5 fe ff ff       	call   6e94 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    6fef:	83 ec 0c             	sub    $0xc,%esp
    6ff2:	68 8c da 00 00       	push   $0xda8c
    6ff7:	e8 76 12 00 00       	call   8272 <z_spin_unlock_valid>
    6ffc:	83 c4 10             	add    $0x10,%esp
    6fff:	84 c0                	test   %al,%al
    7001:	75 38                	jne    703b <k_sched_unlock+0x149>
    7003:	6a 5d                	push   $0x5d
    7005:	68 00 9d 00 00       	push   $0x9d00
    700a:	68 62 9d 00 00       	push   $0x9d62
    700f:	68 e6 8b 00 00       	push   $0x8be6
    7014:	e8 76 cf ff ff       	call   3f8f <printk>
    7019:	58                   	pop    %eax
    701a:	5a                   	pop    %edx
    701b:	68 8c da 00 00       	push   $0xda8c
    7020:	68 79 9d 00 00       	push   $0x9d79
    7025:	e8 65 cf ff ff       	call   3f8f <printk>
    702a:	59                   	pop    %ecx
    702b:	58                   	pop    %eax
    702c:	6a 5d                	push   $0x5d
    702e:	68 00 9d 00 00       	push   $0x9d00
    7033:	e8 eb cf ff ff       	call   4023 <assert_post_action>
    7038:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    703b:	83 ec 0c             	sub    $0xc,%esp
    703e:	53                   	push   %ebx
    703f:	e8 38 e4 ff ff       	call   547c <posix_irq_unlock>
    7044:	83 c4 10             	add    $0x10,%esp
}
    7047:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    704a:	c9                   	leave  
	z_reschedule_unlocked();
    704b:	e9 7a fb ff ff       	jmp    6bca <z_reschedule_unlocked>

00007050 <ready_thread>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    7050:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
    7054:	0f 85 a4 00 00 00    	jne    70fe <ready_thread+0xae>
	if (z_is_thread_ready(thread)) {
    705a:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
    705e:	0f 85 9a 00 00 00    	jne    70fe <ready_thread+0xae>
{
    7064:	55                   	push   %ebp
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    7065:	3d c0 d7 00 00       	cmp    $0xd7c0,%eax
{
    706a:	89 e5                	mov    %esp,%ebp
    706c:	53                   	push   %ebx
    706d:	89 c3                	mov    %eax,%ebx
    706f:	51                   	push   %ecx
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    7070:	75 2d                	jne    709f <ready_thread+0x4f>
    7072:	68 1c 03 00 00       	push   $0x31c
    7077:	68 8e 9d 00 00       	push   $0x9d8e
    707c:	68 4d 9e 00 00       	push   $0x9e4d
    7081:	68 e6 8b 00 00       	push   $0x8be6
    7086:	e8 04 cf ff ff       	call   3f8f <printk>
    708b:	58                   	pop    %eax
    708c:	5a                   	pop    %edx
    708d:	68 1c 03 00 00       	push   $0x31c
    7092:	68 8e 9d 00 00       	push   $0x9d8e
    7097:	e8 87 cf ff ff       	call   4023 <assert_post_action>
    709c:	83 c4 10             	add    $0x10,%esp
    709f:	a1 e4 d8 00 00       	mov    0xd8e4,%eax
    70a4:	8b 15 e8 d8 00 00    	mov    0xd8e8,%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    70aa:	85 c0                	test   %eax,%eax
    70ac:	74 2b                	je     70d9 <ready_thread+0x89>
    70ae:	3d e4 d8 00 00       	cmp    $0xd8e4,%eax
    70b3:	74 24                	je     70d9 <ready_thread+0x89>
	if (thread_1->base.prio < thread_2->base.prio) {
    70b5:	8a 48 0e             	mov    0xe(%eax),%cl
    70b8:	38 4b 0e             	cmp    %cl,0xe(%ebx)
    70bb:	7c 0a                	jl     70c7 <ready_thread+0x77>
	return (node == list->tail) ? NULL : node->next;
    70bd:	39 d0                	cmp    %edx,%eax
    70bf:	74 18                	je     70d9 <ready_thread+0x89>
    70c1:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    70c3:	85 c0                	test   %eax,%eax
    70c5:	eb ec                	jmp    70b3 <ready_thread+0x63>
	node->prev = successor->prev;
    70c7:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
    70ca:	89 03                	mov    %eax,(%ebx)
	node->prev = successor->prev;
    70cc:	89 53 04             	mov    %edx,0x4(%ebx)
	successor->prev->next = node;
    70cf:	8b 50 04             	mov    0x4(%eax),%edx
    70d2:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
    70d4:	89 58 04             	mov    %ebx,0x4(%eax)
    70d7:	eb 16                	jmp    70ef <ready_thread+0x9f>
	node->prev = list->tail;
    70d9:	89 53 04             	mov    %edx,0x4(%ebx)
	list->tail->next = node;
    70dc:	a1 e8 d8 00 00       	mov    0xd8e8,%eax
	node->next = list;
    70e1:	c7 03 e4 d8 00 00    	movl   $0xd8e4,(%ebx)
	list->tail->next = node;
    70e7:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
    70e9:	89 1d e8 d8 00 00    	mov    %ebx,0xd8e8
	thread->base.thread_state |= states;
    70ef:	80 4b 0d 80          	orb    $0x80,0xd(%ebx)
		update_cache(0);
    70f3:	31 c0                	xor    %eax,%eax
}
    70f5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    70f8:	c9                   	leave  
		update_cache(0);
    70f9:	e9 96 fd ff ff       	jmp    6e94 <update_cache>
    70fe:	c3                   	ret    

000070ff <z_ready_thread>:
{
    70ff:	55                   	push   %ebp
    7100:	89 e5                	mov    %esp,%ebp
    7102:	56                   	push   %esi
    7103:	53                   	push   %ebx
    7104:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
    7107:	e8 5e e3 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    710c:	83 ec 0c             	sub    $0xc,%esp
    710f:	89 c3                	mov    %eax,%ebx
    7111:	68 8c da 00 00       	push   $0xda8c
    7116:	e8 38 11 00 00       	call   8253 <z_spin_lock_valid>
    711b:	83 c4 10             	add    $0x10,%esp
    711e:	84 c0                	test   %al,%al
    7120:	75 38                	jne    715a <z_ready_thread+0x5b>
    7122:	6a 4a                	push   $0x4a
    7124:	68 00 9d 00 00       	push   $0x9d00
    7129:	68 35 9d 00 00       	push   $0x9d35
    712e:	68 e6 8b 00 00       	push   $0x8be6
    7133:	e8 57 ce ff ff       	call   3f8f <printk>
    7138:	58                   	pop    %eax
    7139:	5a                   	pop    %edx
    713a:	68 8c da 00 00       	push   $0xda8c
    713f:	68 4a 9d 00 00       	push   $0x9d4a
    7144:	e8 46 ce ff ff       	call   3f8f <printk>
    7149:	59                   	pop    %ecx
    714a:	58                   	pop    %eax
    714b:	6a 4a                	push   $0x4a
    714d:	68 00 9d 00 00       	push   $0x9d00
    7152:	e8 cc ce ff ff       	call   4023 <assert_post_action>
    7157:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    715a:	83 ec 0c             	sub    $0xc,%esp
    715d:	68 8c da 00 00       	push   $0xda8c
    7162:	e8 2e 11 00 00       	call   8295 <z_spin_lock_set_owner>
    7167:	83 c4 10             	add    $0x10,%esp
		ready_thread(thread);
    716a:	89 f0                	mov    %esi,%eax
    716c:	e8 df fe ff ff       	call   7050 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    7171:	83 ec 0c             	sub    $0xc,%esp
    7174:	68 8c da 00 00       	push   $0xda8c
    7179:	e8 f4 10 00 00       	call   8272 <z_spin_unlock_valid>
    717e:	83 c4 10             	add    $0x10,%esp
    7181:	84 c0                	test   %al,%al
    7183:	75 38                	jne    71bd <z_ready_thread+0xbe>
    7185:	6a 5d                	push   $0x5d
    7187:	68 00 9d 00 00       	push   $0x9d00
    718c:	68 62 9d 00 00       	push   $0x9d62
    7191:	68 e6 8b 00 00       	push   $0x8be6
    7196:	e8 f4 cd ff ff       	call   3f8f <printk>
    719b:	58                   	pop    %eax
    719c:	5a                   	pop    %edx
    719d:	68 8c da 00 00       	push   $0xda8c
    71a2:	68 79 9d 00 00       	push   $0x9d79
    71a7:	e8 e3 cd ff ff       	call   3f8f <printk>
    71ac:	59                   	pop    %ecx
    71ad:	5e                   	pop    %esi
    71ae:	6a 5d                	push   $0x5d
    71b0:	68 00 9d 00 00       	push   $0x9d00
    71b5:	e8 69 ce ff ff       	call   4023 <assert_post_action>
    71ba:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    71bd:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
    71c0:	8d 65 f8             	lea    -0x8(%ebp),%esp
    71c3:	5b                   	pop    %ebx
    71c4:	5e                   	pop    %esi
    71c5:	5d                   	pop    %ebp
    71c6:	e9 b1 e2 ff ff       	jmp    547c <posix_irq_unlock>

000071cb <z_thread_timeout>:
{
    71cb:	55                   	push   %ebp
    71cc:	89 e5                	mov    %esp,%ebp
    71ce:	57                   	push   %edi
    71cf:	56                   	push   %esi
    71d0:	53                   	push   %ebx
    71d1:	83 ec 0c             	sub    $0xc,%esp
    71d4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (thread->base.pended_on != NULL) {
    71d7:	83 7b f0 00          	cmpl   $0x0,-0x10(%ebx)
	struct k_thread *thread = CONTAINER_OF(timeout,
    71db:	8d 73 e8             	lea    -0x18(%ebx),%esi
	if (thread->base.pended_on != NULL) {
    71de:	0f 84 d6 00 00 00    	je     72ba <z_thread_timeout+0xef>
	return posix_irq_lock();
    71e4:	e8 81 e2 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    71e9:	83 ec 0c             	sub    $0xc,%esp
    71ec:	89 c7                	mov    %eax,%edi
    71ee:	68 8c da 00 00       	push   $0xda8c
    71f3:	e8 5b 10 00 00       	call   8253 <z_spin_lock_valid>
    71f8:	83 c4 10             	add    $0x10,%esp
    71fb:	84 c0                	test   %al,%al
    71fd:	75 38                	jne    7237 <z_thread_timeout+0x6c>
    71ff:	6a 4a                	push   $0x4a
    7201:	68 00 9d 00 00       	push   $0x9d00
    7206:	68 35 9d 00 00       	push   $0x9d35
    720b:	68 e6 8b 00 00       	push   $0x8be6
    7210:	e8 7a cd ff ff       	call   3f8f <printk>
    7215:	59                   	pop    %ecx
    7216:	58                   	pop    %eax
    7217:	68 8c da 00 00       	push   $0xda8c
    721c:	68 4a 9d 00 00       	push   $0x9d4a
    7221:	e8 69 cd ff ff       	call   3f8f <printk>
    7226:	58                   	pop    %eax
    7227:	5a                   	pop    %edx
    7228:	6a 4a                	push   $0x4a
    722a:	68 00 9d 00 00       	push   $0x9d00
    722f:	e8 ef cd ff ff       	call   4023 <assert_post_action>
    7234:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    7237:	83 ec 0c             	sub    $0xc,%esp
    723a:	68 8c da 00 00       	push   $0xda8c
    723f:	e8 51 10 00 00       	call   8295 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    7244:	8d 43 f0             	lea    -0x10(%ebx),%eax
    7247:	83 c4 10             	add    $0x10,%esp
    724a:	e8 35 f7 ff ff       	call   6984 <pended_on.isra.18>
    724f:	52                   	push   %edx
    7250:	52                   	push   %edx
    7251:	56                   	push   %esi
    7252:	50                   	push   %eax
    7253:	e8 de fa ff ff       	call   6d36 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    7258:	80 63 f5 fd          	andb   $0xfd,-0xb(%ebx)
		thread->base.pended_on = NULL;
    725c:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    7263:	c7 04 24 8c da 00 00 	movl   $0xda8c,(%esp)
    726a:	e8 03 10 00 00       	call   8272 <z_spin_unlock_valid>
    726f:	83 c4 10             	add    $0x10,%esp
    7272:	84 c0                	test   %al,%al
    7274:	75 38                	jne    72ae <z_thread_timeout+0xe3>
    7276:	6a 5d                	push   $0x5d
    7278:	68 00 9d 00 00       	push   $0x9d00
    727d:	68 62 9d 00 00       	push   $0x9d62
    7282:	68 e6 8b 00 00       	push   $0x8be6
    7287:	e8 03 cd ff ff       	call   3f8f <printk>
    728c:	58                   	pop    %eax
    728d:	5a                   	pop    %edx
    728e:	68 8c da 00 00       	push   $0xda8c
    7293:	68 79 9d 00 00       	push   $0x9d79
    7298:	e8 f2 cc ff ff       	call   3f8f <printk>
    729d:	59                   	pop    %ecx
    729e:	58                   	pop    %eax
    729f:	6a 5d                	push   $0x5d
    72a1:	68 00 9d 00 00       	push   $0x9d00
    72a6:	e8 78 cd ff ff       	call   4023 <assert_post_action>
    72ab:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    72ae:	83 ec 0c             	sub    $0xc,%esp
    72b1:	57                   	push   %edi
    72b2:	e8 c5 e1 ff ff       	call   547c <posix_irq_unlock>
    72b7:	83 c4 10             	add    $0x10,%esp
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    72ba:	80 63 f5 eb          	andb   $0xeb,-0xb(%ebx)
	z_ready_thread(thread);
    72be:	89 75 08             	mov    %esi,0x8(%ebp)
}
    72c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
    72c4:	5b                   	pop    %ebx
    72c5:	5e                   	pop    %esi
    72c6:	5f                   	pop    %edi
    72c7:	5d                   	pop    %ebp
	z_ready_thread(thread);
    72c8:	e9 32 fe ff ff       	jmp    70ff <z_ready_thread>

000072cd <z_sched_start>:
{
    72cd:	55                   	push   %ebp
    72ce:	89 e5                	mov    %esp,%ebp
    72d0:	56                   	push   %esi
    72d1:	53                   	push   %ebx
    72d2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
    72d5:	e8 90 e1 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    72da:	83 ec 0c             	sub    $0xc,%esp
    72dd:	89 c6                	mov    %eax,%esi
    72df:	68 8c da 00 00       	push   $0xda8c
    72e4:	e8 6a 0f 00 00       	call   8253 <z_spin_lock_valid>
    72e9:	83 c4 10             	add    $0x10,%esp
    72ec:	84 c0                	test   %al,%al
    72ee:	75 38                	jne    7328 <z_sched_start+0x5b>
    72f0:	6a 4a                	push   $0x4a
    72f2:	68 00 9d 00 00       	push   $0x9d00
    72f7:	68 35 9d 00 00       	push   $0x9d35
    72fc:	68 e6 8b 00 00       	push   $0x8be6
    7301:	e8 89 cc ff ff       	call   3f8f <printk>
    7306:	58                   	pop    %eax
    7307:	5a                   	pop    %edx
    7308:	68 8c da 00 00       	push   $0xda8c
    730d:	68 4a 9d 00 00       	push   $0x9d4a
    7312:	e8 78 cc ff ff       	call   3f8f <printk>
    7317:	59                   	pop    %ecx
    7318:	58                   	pop    %eax
    7319:	6a 4a                	push   $0x4a
    731b:	68 00 9d 00 00       	push   $0x9d00
    7320:	e8 fe cc ff ff       	call   4023 <assert_post_action>
    7325:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    7328:	83 ec 0c             	sub    $0xc,%esp
    732b:	68 8c da 00 00       	push   $0xda8c
    7330:	e8 60 0f 00 00       	call   8295 <z_spin_lock_set_owner>
	if (z_has_thread_started(thread)) {
    7335:	8a 43 0d             	mov    0xd(%ebx),%al
    7338:	83 c4 10             	add    $0x10,%esp
    733b:	a8 04                	test   $0x4,%al
    733d:	75 5a                	jne    7399 <z_sched_start+0xcc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    733f:	83 ec 0c             	sub    $0xc,%esp
    7342:	68 8c da 00 00       	push   $0xda8c
    7347:	e8 26 0f 00 00       	call   8272 <z_spin_unlock_valid>
    734c:	83 c4 10             	add    $0x10,%esp
    734f:	84 c0                	test   %al,%al
    7351:	75 38                	jne    738b <z_sched_start+0xbe>
    7353:	6a 5d                	push   $0x5d
    7355:	68 00 9d 00 00       	push   $0x9d00
    735a:	68 62 9d 00 00       	push   $0x9d62
    735f:	68 e6 8b 00 00       	push   $0x8be6
    7364:	e8 26 cc ff ff       	call   3f8f <printk>
    7369:	5a                   	pop    %edx
    736a:	59                   	pop    %ecx
    736b:	68 8c da 00 00       	push   $0xda8c
    7370:	68 79 9d 00 00       	push   $0x9d79
    7375:	e8 15 cc ff ff       	call   3f8f <printk>
    737a:	5b                   	pop    %ebx
    737b:	58                   	pop    %eax
    737c:	6a 5d                	push   $0x5d
    737e:	68 00 9d 00 00       	push   $0x9d00
    7383:	e8 9b cc ff ff       	call   4023 <assert_post_action>
    7388:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    738b:	89 75 08             	mov    %esi,0x8(%ebp)
}
    738e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7391:	5b                   	pop    %ebx
    7392:	5e                   	pop    %esi
    7393:	5d                   	pop    %ebp
    7394:	e9 e3 e0 ff ff       	jmp    547c <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
    7399:	83 e0 fb             	and    $0xfffffffb,%eax
    739c:	88 43 0d             	mov    %al,0xd(%ebx)
	ready_thread(thread);
    739f:	89 d8                	mov    %ebx,%eax
    73a1:	e8 aa fc ff ff       	call   7050 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    73a6:	50                   	push   %eax
    73a7:	50                   	push   %eax
    73a8:	56                   	push   %esi
    73a9:	68 8c da 00 00       	push   $0xda8c
    73ae:	e8 35 f7 ff ff       	call   6ae8 <z_reschedule>
    73b3:	83 c4 10             	add    $0x10,%esp
}
    73b6:	8d 65 f8             	lea    -0x8(%ebp),%esp
    73b9:	5b                   	pop    %ebx
    73ba:	5e                   	pop    %esi
    73bb:	5d                   	pop    %ebp
    73bc:	c3                   	ret    

000073bd <z_move_thread_to_end_of_prio_q>:
{
    73bd:	55                   	push   %ebp
    73be:	89 e5                	mov    %esp,%ebp
    73c0:	56                   	push   %esi
    73c1:	53                   	push   %ebx
    73c2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
    73c5:	e8 a0 e0 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    73ca:	83 ec 0c             	sub    $0xc,%esp
    73cd:	89 c6                	mov    %eax,%esi
    73cf:	68 8c da 00 00       	push   $0xda8c
    73d4:	e8 7a 0e 00 00       	call   8253 <z_spin_lock_valid>
    73d9:	83 c4 10             	add    $0x10,%esp
    73dc:	84 c0                	test   %al,%al
    73de:	75 38                	jne    7418 <z_move_thread_to_end_of_prio_q+0x5b>
    73e0:	6a 4a                	push   $0x4a
    73e2:	68 00 9d 00 00       	push   $0x9d00
    73e7:	68 35 9d 00 00       	push   $0x9d35
    73ec:	68 e6 8b 00 00       	push   $0x8be6
    73f1:	e8 99 cb ff ff       	call   3f8f <printk>
    73f6:	58                   	pop    %eax
    73f7:	5a                   	pop    %edx
    73f8:	68 8c da 00 00       	push   $0xda8c
    73fd:	68 4a 9d 00 00       	push   $0x9d4a
    7402:	e8 88 cb ff ff       	call   3f8f <printk>
    7407:	59                   	pop    %ecx
    7408:	58                   	pop    %eax
    7409:	6a 4a                	push   $0x4a
    740b:	68 00 9d 00 00       	push   $0x9d00
    7410:	e8 0e cc ff ff       	call   4023 <assert_post_action>
    7415:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    7418:	83 ec 0c             	sub    $0xc,%esp
    741b:	68 8c da 00 00       	push   $0xda8c
    7420:	e8 70 0e 00 00       	call   8295 <z_spin_lock_set_owner>
    7425:	83 c4 10             	add    $0x10,%esp
		if (z_is_thread_queued(thread)) {
    7428:	80 7b 0d 00          	cmpb   $0x0,0xd(%ebx)
    742c:	79 10                	jns    743e <z_move_thread_to_end_of_prio_q+0x81>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    742e:	51                   	push   %ecx
    742f:	51                   	push   %ecx
    7430:	53                   	push   %ebx
    7431:	68 e4 d8 00 00       	push   $0xd8e4
    7436:	e8 fb f8 ff ff       	call   6d36 <z_priq_dumb_remove>
    743b:	83 c4 10             	add    $0x10,%esp
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    743e:	81 fb c0 d7 00 00    	cmp    $0xd7c0,%ebx
    7444:	75 2d                	jne    7473 <z_move_thread_to_end_of_prio_q+0xb6>
    7446:	68 1c 03 00 00       	push   $0x31c
    744b:	68 8e 9d 00 00       	push   $0x9d8e
    7450:	68 4d 9e 00 00       	push   $0x9e4d
    7455:	68 e6 8b 00 00       	push   $0x8be6
    745a:	e8 30 cb ff ff       	call   3f8f <printk>
    745f:	58                   	pop    %eax
    7460:	5a                   	pop    %edx
    7461:	68 1c 03 00 00       	push   $0x31c
    7466:	68 8e 9d 00 00       	push   $0x9d8e
    746b:	e8 b3 cb ff ff       	call   4023 <assert_post_action>
    7470:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
    7473:	a1 e4 d8 00 00       	mov    0xd8e4,%eax
    7478:	8b 15 e8 d8 00 00    	mov    0xd8e8,%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    747e:	85 c0                	test   %eax,%eax
    7480:	74 2b                	je     74ad <z_move_thread_to_end_of_prio_q+0xf0>
    7482:	3d e4 d8 00 00       	cmp    $0xd8e4,%eax
    7487:	74 24                	je     74ad <z_move_thread_to_end_of_prio_q+0xf0>
	if (thread_1->base.prio < thread_2->base.prio) {
    7489:	8a 48 0e             	mov    0xe(%eax),%cl
    748c:	38 4b 0e             	cmp    %cl,0xe(%ebx)
    748f:	7c 0a                	jl     749b <z_move_thread_to_end_of_prio_q+0xde>
	return (node == list->tail) ? NULL : node->next;
    7491:	39 c2                	cmp    %eax,%edx
    7493:	74 18                	je     74ad <z_move_thread_to_end_of_prio_q+0xf0>
    7495:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    7497:	85 c0                	test   %eax,%eax
    7499:	eb ec                	jmp    7487 <z_move_thread_to_end_of_prio_q+0xca>
	node->prev = successor->prev;
    749b:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
    749e:	89 03                	mov    %eax,(%ebx)
	node->prev = successor->prev;
    74a0:	89 53 04             	mov    %edx,0x4(%ebx)
	successor->prev->next = node;
    74a3:	8b 50 04             	mov    0x4(%eax),%edx
    74a6:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
    74a8:	89 58 04             	mov    %ebx,0x4(%eax)
    74ab:	eb 16                	jmp    74c3 <z_move_thread_to_end_of_prio_q+0x106>
	node->prev = list->tail;
    74ad:	89 53 04             	mov    %edx,0x4(%ebx)
	list->tail->next = node;
    74b0:	a1 e8 d8 00 00       	mov    0xd8e8,%eax
	node->next = list;
    74b5:	c7 03 e4 d8 00 00    	movl   $0xd8e4,(%ebx)
	list->tail->next = node;
    74bb:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
    74bd:	89 1d e8 d8 00 00    	mov    %ebx,0xd8e8
	thread->base.thread_state |= states;
    74c3:	80 4b 0d 80          	orb    $0x80,0xd(%ebx)
		update_cache(thread == _current);
    74c7:	31 c0                	xor    %eax,%eax
    74c9:	39 1d c8 d8 00 00    	cmp    %ebx,0xd8c8
    74cf:	0f 94 c0             	sete   %al
    74d2:	e8 bd f9 ff ff       	call   6e94 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    74d7:	83 ec 0c             	sub    $0xc,%esp
    74da:	68 8c da 00 00       	push   $0xda8c
    74df:	e8 8e 0d 00 00       	call   8272 <z_spin_unlock_valid>
    74e4:	83 c4 10             	add    $0x10,%esp
    74e7:	84 c0                	test   %al,%al
    74e9:	75 38                	jne    7523 <z_move_thread_to_end_of_prio_q+0x166>
    74eb:	6a 5d                	push   $0x5d
    74ed:	68 00 9d 00 00       	push   $0x9d00
    74f2:	68 62 9d 00 00       	push   $0x9d62
    74f7:	68 e6 8b 00 00       	push   $0x8be6
    74fc:	e8 8e ca ff ff       	call   3f8f <printk>
    7501:	58                   	pop    %eax
    7502:	5a                   	pop    %edx
    7503:	68 8c da 00 00       	push   $0xda8c
    7508:	68 79 9d 00 00       	push   $0x9d79
    750d:	e8 7d ca ff ff       	call   3f8f <printk>
    7512:	59                   	pop    %ecx
    7513:	5b                   	pop    %ebx
    7514:	6a 5d                	push   $0x5d
    7516:	68 00 9d 00 00       	push   $0x9d00
    751b:	e8 03 cb ff ff       	call   4023 <assert_post_action>
    7520:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    7523:	89 75 08             	mov    %esi,0x8(%ebp)
}
    7526:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7529:	5b                   	pop    %ebx
    752a:	5e                   	pop    %esi
    752b:	5d                   	pop    %ebp
    752c:	e9 4b df ff ff       	jmp    547c <posix_irq_unlock>

00007531 <z_time_slice>:
{
    7531:	55                   	push   %ebp
    7532:	89 e5                	mov    %esp,%ebp
    7534:	83 ec 08             	sub    $0x8,%esp
	if (slice_time && sliceable(_current)) {
    7537:	83 3d 88 da 00 00 00 	cmpl   $0x0,0xda88
{
    753e:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (slice_time && sliceable(_current)) {
    7541:	74 4b                	je     758e <z_time_slice+0x5d>
    7543:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
		&& !z_is_thread_timeout_active(thread);
    7548:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
    754d:	77 3f                	ja     758e <z_time_slice+0x5d>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    754f:	0f be 50 0e          	movsbl 0xe(%eax),%edx
		&& !z_is_idle_thread_object(thread)
    7553:	39 15 84 da 00 00    	cmp    %edx,0xda84
    7559:	7f 33                	jg     758e <z_time_slice+0x5d>
    755b:	3d c0 d7 00 00       	cmp    $0xd7c0,%eax
    7560:	74 2c                	je     758e <z_time_slice+0x5d>
		&& !z_is_thread_timeout_active(thread);
    7562:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
    7566:	75 26                	jne    758e <z_time_slice+0x5d>
		if (ticks >= _current_cpu->slice_ticks) {
    7568:	8b 15 d0 d8 00 00    	mov    0xd8d0,%edx
    756e:	39 ca                	cmp    %ecx,%edx
    7570:	7f 12                	jg     7584 <z_time_slice+0x53>
			z_move_thread_to_end_of_prio_q(_current);
    7572:	83 ec 0c             	sub    $0xc,%esp
    7575:	50                   	push   %eax
    7576:	e8 42 fe ff ff       	call   73bd <z_move_thread_to_end_of_prio_q>
    757b:	83 c4 10             	add    $0x10,%esp
}
    757e:	c9                   	leave  
			z_reset_time_slice();
    757f:	e9 40 f4 ff ff       	jmp    69c4 <z_reset_time_slice>
			_current_cpu->slice_ticks -= ticks;
    7584:	29 ca                	sub    %ecx,%edx
    7586:	89 15 d0 d8 00 00    	mov    %edx,0xd8d0
    758c:	eb 0a                	jmp    7598 <z_time_slice+0x67>
		_current_cpu->slice_ticks = 0;
    758e:	c7 05 d0 d8 00 00 00 	movl   $0x0,0xd8d0
    7595:	00 00 00 
}
    7598:	c9                   	leave  
    7599:	c3                   	ret    

0000759a <z_thread_single_abort>:
{
    759a:	55                   	push   %ebp
    759b:	89 e5                	mov    %esp,%ebp
    759d:	56                   	push   %esi
    759e:	53                   	push   %ebx
    759f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (thread->fn_abort != NULL) {
    75a2:	8b 43 38             	mov    0x38(%ebx),%eax
    75a5:	85 c0                	test   %eax,%eax
    75a7:	74 02                	je     75ab <z_thread_single_abort+0x11>
		thread->fn_abort();
    75a9:	ff d0                	call   *%eax
    75ab:	8d 43 18             	lea    0x18(%ebx),%eax
    75ae:	83 ec 0c             	sub    $0xc,%esp
    75b1:	50                   	push   %eax
    75b2:	e8 b7 0f 00 00       	call   856e <z_abort_timeout>
    75b7:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
    75ba:	e8 ab de ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    75bf:	83 ec 0c             	sub    $0xc,%esp
    75c2:	89 c6                	mov    %eax,%esi
    75c4:	68 8c da 00 00       	push   $0xda8c
    75c9:	e8 85 0c 00 00       	call   8253 <z_spin_lock_valid>
    75ce:	83 c4 10             	add    $0x10,%esp
    75d1:	84 c0                	test   %al,%al
    75d3:	75 38                	jne    760d <z_thread_single_abort+0x73>
    75d5:	6a 4a                	push   $0x4a
    75d7:	68 00 9d 00 00       	push   $0x9d00
    75dc:	68 35 9d 00 00       	push   $0x9d35
    75e1:	68 e6 8b 00 00       	push   $0x8be6
    75e6:	e8 a4 c9 ff ff       	call   3f8f <printk>
    75eb:	58                   	pop    %eax
    75ec:	5a                   	pop    %edx
    75ed:	68 8c da 00 00       	push   $0xda8c
    75f2:	68 4a 9d 00 00       	push   $0x9d4a
    75f7:	e8 93 c9 ff ff       	call   3f8f <printk>
    75fc:	59                   	pop    %ecx
    75fd:	58                   	pop    %eax
    75fe:	6a 4a                	push   $0x4a
    7600:	68 00 9d 00 00       	push   $0x9d00
    7605:	e8 19 ca ff ff       	call   4023 <assert_post_action>
    760a:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    760d:	83 ec 0c             	sub    $0xc,%esp
    7610:	68 8c da 00 00       	push   $0xda8c
    7615:	e8 7b 0c 00 00       	call   8295 <z_spin_lock_set_owner>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
    761a:	8a 43 0d             	mov    0xd(%ebx),%al
    761d:	83 c4 10             	add    $0x10,%esp
    7620:	a8 1f                	test   $0x1f,%al
    7622:	75 30                	jne    7654 <z_thread_single_abort+0xba>
		if (z_is_thread_ready(thread)) {
    7624:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
    7628:	75 2a                	jne    7654 <z_thread_single_abort+0xba>
			if (z_is_thread_queued(thread)) {
    762a:	84 c0                	test   %al,%al
    762c:	79 14                	jns    7642 <z_thread_single_abort+0xa8>
				_priq_run_remove(&_kernel.ready_q.runq,
    762e:	51                   	push   %ecx
    762f:	51                   	push   %ecx
    7630:	53                   	push   %ebx
    7631:	68 e4 d8 00 00       	push   $0xd8e4
    7636:	e8 fb f6 ff ff       	call   6d36 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    763b:	80 63 0d 7f          	andb   $0x7f,0xd(%ebx)
    763f:	83 c4 10             	add    $0x10,%esp
			update_cache(thread == _current);
    7642:	31 c0                	xor    %eax,%eax
    7644:	39 1d c8 d8 00 00    	cmp    %ebx,0xd8c8
    764a:	0f 94 c0             	sete   %al
    764d:	e8 42 f8 ff ff       	call   6e94 <update_cache>
    7652:	eb 23                	jmp    7677 <z_thread_single_abort+0xdd>
			if (z_is_thread_pending(thread)) {
    7654:	a8 02                	test   $0x2,%al
    7656:	74 1f                	je     7677 <z_thread_single_abort+0xdd>
				_priq_wait_remove(&pended_on(thread)->waitq,
    7658:	8d 43 08             	lea    0x8(%ebx),%eax
    765b:	e8 24 f3 ff ff       	call   6984 <pended_on.isra.18>
    7660:	52                   	push   %edx
    7661:	52                   	push   %edx
    7662:	53                   	push   %ebx
    7663:	50                   	push   %eax
    7664:	e8 cd f6 ff ff       	call   6d36 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    7669:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
    766d:	83 c4 10             	add    $0x10,%esp
				thread->base.pended_on = NULL;
    7670:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		thread->base.thread_state |= mask;
    7677:	80 4b 0d 08          	orb    $0x8,0xd(%ebx)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    767b:	83 ec 0c             	sub    $0xc,%esp
    767e:	68 8c da 00 00       	push   $0xda8c
    7683:	e8 ea 0b 00 00       	call   8272 <z_spin_unlock_valid>
    7688:	83 c4 10             	add    $0x10,%esp
    768b:	84 c0                	test   %al,%al
    768d:	75 38                	jne    76c7 <z_thread_single_abort+0x12d>
    768f:	6a 5d                	push   $0x5d
    7691:	68 00 9d 00 00       	push   $0x9d00
    7696:	68 62 9d 00 00       	push   $0x9d62
    769b:	68 e6 8b 00 00       	push   $0x8be6
    76a0:	e8 ea c8 ff ff       	call   3f8f <printk>
    76a5:	58                   	pop    %eax
    76a6:	5a                   	pop    %edx
    76a7:	68 8c da 00 00       	push   $0xda8c
    76ac:	68 79 9d 00 00       	push   $0x9d79
    76b1:	e8 d9 c8 ff ff       	call   3f8f <printk>
    76b6:	59                   	pop    %ecx
    76b7:	5b                   	pop    %ebx
    76b8:	6a 5d                	push   $0x5d
    76ba:	68 00 9d 00 00       	push   $0x9d00
    76bf:	e8 5f c9 ff ff       	call   4023 <assert_post_action>
    76c4:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    76c7:	89 75 08             	mov    %esi,0x8(%ebp)
}
    76ca:	8d 65 f8             	lea    -0x8(%ebp),%esp
    76cd:	5b                   	pop    %ebx
    76ce:	5e                   	pop    %esi
    76cf:	5d                   	pop    %ebp
    76d0:	e9 a7 dd ff ff       	jmp    547c <posix_irq_unlock>

000076d5 <unready_thread>:
{
    76d5:	55                   	push   %ebp
    76d6:	89 e5                	mov    %esp,%ebp
    76d8:	53                   	push   %ebx
    76d9:	52                   	push   %edx
	if (z_is_thread_queued(thread)) {
    76da:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
{
    76de:	89 c3                	mov    %eax,%ebx
	if (z_is_thread_queued(thread)) {
    76e0:	79 14                	jns    76f6 <unready_thread+0x21>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
    76e2:	50                   	push   %eax
    76e3:	50                   	push   %eax
    76e4:	53                   	push   %ebx
    76e5:	68 e4 d8 00 00       	push   $0xd8e4
    76ea:	e8 47 f6 ff ff       	call   6d36 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    76ef:	80 63 0d 7f          	andb   $0x7f,0xd(%ebx)
    76f3:	83 c4 10             	add    $0x10,%esp
	update_cache(thread == _current);
    76f6:	31 c0                	xor    %eax,%eax
    76f8:	39 1d c8 d8 00 00    	cmp    %ebx,0xd8c8
}
    76fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7701:	c9                   	leave  
	update_cache(thread == _current);
    7702:	0f 94 c0             	sete   %al
    7705:	e9 8a f7 ff ff       	jmp    6e94 <update_cache>

0000770a <pend>:
{
    770a:	55                   	push   %ebp
    770b:	89 e5                	mov    %esp,%ebp
    770d:	57                   	push   %edi
    770e:	56                   	push   %esi
    770f:	53                   	push   %ebx
    7710:	89 d7                	mov    %edx,%edi
    7712:	89 ce                	mov    %ecx,%esi
    7714:	89 c3                	mov    %eax,%ebx
    7716:	83 ec 1c             	sub    $0x1c,%esp
	return posix_irq_lock();
    7719:	e8 4c dd ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    771e:	83 ec 0c             	sub    $0xc,%esp
    7721:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    7724:	68 8c da 00 00       	push   $0xda8c
    7729:	e8 25 0b 00 00       	call   8253 <z_spin_lock_valid>
    772e:	83 c4 10             	add    $0x10,%esp
    7731:	84 c0                	test   %al,%al
    7733:	75 38                	jne    776d <pend+0x63>
    7735:	6a 4a                	push   $0x4a
    7737:	68 00 9d 00 00       	push   $0x9d00
    773c:	68 35 9d 00 00       	push   $0x9d35
    7741:	68 e6 8b 00 00       	push   $0x8be6
    7746:	e8 44 c8 ff ff       	call   3f8f <printk>
    774b:	59                   	pop    %ecx
    774c:	58                   	pop    %eax
    774d:	68 8c da 00 00       	push   $0xda8c
    7752:	68 4a 9d 00 00       	push   $0x9d4a
    7757:	e8 33 c8 ff ff       	call   3f8f <printk>
    775c:	58                   	pop    %eax
    775d:	5a                   	pop    %edx
    775e:	6a 4a                	push   $0x4a
    7760:	68 00 9d 00 00       	push   $0x9d00
    7765:	e8 b9 c8 ff ff       	call   4023 <assert_post_action>
    776a:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    776d:	83 ec 0c             	sub    $0xc,%esp
    7770:	68 8c da 00 00       	push   $0xda8c
    7775:	e8 1b 0b 00 00       	call   8295 <z_spin_lock_set_owner>
    777a:	83 c4 10             	add    $0x10,%esp
		unready_thread(thread);
    777d:	89 d8                	mov    %ebx,%eax
    777f:	e8 51 ff ff ff       	call   76d5 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    7784:	80 4b 0d 02          	orb    $0x2,0xd(%ebx)
		if (wait_q != NULL) {
    7788:	85 ff                	test   %edi,%edi
    778a:	74 77                	je     7803 <pend+0xf9>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    778c:	81 fb c0 d7 00 00    	cmp    $0xd7c0,%ebx
			thread->base.pended_on = wait_q;
    7792:	89 7b 08             	mov    %edi,0x8(%ebx)
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    7795:	75 2d                	jne    77c4 <pend+0xba>
    7797:	68 1c 03 00 00       	push   $0x31c
    779c:	68 8e 9d 00 00       	push   $0x9d8e
    77a1:	68 4d 9e 00 00       	push   $0x9e4d
    77a6:	68 e6 8b 00 00       	push   $0x8be6
    77ab:	e8 df c7 ff ff       	call   3f8f <printk>
    77b0:	58                   	pop    %eax
    77b1:	5a                   	pop    %edx
    77b2:	68 1c 03 00 00       	push   $0x31c
    77b7:	68 8e 9d 00 00       	push   $0x9d8e
    77bc:	e8 62 c8 ff ff       	call   4023 <assert_post_action>
    77c1:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
    77c4:	8b 07                	mov    (%edi),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    77c6:	85 c0                	test   %eax,%eax
    77c8:	74 29                	je     77f3 <pend+0xe9>
    77ca:	39 c7                	cmp    %eax,%edi
    77cc:	74 25                	je     77f3 <pend+0xe9>
	if (thread_1->base.prio < thread_2->base.prio) {
    77ce:	8a 48 0e             	mov    0xe(%eax),%cl
    77d1:	38 4b 0e             	cmp    %cl,0xe(%ebx)
    77d4:	7c 0b                	jl     77e1 <pend+0xd7>
	return (node == list->tail) ? NULL : node->next;
    77d6:	39 47 04             	cmp    %eax,0x4(%edi)
    77d9:	74 18                	je     77f3 <pend+0xe9>
    77db:	8b 00                	mov    (%eax),%eax
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    77dd:	85 c0                	test   %eax,%eax
    77df:	eb eb                	jmp    77cc <pend+0xc2>
	node->prev = successor->prev;
    77e1:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
    77e4:	89 03                	mov    %eax,(%ebx)
	node->prev = successor->prev;
    77e6:	89 53 04             	mov    %edx,0x4(%ebx)
	successor->prev->next = node;
    77e9:	8b 50 04             	mov    0x4(%eax),%edx
    77ec:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
    77ee:	89 58 04             	mov    %ebx,0x4(%eax)
    77f1:	eb 10                	jmp    7803 <pend+0xf9>
	node->prev = list->tail;
    77f3:	8b 47 04             	mov    0x4(%edi),%eax
	node->next = list;
    77f6:	89 3b                	mov    %edi,(%ebx)
	node->prev = list->tail;
    77f8:	89 43 04             	mov    %eax,0x4(%ebx)
	list->tail->next = node;
    77fb:	8b 47 04             	mov    0x4(%edi),%eax
    77fe:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
    7800:	89 5f 04             	mov    %ebx,0x4(%edi)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    7803:	83 ec 0c             	sub    $0xc,%esp
    7806:	68 8c da 00 00       	push   $0xda8c
    780b:	e8 62 0a 00 00       	call   8272 <z_spin_unlock_valid>
    7810:	83 c4 10             	add    $0x10,%esp
    7813:	84 c0                	test   %al,%al
    7815:	75 38                	jne    784f <pend+0x145>
    7817:	6a 5d                	push   $0x5d
    7819:	68 00 9d 00 00       	push   $0x9d00
    781e:	68 62 9d 00 00       	push   $0x9d62
    7823:	68 e6 8b 00 00       	push   $0x8be6
    7828:	e8 62 c7 ff ff       	call   3f8f <printk>
    782d:	5a                   	pop    %edx
    782e:	59                   	pop    %ecx
    782f:	68 8c da 00 00       	push   $0xda8c
    7834:	68 79 9d 00 00       	push   $0x9d79
    7839:	e8 51 c7 ff ff       	call   3f8f <printk>
    783e:	5f                   	pop    %edi
    783f:	58                   	pop    %eax
    7840:	6a 5d                	push   $0x5d
    7842:	68 00 9d 00 00       	push   $0x9d00
    7847:	e8 d7 c7 ff ff       	call   4023 <assert_post_action>
    784c:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    784f:	83 ec 0c             	sub    $0xc,%esp
    7852:	ff 75 e4             	pushl  -0x1c(%ebp)
    7855:	e8 22 dc ff ff       	call   547c <posix_irq_unlock>
    785a:	83 c4 10             	add    $0x10,%esp
	if (timeout != K_FOREVER) {
    785d:	83 fe ff             	cmp    $0xffffffff,%esi
    7860:	74 2a                	je     788c <pend+0x182>
		ticks = _TICK_ALIGN + k_ms_to_ticks_ceil32(timeout);
    7862:	85 f6                	test   %esi,%esi
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    7864:	50                   	push   %eax
    7865:	b8 00 00 00 00       	mov    $0x0,%eax
    786a:	0f 49 c6             	cmovns %esi,%eax
    786d:	b9 0a 00 00 00       	mov    $0xa,%ecx
    7872:	31 d2                	xor    %edx,%edx
    7874:	83 c0 09             	add    $0x9,%eax
    7877:	83 c3 18             	add    $0x18,%ebx
    787a:	f7 f1                	div    %ecx
    787c:	40                   	inc    %eax
    787d:	50                   	push   %eax
    787e:	68 cb 71 00 00       	push   $0x71cb
    7883:	53                   	push   %ebx
    7884:	e8 0c 0b 00 00       	call   8395 <z_add_timeout>
    7889:	83 c4 10             	add    $0x10,%esp
}
    788c:	8d 65 f4             	lea    -0xc(%ebp),%esp
    788f:	5b                   	pop    %ebx
    7890:	5e                   	pop    %esi
    7891:	5f                   	pop    %edi
    7892:	5d                   	pop    %ebp
    7893:	c3                   	ret    

00007894 <z_pend_curr>:
{
    7894:	55                   	push   %ebp
	pend(_current, wait_q, timeout);
    7895:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
{
    789a:	89 e5                	mov    %esp,%ebp
    789c:	56                   	push   %esi
    789d:	53                   	push   %ebx
	pend(_current, wait_q, timeout);
    789e:	8b 4d 14             	mov    0x14(%ebp),%ecx
    78a1:	8b 55 10             	mov    0x10(%ebp),%edx
{
    78a4:	8b 5d 08             	mov    0x8(%ebp),%ebx
    78a7:	8b 75 0c             	mov    0xc(%ebp),%esi
	pend(_current, wait_q, timeout);
    78aa:	e8 5b fe ff ff       	call   770a <pend>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    78af:	83 ec 0c             	sub    $0xc,%esp
    78b2:	53                   	push   %ebx
    78b3:	e8 ba 09 00 00       	call   8272 <z_spin_unlock_valid>
    78b8:	83 c4 10             	add    $0x10,%esp
    78bb:	84 c0                	test   %al,%al
    78bd:	75 34                	jne    78f3 <z_pend_curr+0x5f>
    78bf:	6a 74                	push   $0x74
    78c1:	68 00 9d 00 00       	push   $0x9d00
    78c6:	68 62 9d 00 00       	push   $0x9d62
    78cb:	68 e6 8b 00 00       	push   $0x8be6
    78d0:	e8 ba c6 ff ff       	call   3f8f <printk>
    78d5:	58                   	pop    %eax
    78d6:	5a                   	pop    %edx
    78d7:	53                   	push   %ebx
    78d8:	68 79 9d 00 00       	push   $0x9d79
    78dd:	e8 ad c6 ff ff       	call   3f8f <printk>
    78e2:	59                   	pop    %ecx
    78e3:	5b                   	pop    %ebx
    78e4:	6a 74                	push   $0x74
    78e6:	68 00 9d 00 00       	push   $0x9d00
    78eb:	e8 33 c7 ff ff       	call   4023 <assert_post_action>
    78f0:	83 c4 10             	add    $0x10,%esp
    78f3:	89 75 08             	mov    %esi,0x8(%ebp)
}
    78f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
    78f9:	5b                   	pop    %ebx
    78fa:	5e                   	pop    %esi
    78fb:	5d                   	pop    %ebp
    78fc:	e9 e7 cd ff ff       	jmp    46e8 <arch_swap>

00007901 <z_unpend_first_thread>:
{
    7901:	55                   	push   %ebp
    7902:	89 e5                	mov    %esp,%ebp
    7904:	56                   	push   %esi
    7905:	53                   	push   %ebx
	return posix_irq_lock();
    7906:	e8 5f db ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    790b:	83 ec 0c             	sub    $0xc,%esp
    790e:	89 c6                	mov    %eax,%esi
    7910:	68 8c da 00 00       	push   $0xda8c
    7915:	e8 39 09 00 00       	call   8253 <z_spin_lock_valid>
    791a:	83 c4 10             	add    $0x10,%esp
    791d:	84 c0                	test   %al,%al
    791f:	75 38                	jne    7959 <z_unpend_first_thread+0x58>
    7921:	6a 4a                	push   $0x4a
    7923:	68 00 9d 00 00       	push   $0x9d00
    7928:	68 35 9d 00 00       	push   $0x9d35
    792d:	68 e6 8b 00 00       	push   $0x8be6
    7932:	e8 58 c6 ff ff       	call   3f8f <printk>
    7937:	5b                   	pop    %ebx
    7938:	58                   	pop    %eax
    7939:	68 8c da 00 00       	push   $0xda8c
    793e:	68 4a 9d 00 00       	push   $0x9d4a
    7943:	e8 47 c6 ff ff       	call   3f8f <printk>
    7948:	58                   	pop    %eax
    7949:	5a                   	pop    %edx
    794a:	6a 4a                	push   $0x4a
    794c:	68 00 9d 00 00       	push   $0x9d00
    7951:	e8 cd c6 ff ff       	call   4023 <assert_post_action>
    7956:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    7959:	83 ec 0c             	sub    $0xc,%esp
    795c:	68 8c da 00 00       	push   $0xda8c
    7961:	e8 2f 09 00 00       	call   8295 <z_spin_lock_set_owner>
    7966:	59                   	pop    %ecx
		ret = _priq_wait_best(&wait_q->waitq);
    7967:	ff 75 08             	pushl  0x8(%ebp)
    796a:	e8 11 f5 ff ff       	call   6e80 <z_priq_dumb_best>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    796f:	c7 04 24 8c da 00 00 	movl   $0xda8c,(%esp)
    7976:	89 c3                	mov    %eax,%ebx
    7978:	e8 f5 08 00 00       	call   8272 <z_spin_unlock_valid>
    797d:	83 c4 10             	add    $0x10,%esp
    7980:	84 c0                	test   %al,%al
    7982:	75 38                	jne    79bc <z_unpend_first_thread+0xbb>
    7984:	6a 5d                	push   $0x5d
    7986:	68 00 9d 00 00       	push   $0x9d00
    798b:	68 62 9d 00 00       	push   $0x9d62
    7990:	68 e6 8b 00 00       	push   $0x8be6
    7995:	e8 f5 c5 ff ff       	call   3f8f <printk>
    799a:	59                   	pop    %ecx
    799b:	58                   	pop    %eax
    799c:	68 8c da 00 00       	push   $0xda8c
    79a1:	68 79 9d 00 00       	push   $0x9d79
    79a6:	e8 e4 c5 ff ff       	call   3f8f <printk>
    79ab:	58                   	pop    %eax
    79ac:	5a                   	pop    %edx
    79ad:	6a 5d                	push   $0x5d
    79af:	68 00 9d 00 00       	push   $0x9d00
    79b4:	e8 6a c6 ff ff       	call   4023 <assert_post_action>
    79b9:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    79bc:	83 ec 0c             	sub    $0xc,%esp
    79bf:	56                   	push   %esi
    79c0:	e8 b7 da ff ff       	call   547c <posix_irq_unlock>
    79c5:	83 c4 10             	add    $0x10,%esp

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
    79c8:	85 db                	test   %ebx,%ebx
    79ca:	0f 84 e1 00 00 00    	je     7ab1 <z_unpend_first_thread+0x1b0>
	return posix_irq_lock();
    79d0:	e8 95 da ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    79d5:	83 ec 0c             	sub    $0xc,%esp
    79d8:	89 c6                	mov    %eax,%esi
    79da:	68 8c da 00 00       	push   $0xda8c
    79df:	e8 6f 08 00 00       	call   8253 <z_spin_lock_valid>
    79e4:	83 c4 10             	add    $0x10,%esp
    79e7:	84 c0                	test   %al,%al
    79e9:	75 38                	jne    7a23 <z_unpend_first_thread+0x122>
    79eb:	6a 4a                	push   $0x4a
    79ed:	68 00 9d 00 00       	push   $0x9d00
    79f2:	68 35 9d 00 00       	push   $0x9d35
    79f7:	68 e6 8b 00 00       	push   $0x8be6
    79fc:	e8 8e c5 ff ff       	call   3f8f <printk>
    7a01:	59                   	pop    %ecx
    7a02:	58                   	pop    %eax
    7a03:	68 8c da 00 00       	push   $0xda8c
    7a08:	68 4a 9d 00 00       	push   $0x9d4a
    7a0d:	e8 7d c5 ff ff       	call   3f8f <printk>
    7a12:	58                   	pop    %eax
    7a13:	5a                   	pop    %edx
    7a14:	6a 4a                	push   $0x4a
    7a16:	68 00 9d 00 00       	push   $0x9d00
    7a1b:	e8 03 c6 ff ff       	call   4023 <assert_post_action>
    7a20:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    7a23:	83 ec 0c             	sub    $0xc,%esp
    7a26:	68 8c da 00 00       	push   $0xda8c
    7a2b:	e8 65 08 00 00       	call   8295 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
    7a30:	8d 43 08             	lea    0x8(%ebx),%eax
    7a33:	83 c4 10             	add    $0x10,%esp
    7a36:	e8 49 ef ff ff       	call   6984 <pended_on.isra.18>
    7a3b:	52                   	push   %edx
    7a3c:	52                   	push   %edx
    7a3d:	53                   	push   %ebx
    7a3e:	50                   	push   %eax
    7a3f:	e8 f2 f2 ff ff       	call   6d36 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    7a44:	80 63 0d fd          	andb   $0xfd,0xd(%ebx)
		thread->base.pended_on = NULL;
    7a48:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    7a4f:	c7 04 24 8c da 00 00 	movl   $0xda8c,(%esp)
    7a56:	e8 17 08 00 00       	call   8272 <z_spin_unlock_valid>
    7a5b:	83 c4 10             	add    $0x10,%esp
    7a5e:	84 c0                	test   %al,%al
    7a60:	75 38                	jne    7a9a <z_unpend_first_thread+0x199>
    7a62:	6a 5d                	push   $0x5d
    7a64:	68 00 9d 00 00       	push   $0x9d00
    7a69:	68 62 9d 00 00       	push   $0x9d62
    7a6e:	68 e6 8b 00 00       	push   $0x8be6
    7a73:	e8 17 c5 ff ff       	call   3f8f <printk>
    7a78:	58                   	pop    %eax
    7a79:	5a                   	pop    %edx
    7a7a:	68 8c da 00 00       	push   $0xda8c
    7a7f:	68 79 9d 00 00       	push   $0x9d79
    7a84:	e8 06 c5 ff ff       	call   3f8f <printk>
    7a89:	59                   	pop    %ecx
    7a8a:	58                   	pop    %eax
    7a8b:	6a 5d                	push   $0x5d
    7a8d:	68 00 9d 00 00       	push   $0x9d00
    7a92:	e8 8c c5 ff ff       	call   4023 <assert_post_action>
    7a97:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    7a9a:	83 ec 0c             	sub    $0xc,%esp
    7a9d:	56                   	push   %esi
    7a9e:	e8 d9 d9 ff ff       	call   547c <posix_irq_unlock>
	return z_abort_timeout(&thread->base.timeout);
    7aa3:	8d 43 18             	lea    0x18(%ebx),%eax
    7aa6:	89 04 24             	mov    %eax,(%esp)
    7aa9:	e8 c0 0a 00 00       	call   856e <z_abort_timeout>
    7aae:	83 c4 10             	add    $0x10,%esp
}
    7ab1:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7ab4:	89 d8                	mov    %ebx,%eax
    7ab6:	5b                   	pop    %ebx
    7ab7:	5e                   	pop    %esi
    7ab8:	5d                   	pop    %ebp
    7ab9:	c3                   	ret    

00007aba <z_unpend_all>:
	}
	return thread;
}

int z_unpend_all(_wait_q_t *wait_q)
{
    7aba:	55                   	push   %ebp
	int need_sched = 0;
    7abb:	31 c0                	xor    %eax,%eax
{
    7abd:	89 e5                	mov    %esp,%ebp
    7abf:	56                   	push   %esi
    7ac0:	53                   	push   %ebx
    7ac1:	8b 75 08             	mov    0x8(%ebp),%esi
	return list->head == list;
    7ac4:	8b 1e                	mov    (%esi),%ebx
	struct k_thread *thread;

	while ((thread = z_waitq_head(wait_q)) != NULL) {
    7ac6:	85 db                	test   %ebx,%ebx
    7ac8:	74 1f                	je     7ae9 <z_unpend_all+0x2f>
    7aca:	39 de                	cmp    %ebx,%esi
    7acc:	74 1b                	je     7ae9 <z_unpend_all+0x2f>
		z_unpend_thread(thread);
    7ace:	83 ec 0c             	sub    $0xc,%esp
    7ad1:	53                   	push   %ebx
    7ad2:	e8 ba f2 ff ff       	call   6d91 <z_unpend_thread>
		z_ready_thread(thread);
    7ad7:	89 1c 24             	mov    %ebx,(%esp)
    7ada:	e8 20 f6 ff ff       	call   70ff <z_ready_thread>
    7adf:	83 c4 10             	add    $0x10,%esp
		need_sched = 1;
    7ae2:	b8 01 00 00 00       	mov    $0x1,%eax
    7ae7:	eb db                	jmp    7ac4 <z_unpend_all+0xa>
	}

	return need_sched;
}
    7ae9:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7aec:	5b                   	pop    %ebx
    7aed:	5e                   	pop    %esi
    7aee:	5d                   	pop    %ebp
    7aef:	c3                   	ret    

00007af0 <z_sched_init>:

void z_sched_init(void)
{
    7af0:	55                   	push   %ebp
    7af1:	89 e5                	mov    %esp,%ebp
    7af3:	83 ec 10             	sub    $0x10,%esp
	list->head = (sys_dnode_t *)list;
    7af6:	c7 05 e4 d8 00 00 e4 	movl   $0xd8e4,0xd8e4
    7afd:	d8 00 00 
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    7b00:	6a 00                	push   $0x0
    7b02:	6a 00                	push   $0x0
	list->tail = (sys_dnode_t *)list;
    7b04:	c7 05 e8 d8 00 00 e4 	movl   $0xd8e4,0xd8e8
    7b0b:	d8 00 00 
    7b0e:	e8 e2 ee ff ff       	call   69f5 <k_sched_time_slice_set>
    7b13:	83 c4 10             	add    $0x10,%esp
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
    7b16:	c9                   	leave  
    7b17:	c3                   	ret    

00007b18 <z_impl_k_yield>:
#endif
#endif

void z_impl_k_yield(void)
{
	__ASSERT(!arch_is_in_isr(), "");
    7b18:	83 3d c0 d8 00 00 00 	cmpl   $0x0,0xd8c0
{
    7b1f:	55                   	push   %ebp
    7b20:	89 e5                	mov    %esp,%ebp
    7b22:	56                   	push   %esi
    7b23:	53                   	push   %ebx
	__ASSERT(!arch_is_in_isr(), "");
    7b24:	74 39                	je     7b5f <z_impl_k_yield+0x47>
    7b26:	68 27 04 00 00       	push   $0x427
    7b2b:	68 8e 9d 00 00       	push   $0x9d8e
    7b30:	68 10 9e 00 00       	push   $0x9e10
    7b35:	68 e6 8b 00 00       	push   $0x8be6
    7b3a:	e8 50 c4 ff ff       	call   3f8f <printk>
    7b3f:	c7 04 24 22 9e 00 00 	movl   $0x9e22,(%esp)
    7b46:	e8 44 c4 ff ff       	call   3f8f <printk>
    7b4b:	5e                   	pop    %esi
    7b4c:	58                   	pop    %eax
    7b4d:	68 27 04 00 00       	push   $0x427
    7b52:	68 8e 9d 00 00       	push   $0x9d8e
    7b57:	e8 c7 c4 ff ff       	call   4023 <assert_post_action>
    7b5c:	83 c4 10             	add    $0x10,%esp

	if (!z_is_idle_thread_object(_current)) {
    7b5f:	81 3d c8 d8 00 00 c0 	cmpl   $0xd7c0,0xd8c8
    7b66:	d7 00 00 
    7b69:	0f 84 69 01 00 00    	je     7cd8 <z_impl_k_yield+0x1c0>
	return posix_irq_lock();
    7b6f:	e8 f6 d8 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    7b74:	83 ec 0c             	sub    $0xc,%esp
    7b77:	89 c6                	mov    %eax,%esi
    7b79:	68 8c da 00 00       	push   $0xda8c
    7b7e:	e8 d0 06 00 00       	call   8253 <z_spin_lock_valid>
    7b83:	83 c4 10             	add    $0x10,%esp
    7b86:	84 c0                	test   %al,%al
    7b88:	75 38                	jne    7bc2 <z_impl_k_yield+0xaa>
    7b8a:	6a 4a                	push   $0x4a
    7b8c:	68 00 9d 00 00       	push   $0x9d00
    7b91:	68 35 9d 00 00       	push   $0x9d35
    7b96:	68 e6 8b 00 00       	push   $0x8be6
    7b9b:	e8 ef c3 ff ff       	call   3f8f <printk>
    7ba0:	58                   	pop    %eax
    7ba1:	5a                   	pop    %edx
    7ba2:	68 8c da 00 00       	push   $0xda8c
    7ba7:	68 4a 9d 00 00       	push   $0x9d4a
    7bac:	e8 de c3 ff ff       	call   3f8f <printk>
    7bb1:	59                   	pop    %ecx
    7bb2:	5b                   	pop    %ebx
    7bb3:	6a 4a                	push   $0x4a
    7bb5:	68 00 9d 00 00       	push   $0x9d00
    7bba:	e8 64 c4 ff ff       	call   4023 <assert_post_action>
    7bbf:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    7bc2:	83 ec 0c             	sub    $0xc,%esp
    7bc5:	68 8c da 00 00       	push   $0xda8c
    7bca:	e8 c6 06 00 00       	call   8295 <z_spin_lock_set_owner>
    7bcf:	59                   	pop    %ecx
    7bd0:	5b                   	pop    %ebx
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
    7bd1:	ff 35 c8 d8 00 00    	pushl  0xd8c8
    7bd7:	68 e4 d8 00 00       	push   $0xd8e4
    7bdc:	e8 55 f1 ff ff       	call   6d36 <z_priq_dumb_remove>
						 _current);
			}
			_priq_run_add(&_kernel.ready_q.runq, _current);
    7be1:	8b 1d c8 d8 00 00    	mov    0xd8c8,%ebx
				_priq_run_remove(&_kernel.ready_q.runq,
    7be7:	83 c4 10             	add    $0x10,%esp
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
    7bea:	81 fb c0 d7 00 00    	cmp    $0xd7c0,%ebx
    7bf0:	75 2d                	jne    7c1f <z_impl_k_yield+0x107>
    7bf2:	68 1c 03 00 00       	push   $0x31c
    7bf7:	68 8e 9d 00 00       	push   $0x9d8e
    7bfc:	68 4d 9e 00 00       	push   $0x9e4d
    7c01:	68 e6 8b 00 00       	push   $0x8be6
    7c06:	e8 84 c3 ff ff       	call   3f8f <printk>
    7c0b:	58                   	pop    %eax
    7c0c:	5a                   	pop    %edx
    7c0d:	68 1c 03 00 00       	push   $0x31c
    7c12:	68 8e 9d 00 00       	push   $0x9d8e
    7c17:	e8 07 c4 ff ff       	call   4023 <assert_post_action>
    7c1c:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
    7c1f:	a1 e4 d8 00 00       	mov    0xd8e4,%eax
    7c24:	8b 15 e8 d8 00 00    	mov    0xd8e8,%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    7c2a:	3d e4 d8 00 00       	cmp    $0xd8e4,%eax
    7c2f:	74 26                	je     7c57 <z_impl_k_yield+0x13f>
    7c31:	85 c0                	test   %eax,%eax
    7c33:	74 22                	je     7c57 <z_impl_k_yield+0x13f>
	if (thread_1->base.prio < thread_2->base.prio) {
    7c35:	8a 48 0e             	mov    0xe(%eax),%cl
    7c38:	38 4b 0e             	cmp    %cl,0xe(%ebx)
    7c3b:	7c 08                	jl     7c45 <z_impl_k_yield+0x12d>
	return (node == list->tail) ? NULL : node->next;
    7c3d:	39 d0                	cmp    %edx,%eax
    7c3f:	74 16                	je     7c57 <z_impl_k_yield+0x13f>
    7c41:	8b 00                	mov    (%eax),%eax
    7c43:	eb ec                	jmp    7c31 <z_impl_k_yield+0x119>
	node->prev = successor->prev;
    7c45:	8b 50 04             	mov    0x4(%eax),%edx
	node->next = successor;
    7c48:	89 03                	mov    %eax,(%ebx)
	node->prev = successor->prev;
    7c4a:	89 53 04             	mov    %edx,0x4(%ebx)
	successor->prev->next = node;
    7c4d:	8b 50 04             	mov    0x4(%eax),%edx
    7c50:	89 1a                	mov    %ebx,(%edx)
	successor->prev = node;
    7c52:	89 58 04             	mov    %ebx,0x4(%eax)
    7c55:	eb 16                	jmp    7c6d <z_impl_k_yield+0x155>
	node->prev = list->tail;
    7c57:	89 53 04             	mov    %edx,0x4(%ebx)
	list->tail->next = node;
    7c5a:	a1 e8 d8 00 00       	mov    0xd8e8,%eax
	node->next = list;
    7c5f:	c7 03 e4 d8 00 00    	movl   $0xd8e4,(%ebx)
	list->tail->next = node;
    7c65:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
    7c67:	89 1d e8 d8 00 00    	mov    %ebx,0xd8e8
			z_mark_thread_as_queued(_current);
    7c6d:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
	thread->base.thread_state |= states;
    7c72:	80 48 0d 80          	orb    $0x80,0xd(%eax)
			update_cache(1);
    7c76:	b8 01 00 00 00       	mov    $0x1,%eax
    7c7b:	e8 14 f2 ff ff       	call   6e94 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    7c80:	83 ec 0c             	sub    $0xc,%esp
    7c83:	68 8c da 00 00       	push   $0xda8c
    7c88:	e8 e5 05 00 00       	call   8272 <z_spin_unlock_valid>
    7c8d:	83 c4 10             	add    $0x10,%esp
    7c90:	84 c0                	test   %al,%al
    7c92:	75 38                	jne    7ccc <z_impl_k_yield+0x1b4>
    7c94:	6a 5d                	push   $0x5d
    7c96:	68 00 9d 00 00       	push   $0x9d00
    7c9b:	68 62 9d 00 00       	push   $0x9d62
    7ca0:	68 e6 8b 00 00       	push   $0x8be6
    7ca5:	e8 e5 c2 ff ff       	call   3f8f <printk>
    7caa:	58                   	pop    %eax
    7cab:	5a                   	pop    %edx
    7cac:	68 8c da 00 00       	push   $0xda8c
    7cb1:	68 79 9d 00 00       	push   $0x9d79
    7cb6:	e8 d4 c2 ff ff       	call   3f8f <printk>
    7cbb:	59                   	pop    %ecx
    7cbc:	5b                   	pop    %ebx
    7cbd:	6a 5d                	push   $0x5d
    7cbf:	68 00 9d 00 00       	push   $0x9d00
    7cc4:	e8 5a c3 ff ff       	call   4023 <assert_post_action>
    7cc9:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    7ccc:	83 ec 0c             	sub    $0xc,%esp
    7ccf:	56                   	push   %esi
    7cd0:	e8 a7 d7 ff ff       	call   547c <posix_irq_unlock>
    7cd5:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
    7cd8:	e8 8d d7 ff ff       	call   546a <posix_irq_lock>
    7cdd:	83 ec 0c             	sub    $0xc,%esp
    7ce0:	50                   	push   %eax
    7ce1:	e8 02 ca ff ff       	call   46e8 <arch_swap>
    7ce6:	83 c4 10             	add    $0x10,%esp
		}
	}
	z_swap_unlocked();
}
    7ce9:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7cec:	5b                   	pop    %ebx
    7ced:	5e                   	pop    %esi
    7cee:	5d                   	pop    %ebp
    7cef:	c3                   	ret    

00007cf0 <z_impl_k_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_k_current_get(void)
{
    7cf0:	55                   	push   %ebp

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    7cf1:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
{
    7cf6:	89 e5                	mov    %esp,%ebp
}
    7cf8:	5d                   	pop    %ebp
    7cf9:	c3                   	ret    

00007cfa <z_impl_k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

int z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
    7cfa:	55                   	push   %ebp
    7cfb:	89 e5                	mov    %esp,%ebp
    7cfd:	8b 55 10             	mov    0x10(%ebp),%edx
    7d00:	8b 45 08             	mov    0x8(%ebp),%eax
    7d03:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || initial_count > limit) {
    7d06:	85 d2                	test   %edx,%edx
    7d08:	74 13                	je     7d1d <z_impl_k_sem_init+0x23>
    7d0a:	39 ca                	cmp    %ecx,%edx
    7d0c:	72 0f                	jb     7d1d <z_impl_k_sem_init+0x23>
		return -EINVAL;
	}

	sys_trace_void(SYS_TRACE_ID_SEMA_INIT);
	sem->count = initial_count;
    7d0e:	89 48 08             	mov    %ecx,0x8(%eax)
	sem->limit = limit;
    7d11:	89 50 0c             	mov    %edx,0xc(%eax)
	list->head = (sys_dnode_t *)list;
    7d14:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
    7d16:	89 40 04             	mov    %eax,0x4(%eax)
	SYS_TRACING_OBJ_INIT(k_sem, sem);

	z_object_init(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_INIT);

	return 0;
    7d19:	31 c0                	xor    %eax,%eax
    7d1b:	eb 05                	jmp    7d22 <z_impl_k_sem_init+0x28>
		return -EINVAL;
    7d1d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    7d22:	5d                   	pop    %ebp
    7d23:	c3                   	ret    

00007d24 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    7d24:	55                   	push   %ebp
    7d25:	89 e5                	mov    %esp,%ebp
    7d27:	56                   	push   %esi
    7d28:	53                   	push   %ebx
    7d29:	8b 5d 08             	mov    0x8(%ebp),%ebx
    7d2c:	e8 39 d7 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    7d31:	83 ec 0c             	sub    $0xc,%esp
    7d34:	89 c6                	mov    %eax,%esi
    7d36:	68 90 da 00 00       	push   $0xda90
    7d3b:	e8 13 05 00 00       	call   8253 <z_spin_lock_valid>
    7d40:	83 c4 10             	add    $0x10,%esp
    7d43:	84 c0                	test   %al,%al
    7d45:	75 38                	jne    7d7f <z_impl_k_sem_give+0x5b>
    7d47:	6a 4a                	push   $0x4a
    7d49:	68 00 9d 00 00       	push   $0x9d00
    7d4e:	68 35 9d 00 00       	push   $0x9d35
    7d53:	68 e6 8b 00 00       	push   $0x8be6
    7d58:	e8 32 c2 ff ff       	call   3f8f <printk>
    7d5d:	5a                   	pop    %edx
    7d5e:	59                   	pop    %ecx
    7d5f:	68 90 da 00 00       	push   $0xda90
    7d64:	68 4a 9d 00 00       	push   $0x9d4a
    7d69:	e8 21 c2 ff ff       	call   3f8f <printk>
    7d6e:	58                   	pop    %eax
    7d6f:	5a                   	pop    %edx
    7d70:	6a 4a                	push   $0x4a
    7d72:	68 00 9d 00 00       	push   $0x9d00
    7d77:	e8 a7 c2 ff ff       	call   4023 <assert_post_action>
    7d7c:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    7d7f:	83 ec 0c             	sub    $0xc,%esp
    7d82:	68 90 da 00 00       	push   $0xda90
    7d87:	e8 09 05 00 00       	call   8295 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
    7d8c:	89 1c 24             	mov    %ebx,(%esp)
    7d8f:	e8 6d fb ff ff       	call   7901 <z_unpend_first_thread>
    7d94:	83 c4 10             	add    $0x10,%esp

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
    7d97:	85 c0                	test   %eax,%eax
    7d99:	74 15                	je     7db0 <z_impl_k_sem_give+0x8c>
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    7d9b:	83 ec 0c             	sub    $0xc,%esp
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
    7d9e:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
    7da5:	50                   	push   %eax
    7da6:	e8 54 f3 ff ff       	call   70ff <z_ready_thread>
    7dab:	83 c4 10             	add    $0x10,%esp
    7dae:	eb 10                	jmp    7dc0 <z_impl_k_sem_give+0x9c>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    7db0:	8b 53 08             	mov    0x8(%ebx),%edx
    7db3:	31 c0                	xor    %eax,%eax
    7db5:	39 53 0c             	cmp    %edx,0xc(%ebx)
    7db8:	0f 95 c0             	setne  %al
    7dbb:	01 d0                	add    %edx,%eax
    7dbd:	89 43 08             	mov    %eax,0x8(%ebx)
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
    7dc0:	50                   	push   %eax
    7dc1:	50                   	push   %eax
    7dc2:	56                   	push   %esi
    7dc3:	68 90 da 00 00       	push   $0xda90
    7dc8:	e8 1b ed ff ff       	call   6ae8 <z_reschedule>
    7dcd:	83 c4 10             	add    $0x10,%esp
}
    7dd0:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7dd3:	5b                   	pop    %ebx
    7dd4:	5e                   	pop    %esi
    7dd5:	5d                   	pop    %ebp
    7dd6:	c3                   	ret    

00007dd7 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
    7dd7:	55                   	push   %ebp
    7dd8:	89 e5                	mov    %esp,%ebp
    7dda:	57                   	push   %edi
    7ddb:	56                   	push   %esi
    7ddc:	53                   	push   %ebx
    7ddd:	83 ec 0c             	sub    $0xc,%esp
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");
    7de0:	83 3d c0 d8 00 00 00 	cmpl   $0x0,0xd8c0
{
    7de7:	8b 75 08             	mov    0x8(%ebp),%esi
    7dea:	8b 7d 0c             	mov    0xc(%ebp),%edi
	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");
    7ded:	74 3d                	je     7e2c <z_impl_k_sem_take+0x55>
    7def:	85 ff                	test   %edi,%edi
    7df1:	74 39                	je     7e2c <z_impl_k_sem_take+0x55>
    7df3:	68 8c 00 00 00       	push   $0x8c
    7df8:	68 96 9e 00 00       	push   $0x9e96
    7dfd:	68 c5 9e 00 00       	push   $0x9ec5
    7e02:	68 e6 8b 00 00       	push   $0x8be6
    7e07:	e8 83 c1 ff ff       	call   3f8f <printk>
    7e0c:	c7 04 24 22 9e 00 00 	movl   $0x9e22,(%esp)
    7e13:	e8 77 c1 ff ff       	call   3f8f <printk>
    7e18:	59                   	pop    %ecx
    7e19:	5b                   	pop    %ebx
    7e1a:	68 8c 00 00 00       	push   $0x8c
    7e1f:	68 96 9e 00 00       	push   $0x9e96
    7e24:	e8 fa c1 ff ff       	call   4023 <assert_post_action>
    7e29:	83 c4 10             	add    $0x10,%esp
    7e2c:	e8 39 d6 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    7e31:	83 ec 0c             	sub    $0xc,%esp
    7e34:	89 c3                	mov    %eax,%ebx
    7e36:	68 90 da 00 00       	push   $0xda90
    7e3b:	e8 13 04 00 00       	call   8253 <z_spin_lock_valid>
    7e40:	83 c4 10             	add    $0x10,%esp
    7e43:	84 c0                	test   %al,%al
    7e45:	75 38                	jne    7e7f <z_impl_k_sem_take+0xa8>
    7e47:	6a 4a                	push   $0x4a
    7e49:	68 00 9d 00 00       	push   $0x9d00
    7e4e:	68 35 9d 00 00       	push   $0x9d35
    7e53:	68 e6 8b 00 00       	push   $0x8be6
    7e58:	e8 32 c1 ff ff       	call   3f8f <printk>
    7e5d:	59                   	pop    %ecx
    7e5e:	58                   	pop    %eax
    7e5f:	68 90 da 00 00       	push   $0xda90
    7e64:	68 4a 9d 00 00       	push   $0x9d4a
    7e69:	e8 21 c1 ff ff       	call   3f8f <printk>
    7e6e:	58                   	pop    %eax
    7e6f:	5a                   	pop    %edx
    7e70:	6a 4a                	push   $0x4a
    7e72:	68 00 9d 00 00       	push   $0x9d00
    7e77:	e8 a7 c1 ff ff       	call   4023 <assert_post_action>
    7e7c:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    7e7f:	83 ec 0c             	sub    $0xc,%esp
    7e82:	68 90 da 00 00       	push   $0xda90
    7e87:	e8 09 04 00 00       	call   8295 <z_spin_lock_set_owner>

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
    7e8c:	8b 46 08             	mov    0x8(%esi),%eax
    7e8f:	83 c4 10             	add    $0x10,%esp
    7e92:	85 c0                	test   %eax,%eax
    7e94:	74 60                	je     7ef6 <z_impl_k_sem_take+0x11f>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    7e96:	83 ec 0c             	sub    $0xc,%esp
		sem->count--;
    7e99:	48                   	dec    %eax
    7e9a:	89 46 08             	mov    %eax,0x8(%esi)
    7e9d:	68 90 da 00 00       	push   $0xda90
    7ea2:	e8 cb 03 00 00       	call   8272 <z_spin_unlock_valid>
    7ea7:	83 c4 10             	add    $0x10,%esp
    7eaa:	84 c0                	test   %al,%al
    7eac:	75 38                	jne    7ee6 <z_impl_k_sem_take+0x10f>
    7eae:	6a 5d                	push   $0x5d
    7eb0:	68 00 9d 00 00       	push   $0x9d00
    7eb5:	68 62 9d 00 00       	push   $0x9d62
    7eba:	68 e6 8b 00 00       	push   $0x8be6
    7ebf:	e8 cb c0 ff ff       	call   3f8f <printk>
    7ec4:	5f                   	pop    %edi
    7ec5:	58                   	pop    %eax
    7ec6:	68 90 da 00 00       	push   $0xda90
    7ecb:	68 79 9d 00 00       	push   $0x9d79
    7ed0:	e8 ba c0 ff ff       	call   3f8f <printk>
    7ed5:	58                   	pop    %eax
    7ed6:	5a                   	pop    %edx
    7ed7:	6a 5d                	push   $0x5d
    7ed9:	68 00 9d 00 00       	push   $0x9d00
    7ede:	e8 40 c1 ff ff       	call   4023 <assert_post_action>
    7ee3:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    7ee6:	83 ec 0c             	sub    $0xc,%esp
    7ee9:	53                   	push   %ebx
    7eea:	e8 8d d5 ff ff       	call   547c <posix_irq_unlock>
    7eef:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&lock, key);
		ret = 0;
    7ef2:	31 c0                	xor    %eax,%eax
		goto out;
    7ef4:	eb 73                	jmp    7f69 <z_impl_k_sem_take+0x192>
	}

	if (timeout == K_NO_WAIT) {
    7ef6:	85 ff                	test   %edi,%edi
    7ef8:	75 5f                	jne    7f59 <z_impl_k_sem_take+0x182>
    7efa:	83 ec 0c             	sub    $0xc,%esp
    7efd:	68 90 da 00 00       	push   $0xda90
    7f02:	e8 6b 03 00 00       	call   8272 <z_spin_unlock_valid>
    7f07:	83 c4 10             	add    $0x10,%esp
    7f0a:	84 c0                	test   %al,%al
    7f0c:	75 38                	jne    7f46 <z_impl_k_sem_take+0x16f>
    7f0e:	6a 5d                	push   $0x5d
    7f10:	68 00 9d 00 00       	push   $0x9d00
    7f15:	68 62 9d 00 00       	push   $0x9d62
    7f1a:	68 e6 8b 00 00       	push   $0x8be6
    7f1f:	e8 6b c0 ff ff       	call   3f8f <printk>
    7f24:	58                   	pop    %eax
    7f25:	5a                   	pop    %edx
    7f26:	68 90 da 00 00       	push   $0xda90
    7f2b:	68 79 9d 00 00       	push   $0x9d79
    7f30:	e8 5a c0 ff ff       	call   3f8f <printk>
    7f35:	59                   	pop    %ecx
    7f36:	5e                   	pop    %esi
    7f37:	6a 5d                	push   $0x5d
    7f39:	68 00 9d 00 00       	push   $0x9d00
    7f3e:	e8 e0 c0 ff ff       	call   4023 <assert_post_action>
    7f43:	83 c4 10             	add    $0x10,%esp
    7f46:	83 ec 0c             	sub    $0xc,%esp
    7f49:	53                   	push   %ebx
    7f4a:	e8 2d d5 ff ff       	call   547c <posix_irq_unlock>
    7f4f:	83 c4 10             	add    $0x10,%esp
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
    7f52:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
		goto out;
    7f57:	eb 10                	jmp    7f69 <z_impl_k_sem_take+0x192>
	}

	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    7f59:	57                   	push   %edi
    7f5a:	56                   	push   %esi
    7f5b:	53                   	push   %ebx
    7f5c:	68 90 da 00 00       	push   $0xda90
    7f61:	e8 2e f9 ff ff       	call   7894 <z_pend_curr>
    7f66:	83 c4 10             	add    $0x10,%esp

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
    7f69:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7f6c:	5b                   	pop    %ebx
    7f6d:	5e                   	pop    %esi
    7f6e:	5f                   	pop    %edi
    7f6f:	5d                   	pop    %ebp
    7f70:	c3                   	ret    

00007f71 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
    7f71:	55                   	push   %ebp
    7f72:	89 e5                	mov    %esp,%ebp
    7f74:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
    7f77:	6a ff                	push   $0xffffffff
    7f79:	68 00 04 00 00       	push   $0x400
    7f7e:	68 80 cf 00 00       	push   $0xcf80
    7f83:	68 00 d9 00 00       	push   $0xd900
    7f88:	e8 1f 03 00 00       	call   82ac <k_work_q_start>
    7f8d:	5a                   	pop    %edx
    7f8e:	59                   	pop    %ecx
	return z_impl_k_thread_name_set(thread_id, value);
    7f8f:	68 f1 9e 00 00       	push   $0x9ef1
    7f94:	68 14 d9 00 00       	push   $0xd914
    7f99:	e8 07 00 00 00       	call   7fa5 <z_impl_k_thread_name_set>
    7f9e:	83 c4 10             	add    $0x10,%esp
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
    7fa1:	31 c0                	xor    %eax,%eax
    7fa3:	c9                   	leave  
    7fa4:	c3                   	ret    

00007fa5 <z_impl_k_thread_name_set>:
	k_spin_unlock(&lock, key);
}
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
    7fa5:	55                   	push   %ebp
    7fa6:	89 e5                	mov    %esp,%ebp
    7fa8:	53                   	push   %ebx
    7fa9:	52                   	push   %edx
    7faa:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
    7fad:	85 db                	test   %ebx,%ebx
    7faf:	75 06                	jne    7fb7 <z_impl_k_thread_name_set+0x12>
		thread = _current;
    7fb1:	8b 1d c8 d8 00 00    	mov    0xd8c8,%ebx

__fortify_function char *
__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
		size_t __len))
{
  return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));
    7fb7:	50                   	push   %eax
    7fb8:	8d 43 3c             	lea    0x3c(%ebx),%eax
    7fbb:	6a 20                	push   $0x20
    7fbd:	ff 75 0c             	pushl  0xc(%ebp)
    7fc0:	50                   	push   %eax
    7fc1:	e8 fc ff ff ff       	call   7fc2 <z_impl_k_thread_name_set+0x1d>
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    7fc6:	c6 43 5b 00          	movb   $0x0,0x5b(%ebx)
    7fca:	83 c4 10             	add    $0x10,%esp
#else
	ARG_UNUSED(thread);
	ARG_UNUSED(value);
	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
    7fcd:	31 c0                	xor    %eax,%eax
    7fcf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7fd2:	c9                   	leave  
    7fd3:	c3                   	ret    

00007fd4 <k_thread_name_get>:
}
#include <syscalls/k_thread_name_set_mrsh.c>
#endif /* CONFIG_USERSPACE */

const char *k_thread_name_get(struct k_thread *thread)
{
    7fd4:	55                   	push   %ebp
    7fd5:	89 e5                	mov    %esp,%ebp
#ifdef CONFIG_THREAD_NAME
	return (const char *)thread->name;
    7fd7:	8b 45 08             	mov    0x8(%ebp),%eax
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
    7fda:	5d                   	pop    %ebp
	return (const char *)thread->name;
    7fdb:	83 c0 3c             	add    $0x3c,%eax
}
    7fde:	c3                   	ret    

00007fdf <z_new_thread_init>:
#endif /* CONFIG_STACK_POINTER_RANDOM */

void z_new_thread_init(struct k_thread *thread,
					    char *pStack, size_t stackSize,
					    int prio, unsigned int options)
{
    7fdf:	55                   	push   %ebp
    7fe0:	89 e5                	mov    %esp,%ebp
    7fe2:	8b 45 08             	mov    0x8(%ebp),%eax
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
    7fe5:	8b 55 18             	mov    0x18(%ebp),%edx
    7fe8:	88 50 0c             	mov    %dl,0xc(%eax)
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;
    7feb:	8b 55 14             	mov    0x14(%ebp),%edx
	thread_base->thread_state = (u8_t)initial_state;
    7fee:	c6 40 0d 04          	movb   $0x4,0xd(%eax)

	thread_base->sched_locked = 0U;
    7ff2:	c6 40 0f 00          	movb   $0x0,0xf(%eax)
	node->next = NULL;
    7ff6:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	node->prev = NULL;
    7ffd:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	thread_base->prio = priority;
    8004:	88 50 0e             	mov    %dl,0xe(%eax)
	thread->init_data = NULL;
    8007:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
	thread->fn_abort = NULL;
    800e:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
	thread->name[0] = '\0';
    8015:	c6 40 3c 00          	movb   $0x0,0x3c(%eax)
}
    8019:	5d                   	pop    %ebp
    801a:	c3                   	ret    

0000801b <z_setup_new_thread>:
{
    801b:	55                   	push   %ebp
    801c:	89 e5                	mov    %esp,%ebp
    801e:	56                   	push   %esi
    801f:	53                   	push   %ebx
    8020:	8b 5d 08             	mov    0x8(%ebp),%ebx
    8023:	8b 75 2c             	mov    0x2c(%ebp),%esi
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    8026:	83 ec 0c             	sub    $0xc,%esp
    8029:	ff 75 28             	pushl  0x28(%ebp)
    802c:	ff 75 24             	pushl  0x24(%ebp)
    802f:	ff 75 20             	pushl  0x20(%ebp)
    8032:	ff 75 1c             	pushl  0x1c(%ebp)
    8035:	ff 75 18             	pushl  0x18(%ebp)
    8038:	ff 75 14             	pushl  0x14(%ebp)
    803b:	ff 75 10             	pushl  0x10(%ebp)
    803e:	ff 75 0c             	pushl  0xc(%ebp)
    8041:	53                   	push   %ebx
    8042:	e8 0d c7 ff ff       	call   4754 <arch_new_thread>
    8047:	83 c4 30             	add    $0x30,%esp
	if (name != NULL) {
    804a:	85 f6                	test   %esi,%esi
    804c:	74 14                	je     8062 <z_setup_new_thread+0x47>
    804e:	50                   	push   %eax
    804f:	8d 43 3c             	lea    0x3c(%ebx),%eax
    8052:	6a 1f                	push   $0x1f
    8054:	56                   	push   %esi
    8055:	50                   	push   %eax
    8056:	e8 fc ff ff ff       	call   8057 <z_setup_new_thread+0x3c>
    805b:	83 c4 10             	add    $0x10,%esp
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    805e:	c6 43 5b 00          	movb   $0x0,0x5b(%ebx)
	if (!_current) {
    8062:	a1 c8 d8 00 00       	mov    0xd8c8,%eax
    8067:	85 c0                	test   %eax,%eax
    8069:	75 09                	jne    8074 <z_setup_new_thread+0x59>
		new_thread->resource_pool = NULL;
    806b:	c7 43 60 00 00 00 00 	movl   $0x0,0x60(%ebx)
		return;
    8072:	eb 06                	jmp    807a <z_setup_new_thread+0x5f>
	new_thread->resource_pool = _current->resource_pool;
    8074:	8b 40 60             	mov    0x60(%eax),%eax
    8077:	89 43 60             	mov    %eax,0x60(%ebx)
}
    807a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    807d:	5b                   	pop    %ebx
    807e:	5e                   	pop    %esi
    807f:	5d                   	pop    %ebp
    8080:	c3                   	ret    

00008081 <z_impl_k_thread_create>:
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
    8081:	83 3d c0 d8 00 00 00 	cmpl   $0x0,0xd8c0
{
    8088:	55                   	push   %ebp
    8089:	89 e5                	mov    %esp,%ebp
    808b:	56                   	push   %esi
    808c:	53                   	push   %ebx
    808d:	8b 75 08             	mov    0x8(%ebp),%esi
    8090:	8b 5d 2c             	mov    0x2c(%ebp),%ebx
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
    8093:	74 39                	je     80ce <z_impl_k_thread_create+0x4d>
    8095:	68 53 02 00 00       	push   $0x253
    809a:	68 fa 9e 00 00       	push   $0x9efa
    809f:	68 10 9e 00 00       	push   $0x9e10
    80a4:	68 e6 8b 00 00       	push   $0x8be6
    80a9:	e8 e1 be ff ff       	call   3f8f <printk>
    80ae:	c7 04 24 2c 9f 00 00 	movl   $0x9f2c,(%esp)
    80b5:	e8 d5 be ff ff       	call   3f8f <printk>
    80ba:	59                   	pop    %ecx
    80bb:	58                   	pop    %eax
    80bc:	68 53 02 00 00       	push   $0x253
    80c1:	68 fa 9e 00 00       	push   $0x9efa
    80c6:	e8 58 bf ff ff       	call   4023 <assert_post_action>
    80cb:	83 c4 10             	add    $0x10,%esp
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    80ce:	52                   	push   %edx
    80cf:	52                   	push   %edx
    80d0:	6a 00                	push   $0x0
    80d2:	ff 75 28             	pushl  0x28(%ebp)
    80d5:	ff 75 24             	pushl  0x24(%ebp)
    80d8:	ff 75 20             	pushl  0x20(%ebp)
    80db:	ff 75 1c             	pushl  0x1c(%ebp)
    80de:	ff 75 18             	pushl  0x18(%ebp)
    80e1:	ff 75 14             	pushl  0x14(%ebp)
    80e4:	ff 75 10             	pushl  0x10(%ebp)
    80e7:	ff 75 0c             	pushl  0xc(%ebp)
    80ea:	56                   	push   %esi
    80eb:	e8 2b ff ff ff       	call   801b <z_setup_new_thread>
    80f0:	83 c4 30             	add    $0x30,%esp
	if (delay != K_FOREVER) {
    80f3:	83 fb ff             	cmp    $0xffffffff,%ebx
    80f6:	74 2f                	je     8127 <z_impl_k_thread_create+0xa6>
	if (delay == 0) {
    80f8:	85 db                	test   %ebx,%ebx
    80fa:	75 0b                	jne    8107 <z_impl_k_thread_create+0x86>
	z_sched_start(thread);
    80fc:	83 ec 0c             	sub    $0xc,%esp
    80ff:	56                   	push   %esi
    8100:	e8 c8 f1 ff ff       	call   72cd <z_sched_start>
    8105:	eb 1d                	jmp    8124 <z_impl_k_thread_create+0xa3>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    8107:	50                   	push   %eax
    8108:	8d 43 09             	lea    0x9(%ebx),%eax
    810b:	b9 0a 00 00 00       	mov    $0xa,%ecx
    8110:	31 d2                	xor    %edx,%edx
    8112:	f7 f1                	div    %ecx
		s32_t ticks = _TICK_ALIGN + k_ms_to_ticks_ceil32(delay);
    8114:	40                   	inc    %eax
    8115:	50                   	push   %eax
    8116:	8d 46 18             	lea    0x18(%esi),%eax
    8119:	68 cb 71 00 00       	push   $0x71cb
    811e:	50                   	push   %eax
    811f:	e8 71 02 00 00       	call   8395 <z_add_timeout>
    8124:	83 c4 10             	add    $0x10,%esp
}
    8127:	8d 65 f8             	lea    -0x8(%ebp),%esp
    812a:	89 f0                	mov    %esi,%eax
    812c:	5b                   	pop    %ebx
    812d:	5e                   	pop    %esi
    812e:	5d                   	pop    %ebp
    812f:	c3                   	ret    

00008130 <z_init_static_threads>:
{
    8130:	55                   	push   %ebp
    8131:	89 e5                	mov    %esp,%ebp
    8133:	56                   	push   %esi
    8134:	53                   	push   %ebx
	_FOREACH_STATIC_THREAD(thread_data) {
    8135:	bb 08 d4 00 00       	mov    $0xd408,%ebx
    813a:	81 fb 08 d4 00 00    	cmp    $0xd408,%ebx
    8140:	76 39                	jbe    817b <z_init_static_threads+0x4b>
    8142:	68 e3 02 00 00       	push   $0x2e3
    8147:	68 fa 9e 00 00       	push   $0x9efa
    814c:	68 51 9f 00 00       	push   $0x9f51
    8151:	68 e6 8b 00 00       	push   $0x8be6
    8156:	e8 34 be ff ff       	call   3f8f <printk>
    815b:	c7 04 24 e1 9c 00 00 	movl   $0x9ce1,(%esp)
    8162:	e8 28 be ff ff       	call   3f8f <printk>
    8167:	58                   	pop    %eax
    8168:	5a                   	pop    %edx
    8169:	68 e3 02 00 00       	push   $0x2e3
    816e:	68 fa 9e 00 00       	push   $0x9efa
    8173:	e8 ab be ff ff       	call   4023 <assert_post_action>
    8178:	83 c4 10             	add    $0x10,%esp
    817b:	81 fb 08 d4 00 00    	cmp    $0xd408,%ebx
    8181:	73 31                	jae    81b4 <z_init_static_threads+0x84>
		z_setup_new_thread(
    8183:	51                   	push   %ecx
    8184:	51                   	push   %ecx
    8185:	ff 73 2c             	pushl  0x2c(%ebx)
    8188:	ff 73 20             	pushl  0x20(%ebx)
    818b:	ff 73 1c             	pushl  0x1c(%ebx)
    818e:	ff 73 18             	pushl  0x18(%ebx)
    8191:	ff 73 14             	pushl  0x14(%ebx)
    8194:	ff 73 10             	pushl  0x10(%ebx)
    8197:	ff 73 0c             	pushl  0xc(%ebx)
    819a:	ff 73 08             	pushl  0x8(%ebx)
    819d:	ff 73 04             	pushl  0x4(%ebx)
    81a0:	ff 33                	pushl  (%ebx)
    81a2:	e8 74 fe ff ff       	call   801b <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    81a7:	8b 03                	mov    (%ebx),%eax
		z_setup_new_thread(
    81a9:	83 c4 30             	add    $0x30,%esp
		thread_data->init_thread->init_data = thread_data;
    81ac:	89 58 34             	mov    %ebx,0x34(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
    81af:	83 c3 30             	add    $0x30,%ebx
    81b2:	eb 86                	jmp    813a <z_init_static_threads+0xa>
	_FOREACH_STATIC_THREAD(thread_data) {
    81b4:	bb 08 d4 00 00       	mov    $0xd408,%ebx
	k_sched_lock();
    81b9:	e8 25 ea ff ff       	call   6be3 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    81be:	81 fb 08 d4 00 00    	cmp    $0xd408,%ebx
    81c4:	76 39                	jbe    81ff <z_init_static_threads+0xcf>
    81c6:	68 02 03 00 00       	push   $0x302
    81cb:	68 fa 9e 00 00       	push   $0x9efa
    81d0:	68 51 9f 00 00       	push   $0x9f51
    81d5:	68 e6 8b 00 00       	push   $0x8be6
    81da:	e8 b0 bd ff ff       	call   3f8f <printk>
    81df:	c7 04 24 e1 9c 00 00 	movl   $0x9ce1,(%esp)
    81e6:	e8 a4 bd ff ff       	call   3f8f <printk>
    81eb:	58                   	pop    %eax
    81ec:	5a                   	pop    %edx
    81ed:	68 02 03 00 00       	push   $0x302
    81f2:	68 fa 9e 00 00       	push   $0x9efa
    81f7:	e8 27 be ff ff       	call   4023 <assert_post_action>
    81fc:	83 c4 10             	add    $0x10,%esp
    81ff:	81 fb 08 d4 00 00    	cmp    $0xd408,%ebx
    8205:	73 41                	jae    8248 <z_init_static_threads+0x118>
		if (thread_data->init_delay != K_FOREVER) {
    8207:	8b 43 24             	mov    0x24(%ebx),%eax
    820a:	83 f8 ff             	cmp    $0xffffffff,%eax
    820d:	74 31                	je     8240 <z_init_static_threads+0x110>
	if (delay == 0) {
    820f:	85 c0                	test   %eax,%eax
			schedule_new_thread(thread_data->init_thread,
    8211:	8b 0b                	mov    (%ebx),%ecx
	if (delay == 0) {
    8213:	75 0b                	jne    8220 <z_init_static_threads+0xf0>
	z_sched_start(thread);
    8215:	83 ec 0c             	sub    $0xc,%esp
    8218:	51                   	push   %ecx
    8219:	e8 af f0 ff ff       	call   72cd <z_sched_start>
    821e:	eb 1d                	jmp    823d <z_init_static_threads+0x10d>
    8220:	83 c0 09             	add    $0x9,%eax
    8223:	56                   	push   %esi
    8224:	31 d2                	xor    %edx,%edx
    8226:	be 0a 00 00 00       	mov    $0xa,%esi
    822b:	83 c1 18             	add    $0x18,%ecx
    822e:	f7 f6                	div    %esi
		s32_t ticks = _TICK_ALIGN + k_ms_to_ticks_ceil32(delay);
    8230:	40                   	inc    %eax
    8231:	50                   	push   %eax
    8232:	68 cb 71 00 00       	push   $0x71cb
    8237:	51                   	push   %ecx
    8238:	e8 58 01 00 00       	call   8395 <z_add_timeout>
    823d:	83 c4 10             	add    $0x10,%esp
	_FOREACH_STATIC_THREAD(thread_data) {
    8240:	83 c3 30             	add    $0x30,%ebx
    8243:	e9 76 ff ff ff       	jmp    81be <z_init_static_threads+0x8e>
}
    8248:	8d 65 f8             	lea    -0x8(%ebp),%esp
    824b:	5b                   	pop    %ebx
    824c:	5e                   	pop    %esi
    824d:	5d                   	pop    %ebp
	k_sched_unlock();
    824e:	e9 9f ec ff ff       	jmp    6ef2 <k_sched_unlock>

00008253 <z_spin_lock_valid>:
/* These spinlock assertion predicates are defined here because having
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
    8253:	55                   	push   %ebp
    8254:	89 e5                	mov    %esp,%ebp
	uintptr_t thread_cpu = l->thread_cpu;
    8256:	8b 45 08             	mov    0x8(%ebp),%eax
    8259:	8b 10                	mov    (%eax),%edx
    825b:	b0 01                	mov    $0x1,%al

	if (thread_cpu) {
    825d:	85 d2                	test   %edx,%edx
    825f:	74 0f                	je     8270 <z_spin_lock_valid+0x1d>
		if ((thread_cpu & 3) == _current_cpu->id) {
    8261:	0f b6 05 d4 d8 00 00 	movzbl 0xd8d4,%eax
    8268:	83 e2 03             	and    $0x3,%edx
    826b:	39 c2                	cmp    %eax,%edx
    826d:	0f 95 c0             	setne  %al
			return false;
		}
	}
	return true;
}
    8270:	5d                   	pop    %ebp
    8271:	c3                   	ret    

00008272 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
    8272:	55                   	push   %ebp
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
    8273:	0f b6 15 d4 d8 00 00 	movzbl 0xd8d4,%edx
    827a:	31 c0                	xor    %eax,%eax
    827c:	0b 15 c8 d8 00 00    	or     0xd8c8,%edx
{
    8282:	89 e5                	mov    %esp,%ebp
    8284:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
    8287:	39 11                	cmp    %edx,(%ecx)
    8289:	75 08                	jne    8293 <z_spin_unlock_valid+0x21>
		return false;
	}
	l->thread_cpu = 0;
    828b:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return true;
    8291:	b0 01                	mov    $0x1,%al
}
    8293:	5d                   	pop    %ebp
    8294:	c3                   	ret    

00008295 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
    8295:	55                   	push   %ebp
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
    8296:	0f b6 05 d4 d8 00 00 	movzbl 0xd8d4,%eax
    829d:	0b 05 c8 d8 00 00    	or     0xd8c8,%eax
{
    82a3:	89 e5                	mov    %esp,%ebp
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
    82a5:	8b 55 08             	mov    0x8(%ebp),%edx
    82a8:	89 02                	mov    %eax,(%edx)
}
    82aa:	5d                   	pop    %ebp
    82ab:	c3                   	ret    

000082ac <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
    82ac:	55                   	push   %ebp
    82ad:	89 e5                	mov    %esp,%ebp
    82af:	57                   	push   %edi
    82b0:	56                   	push   %esi
    82b1:	53                   	push   %ebx
    82b2:	83 ec 28             	sub    $0x28,%esp
    82b5:	8b 45 10             	mov    0x10(%ebp),%eax
    82b8:	8b 55 14             	mov    0x14(%ebp),%edx
    82bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
    82be:	8b 7d 0c             	mov    0xc(%ebp),%edi
    82c1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    82c4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	z_impl_k_queue_init(queue);
    82c7:	53                   	push   %ebx
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
    82c8:	8d 73 14             	lea    0x14(%ebx),%esi
    82cb:	e8 34 e5 ff ff       	call   6804 <z_impl_k_queue_init>
    82d0:	58                   	pop    %eax
    82d1:	5a                   	pop    %edx
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    82d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    82d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    82d8:	6a 00                	push   $0x0
    82da:	6a 00                	push   $0x0
    82dc:	52                   	push   %edx
    82dd:	6a 00                	push   $0x0
    82df:	6a 00                	push   $0x0
    82e1:	53                   	push   %ebx
    82e2:	68 e0 3f 00 00       	push   $0x3fe0
    82e7:	50                   	push   %eax
    82e8:	57                   	push   %edi
    82e9:	56                   	push   %esi
    82ea:	e8 92 fd ff ff       	call   8081 <z_impl_k_thread_create>
    82ef:	83 c4 30             	add    $0x30,%esp
	return z_impl_k_thread_name_set(thread_id, value);
    82f2:	89 75 08             	mov    %esi,0x8(%ebp)
    82f5:	c7 45 0c 7e 9f 00 00 	movl   $0x9f7e,0xc(%ebp)
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
    82fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
    82ff:	5b                   	pop    %ebx
    8300:	5e                   	pop    %esi
    8301:	5f                   	pop    %edi
    8302:	5d                   	pop    %ebp
    8303:	e9 9d fc ff ff       	jmp    7fa5 <z_impl_k_thread_name_set>

00008308 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    8308:	83 3d 94 da 00 00 00 	cmpl   $0x0,0xda94
{
    830f:	55                   	push   %ebp
    8310:	89 e5                	mov    %esp,%ebp
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    8312:	75 06                	jne    831a <elapsed+0x12>
}
    8314:	5d                   	pop    %ebp
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
    8315:	e9 9c be ff ff       	jmp    41b6 <z_clock_elapsed>
}
    831a:	31 c0                	xor    %eax,%eax
    831c:	5d                   	pop    %ebp
    831d:	c3                   	ret    

0000831e <next_timeout>:

static s32_t next_timeout(void)
{
    831e:	55                   	push   %ebp
    831f:	89 e5                	mov    %esp,%ebp
    8321:	53                   	push   %ebx
    8322:	51                   	push   %ecx
	return list->head == list;
    8323:	8b 1d 10 c2 00 00    	mov    0xc210,%ebx
	return sys_dlist_is_empty(list) ? NULL : list->head;
    8329:	81 fb 10 c2 00 00    	cmp    $0xc210,%ebx
    832f:	75 02                	jne    8333 <next_timeout+0x15>
    8331:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
    8333:	e8 d0 ff ff ff       	call   8308 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
    8338:	85 db                	test   %ebx,%ebx
    833a:	ba ff ff ff 7f       	mov    $0x7fffffff,%edx
    833f:	74 0d                	je     834e <next_timeout+0x30>
    8341:	8b 53 08             	mov    0x8(%ebx),%edx
    8344:	29 c2                	sub    %eax,%edx
    8346:	b8 00 00 00 00       	mov    $0x0,%eax
    834b:	0f 48 d0             	cmovs  %eax,%edx

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    834e:	a1 d0 d8 00 00       	mov    0xd8d0,%eax
    8353:	85 c0                	test   %eax,%eax
    8355:	74 04                	je     835b <next_timeout+0x3d>
    8357:	39 d0                	cmp    %edx,%eax
    8359:	7c 02                	jl     835d <next_timeout+0x3f>
    835b:	89 d0                	mov    %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    835d:	5a                   	pop    %edx
    835e:	5b                   	pop    %ebx
    835f:	5d                   	pop    %ebp
    8360:	c3                   	ret    

00008361 <remove_timeout>:
{
    8361:	55                   	push   %ebp
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    8362:	85 c0                	test   %eax,%eax
    8364:	8b 10                	mov    (%eax),%edx
    8366:	89 e5                	mov    %esp,%ebp
    8368:	74 12                	je     837c <remove_timeout+0x1b>
	return (node == list->tail) ? NULL : node->next;
    836a:	3b 05 14 c2 00 00    	cmp    0xc214,%eax
    8370:	74 0a                	je     837c <remove_timeout+0x1b>
	if (next(t) != NULL) {
    8372:	85 d2                	test   %edx,%edx
    8374:	74 06                	je     837c <remove_timeout+0x1b>
		next(t)->dticks += t->dticks;
    8376:	8b 48 08             	mov    0x8(%eax),%ecx
    8379:	01 4a 08             	add    %ecx,0x8(%edx)
	node->prev->next = node->next;
    837c:	8b 48 04             	mov    0x4(%eax),%ecx
    837f:	89 11                	mov    %edx,(%ecx)
	node->next->prev = node->prev;
    8381:	8b 10                	mov    (%eax),%edx
    8383:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
    8386:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
    838c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
    8393:	5d                   	pop    %ebp
    8394:	c3                   	ret    

00008395 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
    8395:	55                   	push   %ebp
    8396:	89 e5                	mov    %esp,%ebp
    8398:	57                   	push   %edi
    8399:	56                   	push   %esi
    839a:	53                   	push   %ebx
    839b:	83 ec 0c             	sub    $0xc,%esp
    839e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    83a1:	8b 7d 0c             	mov    0xc(%ebp),%edi
    83a4:	8b 75 10             	mov    0x10(%ebp),%esi
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
    83a7:	83 3b 00             	cmpl   $0x0,(%ebx)
    83aa:	74 33                	je     83df <z_add_timeout+0x4a>
    83ac:	6a 58                	push   $0x58
    83ae:	68 88 9f 00 00       	push   $0x9f88
    83b3:	68 bb 9f 00 00       	push   $0x9fbb
    83b8:	68 e6 8b 00 00       	push   $0x8be6
    83bd:	e8 cd bb ff ff       	call   3f8f <printk>
    83c2:	c7 04 24 22 9e 00 00 	movl   $0x9e22,(%esp)
    83c9:	e8 c1 bb ff ff       	call   3f8f <printk>
    83ce:	59                   	pop    %ecx
    83cf:	58                   	pop    %eax
    83d0:	6a 58                	push   $0x58
    83d2:	68 88 9f 00 00       	push   $0x9f88
    83d7:	e8 47 bc ff ff       	call   4023 <assert_post_action>
    83dc:	83 c4 10             	add    $0x10,%esp
	to->fn = fn;
	ticks = MAX(1, ticks);
    83df:	85 f6                	test   %esi,%esi
	to->fn = fn;
    83e1:	89 7b 0c             	mov    %edi,0xc(%ebx)
	ticks = MAX(1, ticks);
    83e4:	b8 01 00 00 00       	mov    $0x1,%eax
    83e9:	0f 4e f0             	cmovle %eax,%esi
	return posix_irq_lock();
    83ec:	e8 79 d0 ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    83f1:	83 ec 0c             	sub    $0xc,%esp
    83f4:	89 c7                	mov    %eax,%edi
    83f6:	68 98 da 00 00       	push   $0xda98
    83fb:	e8 53 fe ff ff       	call   8253 <z_spin_lock_valid>
    8400:	83 c4 10             	add    $0x10,%esp
    8403:	84 c0                	test   %al,%al
    8405:	75 38                	jne    843f <z_add_timeout+0xaa>
    8407:	6a 4a                	push   $0x4a
    8409:	68 00 9d 00 00       	push   $0x9d00
    840e:	68 35 9d 00 00       	push   $0x9d35
    8413:	68 e6 8b 00 00       	push   $0x8be6
    8418:	e8 72 bb ff ff       	call   3f8f <printk>
    841d:	59                   	pop    %ecx
    841e:	58                   	pop    %eax
    841f:	68 98 da 00 00       	push   $0xda98
    8424:	68 4a 9d 00 00       	push   $0x9d4a
    8429:	e8 61 bb ff ff       	call   3f8f <printk>
    842e:	58                   	pop    %eax
    842f:	5a                   	pop    %edx
    8430:	6a 4a                	push   $0x4a
    8432:	68 00 9d 00 00       	push   $0x9d00
    8437:	e8 e7 bb ff ff       	call   4023 <assert_post_action>
    843c:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    843f:	83 ec 0c             	sub    $0xc,%esp
    8442:	68 98 da 00 00       	push   $0xda98
    8447:	e8 49 fe ff ff       	call   8295 <z_spin_lock_set_owner>
    844c:	83 c4 10             	add    $0x10,%esp

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    844f:	e8 b4 fe ff ff       	call   8308 <elapsed>
    8454:	01 c6                	add    %eax,%esi
    8456:	89 73 08             	mov    %esi,0x8(%ebx)
	return list->head == list;
    8459:	8b 35 10 c2 00 00    	mov    0xc210,%esi
	return sys_dlist_is_empty(list) ? NULL : list->head;
    845f:	81 fe 10 c2 00 00    	cmp    $0xc210,%esi
    8465:	74 6f                	je     84d6 <z_add_timeout+0x141>
		for (t = first(); t != NULL; t = next(t)) {
    8467:	85 f6                	test   %esi,%esi
    8469:	74 6b                	je     84d6 <z_add_timeout+0x141>
			__ASSERT(t->dticks >= 0, "");
    846b:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
    846f:	79 33                	jns    84a4 <z_add_timeout+0x10f>
    8471:	6a 61                	push   $0x61
    8473:	68 88 9f 00 00       	push   $0x9f88
    8478:	68 db 9f 00 00       	push   $0x9fdb
    847d:	68 e6 8b 00 00       	push   $0x8be6
    8482:	e8 08 bb ff ff       	call   3f8f <printk>
    8487:	c7 04 24 22 9e 00 00 	movl   $0x9e22,(%esp)
    848e:	e8 fc ba ff ff       	call   3f8f <printk>
    8493:	58                   	pop    %eax
    8494:	5a                   	pop    %edx
    8495:	6a 61                	push   $0x61
    8497:	68 88 9f 00 00       	push   $0x9f88
    849c:	e8 82 bb ff ff       	call   4023 <assert_post_action>
    84a1:	83 c4 10             	add    $0x10,%esp

			if (t->dticks > to->dticks) {
    84a4:	8b 56 08             	mov    0x8(%esi),%edx
    84a7:	8b 43 08             	mov    0x8(%ebx),%eax
    84aa:	39 c2                	cmp    %eax,%edx
    84ac:	7e 17                	jle    84c5 <z_add_timeout+0x130>
				t->dticks -= to->dticks;
    84ae:	29 c2                	sub    %eax,%edx
	node->prev = successor->prev;
    84b0:	8b 46 04             	mov    0x4(%esi),%eax
    84b3:	89 56 08             	mov    %edx,0x8(%esi)
	node->next = successor;
    84b6:	89 33                	mov    %esi,(%ebx)
	node->prev = successor->prev;
    84b8:	89 43 04             	mov    %eax,0x4(%ebx)
	successor->prev->next = node;
    84bb:	8b 46 04             	mov    0x4(%esi),%eax
    84be:	89 18                	mov    %ebx,(%eax)
	successor->prev = node;
    84c0:	89 5e 04             	mov    %ebx,0x4(%esi)
    84c3:	eb 2c                	jmp    84f1 <z_add_timeout+0x15c>
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
    84c5:	29 d0                	sub    %edx,%eax
	return (node == list->tail) ? NULL : node->next;
    84c7:	39 35 14 c2 00 00    	cmp    %esi,0xc214
    84cd:	89 43 08             	mov    %eax,0x8(%ebx)
    84d0:	74 04                	je     84d6 <z_add_timeout+0x141>
    84d2:	8b 36                	mov    (%esi),%esi
    84d4:	eb 91                	jmp    8467 <z_add_timeout+0xd2>
	node->prev = list->tail;
    84d6:	a1 14 c2 00 00       	mov    0xc214,%eax
	node->next = list;
    84db:	c7 03 10 c2 00 00    	movl   $0xc210,(%ebx)
	node->prev = list->tail;
    84e1:	89 43 04             	mov    %eax,0x4(%ebx)
	list->tail->next = node;
    84e4:	a1 14 c2 00 00       	mov    0xc214,%eax
    84e9:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
    84eb:	89 1d 14 c2 00 00    	mov    %ebx,0xc214
	return list->head == list;
    84f1:	a1 10 c2 00 00       	mov    0xc210,%eax

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    84f6:	39 c3                	cmp    %eax,%ebx
    84f8:	75 19                	jne    8513 <z_add_timeout+0x17e>
    84fa:	3d 10 c2 00 00       	cmp    $0xc210,%eax
    84ff:	74 12                	je     8513 <z_add_timeout+0x17e>
			z_clock_set_timeout(next_timeout(), false);
    8501:	e8 18 fe ff ff       	call   831e <next_timeout>
    8506:	56                   	push   %esi
    8507:	56                   	push   %esi
    8508:	6a 00                	push   $0x0
    850a:	50                   	push   %eax
    850b:	e8 75 bc ff ff       	call   4185 <z_clock_set_timeout>
    8510:	83 c4 10             	add    $0x10,%esp
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    8513:	83 ec 0c             	sub    $0xc,%esp
    8516:	68 98 da 00 00       	push   $0xda98
    851b:	e8 52 fd ff ff       	call   8272 <z_spin_unlock_valid>
    8520:	83 c4 10             	add    $0x10,%esp
    8523:	84 c0                	test   %al,%al
    8525:	75 38                	jne    855f <z_add_timeout+0x1ca>
    8527:	6a 5d                	push   $0x5d
    8529:	68 00 9d 00 00       	push   $0x9d00
    852e:	68 62 9d 00 00       	push   $0x9d62
    8533:	68 e6 8b 00 00       	push   $0x8be6
    8538:	e8 52 ba ff ff       	call   3f8f <printk>
    853d:	58                   	pop    %eax
    853e:	5a                   	pop    %edx
    853f:	68 98 da 00 00       	push   $0xda98
    8544:	68 79 9d 00 00       	push   $0x9d79
    8549:	e8 41 ba ff ff       	call   3f8f <printk>
    854e:	59                   	pop    %ecx
    854f:	5b                   	pop    %ebx
    8550:	6a 5d                	push   $0x5d
    8552:	68 00 9d 00 00       	push   $0x9d00
    8557:	e8 c7 ba ff ff       	call   4023 <assert_post_action>
    855c:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    855f:	89 7d 08             	mov    %edi,0x8(%ebp)
		}
	}
}
    8562:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8565:	5b                   	pop    %ebx
    8566:	5e                   	pop    %esi
    8567:	5f                   	pop    %edi
    8568:	5d                   	pop    %ebp
    8569:	e9 0e cf ff ff       	jmp    547c <posix_irq_unlock>

0000856e <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
    856e:	55                   	push   %ebp
    856f:	89 e5                	mov    %esp,%ebp
    8571:	57                   	push   %edi
    8572:	56                   	push   %esi
    8573:	53                   	push   %ebx
    8574:	83 ec 0c             	sub    $0xc,%esp
    8577:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
    857a:	e8 eb ce ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    857f:	83 ec 0c             	sub    $0xc,%esp
    8582:	89 c7                	mov    %eax,%edi
    8584:	68 98 da 00 00       	push   $0xda98
    8589:	e8 c5 fc ff ff       	call   8253 <z_spin_lock_valid>
    858e:	83 c4 10             	add    $0x10,%esp
    8591:	84 c0                	test   %al,%al
    8593:	75 38                	jne    85cd <z_abort_timeout+0x5f>
    8595:	6a 4a                	push   $0x4a
    8597:	68 00 9d 00 00       	push   $0x9d00
    859c:	68 35 9d 00 00       	push   $0x9d35
    85a1:	68 e6 8b 00 00       	push   $0x8be6
    85a6:	e8 e4 b9 ff ff       	call   3f8f <printk>
    85ab:	58                   	pop    %eax
    85ac:	5a                   	pop    %edx
    85ad:	68 98 da 00 00       	push   $0xda98
    85b2:	68 4a 9d 00 00       	push   $0x9d4a
    85b7:	e8 d3 b9 ff ff       	call   3f8f <printk>
    85bc:	59                   	pop    %ecx
    85bd:	5b                   	pop    %ebx
    85be:	6a 4a                	push   $0x4a
    85c0:	68 00 9d 00 00       	push   $0x9d00
    85c5:	e8 59 ba ff ff       	call   4023 <assert_post_action>
    85ca:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    85cd:	83 ec 0c             	sub    $0xc,%esp
	int ret = -EINVAL;
    85d0:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
    85d5:	68 98 da 00 00       	push   $0xda98
    85da:	e8 b6 fc ff ff       	call   8295 <z_spin_lock_set_owner>
    85df:	83 c4 10             	add    $0x10,%esp

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    85e2:	83 3e 00             	cmpl   $0x0,(%esi)
    85e5:	74 09                	je     85f0 <z_abort_timeout+0x82>
			remove_timeout(to);
    85e7:	89 f0                	mov    %esi,%eax
			ret = 0;
    85e9:	31 db                	xor    %ebx,%ebx
			remove_timeout(to);
    85eb:	e8 71 fd ff ff       	call   8361 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    85f0:	83 ec 0c             	sub    $0xc,%esp
    85f3:	68 98 da 00 00       	push   $0xda98
    85f8:	e8 75 fc ff ff       	call   8272 <z_spin_unlock_valid>
    85fd:	83 c4 10             	add    $0x10,%esp
    8600:	84 c0                	test   %al,%al
    8602:	75 38                	jne    863c <z_abort_timeout+0xce>
    8604:	6a 5d                	push   $0x5d
    8606:	68 00 9d 00 00       	push   $0x9d00
    860b:	68 62 9d 00 00       	push   $0x9d62
    8610:	68 e6 8b 00 00       	push   $0x8be6
    8615:	e8 75 b9 ff ff       	call   3f8f <printk>
    861a:	58                   	pop    %eax
    861b:	5a                   	pop    %edx
    861c:	68 98 da 00 00       	push   $0xda98
    8621:	68 79 9d 00 00       	push   $0x9d79
    8626:	e8 64 b9 ff ff       	call   3f8f <printk>
    862b:	59                   	pop    %ecx
    862c:	5e                   	pop    %esi
    862d:	6a 5d                	push   $0x5d
    862f:	68 00 9d 00 00       	push   $0x9d00
    8634:	e8 ea b9 ff ff       	call   4023 <assert_post_action>
    8639:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    863c:	83 ec 0c             	sub    $0xc,%esp
    863f:	57                   	push   %edi
    8640:	e8 37 ce ff ff       	call   547c <posix_irq_unlock>
    8645:	83 c4 10             	add    $0x10,%esp
		}
	}

	return ret;
}
    8648:	8d 65 f4             	lea    -0xc(%ebp),%esp
    864b:	89 d8                	mov    %ebx,%eax
    864d:	5b                   	pop    %ebx
    864e:	5e                   	pop    %esi
    864f:	5f                   	pop    %edi
    8650:	5d                   	pop    %ebp
    8651:	c3                   	ret    

00008652 <z_get_next_timeout_expiry>:

	return ticks - elapsed();
}

s32_t z_get_next_timeout_expiry(void)
{
    8652:	55                   	push   %ebp
    8653:	89 e5                	mov    %esp,%ebp
    8655:	56                   	push   %esi
    8656:	53                   	push   %ebx
	return posix_irq_lock();
    8657:	e8 0e ce ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    865c:	83 ec 0c             	sub    $0xc,%esp
    865f:	89 c6                	mov    %eax,%esi
    8661:	68 98 da 00 00       	push   $0xda98
    8666:	e8 e8 fb ff ff       	call   8253 <z_spin_lock_valid>
    866b:	83 c4 10             	add    $0x10,%esp
    866e:	84 c0                	test   %al,%al
    8670:	75 38                	jne    86aa <z_get_next_timeout_expiry+0x58>
    8672:	6a 4a                	push   $0x4a
    8674:	68 00 9d 00 00       	push   $0x9d00
    8679:	68 35 9d 00 00       	push   $0x9d35
    867e:	68 e6 8b 00 00       	push   $0x8be6
    8683:	e8 07 b9 ff ff       	call   3f8f <printk>
    8688:	58                   	pop    %eax
    8689:	5a                   	pop    %edx
    868a:	68 98 da 00 00       	push   $0xda98
    868f:	68 4a 9d 00 00       	push   $0x9d4a
    8694:	e8 f6 b8 ff ff       	call   3f8f <printk>
    8699:	59                   	pop    %ecx
    869a:	5b                   	pop    %ebx
    869b:	6a 4a                	push   $0x4a
    869d:	68 00 9d 00 00       	push   $0x9d00
    86a2:	e8 7c b9 ff ff       	call   4023 <assert_post_action>
    86a7:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    86aa:	83 ec 0c             	sub    $0xc,%esp
    86ad:	68 98 da 00 00       	push   $0xda98
    86b2:	e8 de fb ff ff       	call   8295 <z_spin_lock_set_owner>
    86b7:	83 c4 10             	add    $0x10,%esp
	s32_t ret = K_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
    86ba:	e8 5f fc ff ff       	call   831e <next_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    86bf:	83 ec 0c             	sub    $0xc,%esp
    86c2:	89 c3                	mov    %eax,%ebx
    86c4:	68 98 da 00 00       	push   $0xda98
    86c9:	e8 a4 fb ff ff       	call   8272 <z_spin_unlock_valid>
    86ce:	83 c4 10             	add    $0x10,%esp
    86d1:	84 c0                	test   %al,%al
    86d3:	75 38                	jne    870d <z_get_next_timeout_expiry+0xbb>
    86d5:	6a 5d                	push   $0x5d
    86d7:	68 00 9d 00 00       	push   $0x9d00
    86dc:	68 62 9d 00 00       	push   $0x9d62
    86e1:	68 e6 8b 00 00       	push   $0x8be6
    86e6:	e8 a4 b8 ff ff       	call   3f8f <printk>
    86eb:	58                   	pop    %eax
    86ec:	5a                   	pop    %edx
    86ed:	68 98 da 00 00       	push   $0xda98
    86f2:	68 79 9d 00 00       	push   $0x9d79
    86f7:	e8 93 b8 ff ff       	call   3f8f <printk>
    86fc:	59                   	pop    %ecx
    86fd:	58                   	pop    %eax
    86fe:	6a 5d                	push   $0x5d
    8700:	68 00 9d 00 00       	push   $0x9d00
    8705:	e8 19 b9 ff ff       	call   4023 <assert_post_action>
    870a:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    870d:	83 ec 0c             	sub    $0xc,%esp
    8710:	56                   	push   %esi
    8711:	e8 66 cd ff ff       	call   547c <posix_irq_unlock>
    8716:	83 c4 10             	add    $0x10,%esp
	}
	return ret;
}
    8719:	8d 65 f8             	lea    -0x8(%ebp),%esp
    871c:	89 d8                	mov    %ebx,%eax
    871e:	5b                   	pop    %ebx
    871f:	5e                   	pop    %esi
    8720:	5d                   	pop    %ebp
    8721:	c3                   	ret    

00008722 <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
    8722:	55                   	push   %ebp
    8723:	89 e5                	mov    %esp,%ebp
    8725:	57                   	push   %edi
    8726:	56                   	push   %esi
    8727:	53                   	push   %ebx
    8728:	83 ec 0c             	sub    $0xc,%esp
    872b:	8b 75 08             	mov    0x8(%ebp),%esi
    872e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	return posix_irq_lock();
    8731:	e8 34 cd ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    8736:	83 ec 0c             	sub    $0xc,%esp
    8739:	89 c7                	mov    %eax,%edi
    873b:	68 98 da 00 00       	push   $0xda98
    8740:	e8 0e fb ff ff       	call   8253 <z_spin_lock_valid>
    8745:	83 c4 10             	add    $0x10,%esp
    8748:	84 c0                	test   %al,%al
    874a:	75 38                	jne    8784 <z_set_timeout_expiry+0x62>
    874c:	6a 4a                	push   $0x4a
    874e:	68 00 9d 00 00       	push   $0x9d00
    8753:	68 35 9d 00 00       	push   $0x9d35
    8758:	68 e6 8b 00 00       	push   $0x8be6
    875d:	e8 2d b8 ff ff       	call   3f8f <printk>
    8762:	58                   	pop    %eax
    8763:	5a                   	pop    %edx
    8764:	68 98 da 00 00       	push   $0xda98
    8769:	68 4a 9d 00 00       	push   $0x9d4a
    876e:	e8 1c b8 ff ff       	call   3f8f <printk>
    8773:	59                   	pop    %ecx
    8774:	58                   	pop    %eax
    8775:	6a 4a                	push   $0x4a
    8777:	68 00 9d 00 00       	push   $0x9d00
    877c:	e8 a2 b8 ff ff       	call   4023 <assert_post_action>
    8781:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    8784:	83 ec 0c             	sub    $0xc,%esp
    8787:	68 98 da 00 00       	push   $0xda98
    878c:	e8 04 fb ff ff       	call   8295 <z_spin_lock_set_owner>
    8791:	83 c4 10             	add    $0x10,%esp
	LOCKED(&timeout_lock) {
		int next = next_timeout();
    8794:	e8 85 fb ff ff       	call   831e <next_timeout>
		bool sooner = (next == K_FOREVER) || (ticks < next);
    8799:	83 f8 ff             	cmp    $0xffffffff,%eax
    879c:	0f 94 c1             	sete   %cl
    879f:	39 f0                	cmp    %esi,%eax
    87a1:	0f 9f c2             	setg   %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    87a4:	08 d1                	or     %dl,%cl
    87a6:	74 12                	je     87ba <z_set_timeout_expiry+0x98>
    87a8:	48                   	dec    %eax
    87a9:	7e 0f                	jle    87ba <z_set_timeout_expiry+0x98>
			z_clock_set_timeout(ticks, idle);
    87ab:	0f b6 db             	movzbl %bl,%ebx
    87ae:	50                   	push   %eax
    87af:	50                   	push   %eax
    87b0:	53                   	push   %ebx
    87b1:	56                   	push   %esi
    87b2:	e8 ce b9 ff ff       	call   4185 <z_clock_set_timeout>
    87b7:	83 c4 10             	add    $0x10,%esp
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    87ba:	83 ec 0c             	sub    $0xc,%esp
    87bd:	68 98 da 00 00       	push   $0xda98
    87c2:	e8 ab fa ff ff       	call   8272 <z_spin_unlock_valid>
    87c7:	83 c4 10             	add    $0x10,%esp
    87ca:	84 c0                	test   %al,%al
    87cc:	75 38                	jne    8806 <z_set_timeout_expiry+0xe4>
    87ce:	6a 5d                	push   $0x5d
    87d0:	68 00 9d 00 00       	push   $0x9d00
    87d5:	68 62 9d 00 00       	push   $0x9d62
    87da:	68 e6 8b 00 00       	push   $0x8be6
    87df:	e8 ab b7 ff ff       	call   3f8f <printk>
    87e4:	58                   	pop    %eax
    87e5:	5a                   	pop    %edx
    87e6:	68 98 da 00 00       	push   $0xda98
    87eb:	68 79 9d 00 00       	push   $0x9d79
    87f0:	e8 9a b7 ff ff       	call   3f8f <printk>
    87f5:	59                   	pop    %ecx
    87f6:	5b                   	pop    %ebx
    87f7:	6a 5d                	push   $0x5d
    87f9:	68 00 9d 00 00       	push   $0x9d00
    87fe:	e8 20 b8 ff ff       	call   4023 <assert_post_action>
    8803:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    8806:	89 7d 08             	mov    %edi,0x8(%ebp)
		}
	}
}
    8809:	8d 65 f4             	lea    -0xc(%ebp),%esp
    880c:	5b                   	pop    %ebx
    880d:	5e                   	pop    %esi
    880e:	5f                   	pop    %edi
    880f:	5d                   	pop    %ebp
    8810:	e9 67 cc ff ff       	jmp    547c <posix_irq_unlock>

00008815 <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
    8815:	55                   	push   %ebp
    8816:	89 e5                	mov    %esp,%ebp
    8818:	57                   	push   %edi
    8819:	56                   	push   %esi
    881a:	53                   	push   %ebx
    881b:	83 ec 28             	sub    $0x28,%esp
    881e:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    8821:	53                   	push   %ebx
    8822:	e8 0a ed ff ff       	call   7531 <z_time_slice>
    8827:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
    882a:	e8 3b cc ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    882f:	83 ec 0c             	sub    $0xc,%esp
    8832:	89 c6                	mov    %eax,%esi
    8834:	68 98 da 00 00       	push   $0xda98
    8839:	e8 15 fa ff ff       	call   8253 <z_spin_lock_valid>
    883e:	83 c4 10             	add    $0x10,%esp
    8841:	84 c0                	test   %al,%al
    8843:	75 38                	jne    887d <z_clock_announce+0x68>
    8845:	6a 4a                	push   $0x4a
    8847:	68 00 9d 00 00       	push   $0x9d00
    884c:	68 35 9d 00 00       	push   $0x9d35
    8851:	68 e6 8b 00 00       	push   $0x8be6
    8856:	e8 34 b7 ff ff       	call   3f8f <printk>
    885b:	59                   	pop    %ecx
    885c:	5f                   	pop    %edi
    885d:	68 98 da 00 00       	push   $0xda98
    8862:	68 4a 9d 00 00       	push   $0x9d4a
    8867:	e8 23 b7 ff ff       	call   3f8f <printk>
    886c:	58                   	pop    %eax
    886d:	5a                   	pop    %edx
    886e:	6a 4a                	push   $0x4a
    8870:	68 00 9d 00 00       	push   $0x9d00
    8875:	e8 a9 b7 ff ff       	call   4023 <assert_post_action>
    887a:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    887d:	83 ec 0c             	sub    $0xc,%esp
    8880:	68 98 da 00 00       	push   $0xda98
    8885:	e8 0b fa ff ff       	call   8295 <z_spin_lock_set_owner>
    888a:	83 c4 10             	add    $0x10,%esp
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    888d:	89 1d 94 da 00 00    	mov    %ebx,0xda94
    8893:	8b 1d 10 c2 00 00    	mov    0xc210,%ebx
    8899:	a1 f8 d9 00 00       	mov    0xd9f8,%eax
    889e:	8b 15 fc d9 00 00    	mov    0xd9fc,%edx
    88a4:	8b 3d 94 da 00 00    	mov    0xda94,%edi

	while (first() != NULL && first()->dticks <= announce_remaining) {
    88aa:	85 db                	test   %ebx,%ebx
    88ac:	89 45 e0             	mov    %eax,-0x20(%ebp)
    88af:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    88b2:	0f 84 0c 01 00 00    	je     89c4 <z_clock_announce+0x1af>
    88b8:	81 fb 10 c2 00 00    	cmp    $0xc210,%ebx
    88be:	0f 84 00 01 00 00    	je     89c4 <z_clock_announce+0x1af>
    88c4:	8b 4b 08             	mov    0x8(%ebx),%ecx
    88c7:	39 f9                	cmp    %edi,%ecx
    88c9:	0f 8f f0 00 00 00    	jg     89bf <z_clock_announce+0x1aa>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    88cf:	89 c8                	mov    %ecx,%eax
		announce_remaining -= dt;
		t->dticks = 0;
    88d1:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		curr_tick += dt;
    88d8:	99                   	cltd   
    88d9:	03 45 e0             	add    -0x20(%ebp),%eax
    88dc:	13 55 e4             	adc    -0x1c(%ebp),%edx
		announce_remaining -= dt;
    88df:	29 cf                	sub    %ecx,%edi
    88e1:	89 3d 94 da 00 00    	mov    %edi,0xda94
		curr_tick += dt;
    88e7:	a3 f8 d9 00 00       	mov    %eax,0xd9f8
		remove_timeout(t);
    88ec:	89 d8                	mov    %ebx,%eax
		curr_tick += dt;
    88ee:	89 15 fc d9 00 00    	mov    %edx,0xd9fc
		remove_timeout(t);
    88f4:	e8 68 fa ff ff       	call   8361 <remove_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    88f9:	83 ec 0c             	sub    $0xc,%esp
    88fc:	68 98 da 00 00       	push   $0xda98
    8901:	e8 6c f9 ff ff       	call   8272 <z_spin_unlock_valid>
    8906:	83 c4 10             	add    $0x10,%esp
    8909:	84 c0                	test   %al,%al
    890b:	75 38                	jne    8945 <z_clock_announce+0x130>
    890d:	6a 5d                	push   $0x5d
    890f:	68 00 9d 00 00       	push   $0x9d00
    8914:	68 62 9d 00 00       	push   $0x9d62
    8919:	68 e6 8b 00 00       	push   $0x8be6
    891e:	e8 6c b6 ff ff       	call   3f8f <printk>
    8923:	5f                   	pop    %edi
    8924:	58                   	pop    %eax
    8925:	68 98 da 00 00       	push   $0xda98
    892a:	68 79 9d 00 00       	push   $0x9d79
    892f:	e8 5b b6 ff ff       	call   3f8f <printk>
    8934:	58                   	pop    %eax
    8935:	5a                   	pop    %edx
    8936:	6a 5d                	push   $0x5d
    8938:	68 00 9d 00 00       	push   $0x9d00
    893d:	e8 e1 b6 ff ff       	call   4023 <assert_post_action>
    8942:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    8945:	83 ec 0c             	sub    $0xc,%esp
    8948:	56                   	push   %esi
    8949:	e8 2e cb ff ff       	call   547c <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    894e:	89 1c 24             	mov    %ebx,(%esp)
    8951:	ff 53 0c             	call   *0xc(%ebx)
    8954:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
    8957:	e8 0e cb ff ff       	call   546a <posix_irq_lock>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
    895c:	83 ec 0c             	sub    $0xc,%esp
    895f:	89 c6                	mov    %eax,%esi
    8961:	68 98 da 00 00       	push   $0xda98
    8966:	e8 e8 f8 ff ff       	call   8253 <z_spin_lock_valid>
    896b:	83 c4 10             	add    $0x10,%esp
    896e:	84 c0                	test   %al,%al
    8970:	75 38                	jne    89aa <z_clock_announce+0x195>
    8972:	6a 4a                	push   $0x4a
    8974:	68 00 9d 00 00       	push   $0x9d00
    8979:	68 35 9d 00 00       	push   $0x9d35
    897e:	68 e6 8b 00 00       	push   $0x8be6
    8983:	e8 07 b6 ff ff       	call   3f8f <printk>
    8988:	58                   	pop    %eax
    8989:	5a                   	pop    %edx
    898a:	68 98 da 00 00       	push   $0xda98
    898f:	68 4a 9d 00 00       	push   $0x9d4a
    8994:	e8 f6 b5 ff ff       	call   3f8f <printk>
    8999:	59                   	pop    %ecx
    899a:	5b                   	pop    %ebx
    899b:	6a 4a                	push   $0x4a
    899d:	68 00 9d 00 00       	push   $0x9d00
    89a2:	e8 7c b6 ff ff       	call   4023 <assert_post_action>
    89a7:	83 c4 10             	add    $0x10,%esp
	z_spin_lock_set_owner(l);
    89aa:	83 ec 0c             	sub    $0xc,%esp
    89ad:	68 98 da 00 00       	push   $0xda98
    89b2:	e8 de f8 ff ff       	call   8295 <z_spin_lock_set_owner>
    89b7:	83 c4 10             	add    $0x10,%esp
    89ba:	e9 d4 fe ff ff       	jmp    8893 <z_clock_announce+0x7e>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    89bf:	29 f9                	sub    %edi,%ecx
    89c1:	89 4b 08             	mov    %ecx,0x8(%ebx)
	}

	curr_tick += announce_remaining;
    89c4:	89 f8                	mov    %edi,%eax
	announce_remaining = 0;
    89c6:	c7 05 94 da 00 00 00 	movl   $0x0,0xda94
    89cd:	00 00 00 
	curr_tick += announce_remaining;
    89d0:	99                   	cltd   
    89d1:	03 45 e0             	add    -0x20(%ebp),%eax
    89d4:	13 55 e4             	adc    -0x1c(%ebp),%edx
    89d7:	a3 f8 d9 00 00       	mov    %eax,0xd9f8
    89dc:	89 15 fc d9 00 00    	mov    %edx,0xd9fc

	z_clock_set_timeout(next_timeout(), false);
    89e2:	e8 37 f9 ff ff       	call   831e <next_timeout>
    89e7:	57                   	push   %edi
    89e8:	57                   	push   %edi
    89e9:	6a 00                	push   $0x0
    89eb:	50                   	push   %eax
    89ec:	e8 94 b7 ff ff       	call   4185 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
    89f1:	c7 04 24 98 da 00 00 	movl   $0xda98,(%esp)
    89f8:	e8 75 f8 ff ff       	call   8272 <z_spin_unlock_valid>
    89fd:	83 c4 10             	add    $0x10,%esp
    8a00:	84 c0                	test   %al,%al
    8a02:	75 38                	jne    8a3c <z_clock_announce+0x227>
    8a04:	6a 5d                	push   $0x5d
    8a06:	68 00 9d 00 00       	push   $0x9d00
    8a0b:	68 62 9d 00 00       	push   $0x9d62
    8a10:	68 e6 8b 00 00       	push   $0x8be6
    8a15:	e8 75 b5 ff ff       	call   3f8f <printk>
    8a1a:	58                   	pop    %eax
    8a1b:	5a                   	pop    %edx
    8a1c:	68 98 da 00 00       	push   $0xda98
    8a21:	68 79 9d 00 00       	push   $0x9d79
    8a26:	e8 64 b5 ff ff       	call   3f8f <printk>
    8a2b:	59                   	pop    %ecx
    8a2c:	5b                   	pop    %ebx
    8a2d:	6a 5d                	push   $0x5d
    8a2f:	68 00 9d 00 00       	push   $0x9d00
    8a34:	e8 ea b5 ff ff       	call   4023 <assert_post_action>
    8a39:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
    8a3c:	89 75 08             	mov    %esi,0x8(%ebp)

	k_spin_unlock(&timeout_lock, key);
}
    8a3f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    8a42:	5b                   	pop    %ebx
    8a43:	5e                   	pop    %esi
    8a44:	5f                   	pop    %edi
    8a45:	5d                   	pop    %ebp
    8a46:	e9 31 ca ff ff       	jmp    547c <posix_irq_unlock>

00008a4b <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
    8a4b:	55                   	push   %ebp
    8a4c:	89 e5                	mov    %esp,%ebp
    8a4e:	56                   	push   %esi
    8a4f:	53                   	push   %ebx
    8a50:	8b 75 08             	mov    0x8(%ebp),%esi
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
    8a53:	8b 1c b5 30 8b 00 00 	mov    0x8b30(,%esi,4),%ebx
    8a5a:	39 1c b5 34 8b 00 00 	cmp    %ebx,0x8b34(,%esi,4)
    8a61:	76 1c                	jbe    8a7f <z_sys_device_do_config_level+0x34>
								info++) {
		int retval;
		const struct device_config *device_conf = info->config;

		retval = device_conf->init(info);
    8a63:	83 ec 0c             	sub    $0xc,%esp
    8a66:	8b 03                	mov    (%ebx),%eax
    8a68:	53                   	push   %ebx
    8a69:	ff 50 04             	call   *0x4(%eax)
    8a6c:	83 c4 10             	add    $0x10,%esp
		if (retval != 0) {
    8a6f:	85 c0                	test   %eax,%eax
    8a71:	74 07                	je     8a7a <z_sys_device_do_config_level+0x2f>
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
    8a73:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
								info++) {
    8a7a:	83 c3 0c             	add    $0xc,%ebx
    8a7d:	eb db                	jmp    8a5a <z_sys_device_do_config_level+0xf>
		} else {
			z_object_init(info);
		}
	}
}
    8a7f:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8a82:	5b                   	pop    %ebx
    8a83:	5e                   	pop    %esi
    8a84:	5d                   	pop    %ebp
    8a85:	c3                   	ret    

00008a86 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
    8a86:	55                   	push   %ebp
    8a87:	89 e5                	mov    %esp,%ebp

#if defined(CONFIG_FP_SHARING)
GEN_OFFSET_SYM(_thread_arch_t, excNestCount);
#endif

GEN_ABS_SYM_END
    8a89:	5d                   	pop    %ebp
    8a8a:	c3                   	ret    

Disassembly of section .fini:

00008a8c <_fini>:
    8a8c:	53                   	push   %ebx
    8a8d:	83 ec 08             	sub    $0x8,%esp
    8a90:	e8 8b a9 ff ff       	call   3420 <__x86.get_pc_thunk.bx>
    8a95:	81 c3 b3 34 00 00    	add    $0x34b3,%ebx
    8a9b:	83 c4 08             	add    $0x8,%esp
    8a9e:	5b                   	pop    %ebx
    8a9f:	c3                   	ret    
